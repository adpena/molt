use crate::object::accessors::object_field_init_ptr_raw;
use crate::object::layout::{range_start_bits, range_step_bits, range_stop_bits};
use crate::object::utf8_cache::{
    UTF8_CACHE_BLOCK, UTF8_CACHE_MIN_LEN, UTF8_COUNT_CACHE_SHARDS, UTF8_COUNT_PREFIX_MIN_LEN,
    UTF8_COUNT_TLS, Utf8CountCache, Utf8CountCacheEntry, Utf8IndexCache,
};
use crate::state::runtime_state::PythonVersionInfo;
use crate::*;
use getrandom::fill as getrandom_fill;
use memchr::{memchr, memmem};
use molt_obj_model::MoltObject;
use num_bigint::{BigInt, Sign};
use num_integer::Integer;
use num_traits::{Signed, ToPrimitive, Zero};
use std::borrow::Cow;
use std::cmp::Ordering;
use std::collections::{HashMap, HashSet};
use std::ffi::CStr;
#[cfg(not(target_arch = "wasm32"))]
use std::ffi::CString;
use std::io::{BufRead, BufReader, Write};
use std::sync::atomic::{AtomicU64, Ordering as AtomicOrdering};
use std::sync::{Arc, Mutex, OnceLock};
use unicode_casefold::{Locale, UnicodeCaseFold, Variant};
use unicode_ident::{is_xid_continue, is_xid_start};
use wtf8::{CodePoint, Wtf8};

mod unicode_digit_table {
    include!(concat!(env!("OUT_DIR"), "/unicode_digit_ranges.rs"));

    pub(crate) fn is_digit(code: u32) -> bool {
        let mut lo = 0usize;
        let mut hi = UNICODE_DIGIT_RANGES.len();
        while lo < hi {
            let mid = (lo + hi) / 2;
            let (start, end) = UNICODE_DIGIT_RANGES[mid];
            if code < start {
                hi = mid;
            } else if code > end {
                lo = mid + 1;
            } else {
                return true;
            }
        }
        false
    }
}

fn slice_bounds_from_args(
    _py: &PyToken<'_>,
    start_bits: u64,
    end_bits: u64,
    has_start: bool,
    has_end: bool,
    len: i64,
) -> (i64, i64, i64) {
    let msg = "slice indices must be integers or None or have an __index__ method";
    let start_obj = if has_start {
        Some(obj_from_bits(start_bits))
    } else {
        None
    };
    let end_obj = if has_end {
        Some(obj_from_bits(end_bits))
    } else {
        None
    };
    let mut start = if let Some(obj) = start_obj {
        if obj.is_none() {
            0
        } else {
            index_i64_from_obj(_py, start_bits, msg)
        }
    } else {
        0
    };
    let mut end = if let Some(obj) = end_obj {
        if obj.is_none() {
            len
        } else {
            index_i64_from_obj(_py, end_bits, msg)
        }
    } else {
        len
    };
    if start < 0 {
        start += len;
    }
    if end < 0 {
        end += len;
    }
    let start_raw = start;
    if start < 0 {
        start = 0;
    }
    if end < 0 {
        end = 0;
    }
    if start > len {
        start = len;
    }
    if end > len {
        end = len;
    }
    (start, end, start_raw)
}

fn slice_match(slice: &[u8], needle: &[u8], start_raw: i64, total: i64, suffix: bool) -> bool {
    if needle.is_empty() {
        return start_raw <= total;
    }
    if suffix {
        slice.ends_with(needle)
    } else {
        slice.starts_with(needle)
    }
}

fn range_components_bigint(ptr: *mut u8) -> Option<(BigInt, BigInt, BigInt)> {
    unsafe {
        let start_obj = obj_from_bits(range_start_bits(ptr));
        let stop_obj = obj_from_bits(range_stop_bits(ptr));
        let step_obj = obj_from_bits(range_step_bits(ptr));
        let start = to_bigint(start_obj)?;
        let stop = to_bigint(stop_obj)?;
        let step = to_bigint(step_obj)?;
        Some((start, stop, step))
    }
}

fn range_components_i64(ptr: *mut u8) -> Option<(i64, i64, i64)> {
    unsafe {
        let start = to_i64(obj_from_bits(range_start_bits(ptr)))?;
        let stop = to_i64(obj_from_bits(range_stop_bits(ptr)))?;
        let step = to_i64(obj_from_bits(range_step_bits(ptr)))?;
        if step == 0 {
            return None;
        }
        Some((start, stop, step))
    }
}

fn range_len_i128(start: i64, stop: i64, step: i64) -> i128 {
    if step == 0 {
        return 0;
    }
    let start_i = start as i128;
    let stop_i = stop as i128;
    let step_i = step as i128;
    if step_i > 0 {
        if start_i >= stop_i {
            return 0;
        }
        let span = stop_i - start_i - 1;
        return 1 + span / step_i;
    }
    if start_i <= stop_i {
        return 0;
    }
    let step_abs = -step_i;
    let span = start_i - stop_i - 1;
    1 + span / step_abs
}

fn range_value_at_index_i64(start: i64, stop: i64, step: i64, idx: i128) -> Option<i64> {
    if idx < 0 {
        return None;
    }
    let step_i = step as i128;
    let val = (start as i128).checked_add(step_i.checked_mul(idx)?)?;
    if step_i > 0 {
        if val >= stop as i128 {
            return None;
        }
    } else if step_i < 0 {
        if val <= stop as i128 {
            return None;
        }
    } else {
        return None;
    }
    i64::try_from(val).ok()
}

#[inline]
fn debug_index_enabled() -> bool {
    static FLAG: OnceLock<bool> = OnceLock::new();
    *FLAG.get_or_init(|| std::env::var("MOLT_DEBUG_INDEX").as_deref() == Ok("1"))
}

#[inline]
fn debug_index_list_enabled() -> bool {
    static FLAG: OnceLock<bool> = OnceLock::new();
    *FLAG.get_or_init(|| std::env::var("MOLT_DEBUG_INDEX_LIST").as_deref() == Ok("1"))
}

#[inline]
fn debug_store_index_enabled() -> bool {
    static FLAG: OnceLock<bool> = OnceLock::new();
    *FLAG.get_or_init(|| std::env::var("MOLT_DEBUG_STORE_INDEX").as_deref() == Ok("1"))
}

fn range_len_bigint(start: &BigInt, stop: &BigInt, step: &BigInt) -> BigInt {
    if step.is_zero() {
        return BigInt::from(0);
    }
    if step.is_positive() {
        if start >= stop {
            return BigInt::from(0);
        }
        let span = stop - start - 1;
        return BigInt::from(1) + span / step;
    }
    if start <= stop {
        return BigInt::from(0);
    }
    let step_abs = -step;
    let span = start - stop - 1;
    BigInt::from(1) + span / step_abs
}

fn alloc_range_from_bigints(_py: &PyToken<'_>, start: BigInt, stop: BigInt, step: BigInt) -> u64 {
    let start_bits = int_bits_from_bigint(_py, start);
    let stop_bits = int_bits_from_bigint(_py, stop);
    let step_bits = int_bits_from_bigint(_py, step);
    let ptr = alloc_range(_py, start_bits, stop_bits, step_bits);
    let range_bits = if ptr.is_null() {
        MoltObject::none().bits()
    } else {
        MoltObject::from_ptr(ptr).bits()
    };
    dec_ref_bits(_py, start_bits);
    dec_ref_bits(_py, stop_bits);
    dec_ref_bits(_py, step_bits);
    range_bits
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_range_new(start_bits: u64, stop_bits: u64, step_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let start_type = class_name_for_error(type_of_bits(_py, start_bits));
        let start_err = format!("'{start_type}' object cannot be interpreted as an integer");
        let Some(start) = index_bigint_from_obj(_py, start_bits, &start_err) else {
            return MoltObject::none().bits();
        };
        let stop_type = class_name_for_error(type_of_bits(_py, stop_bits));
        let stop_err = format!("'{stop_type}' object cannot be interpreted as an integer");
        let Some(stop) = index_bigint_from_obj(_py, stop_bits, &stop_err) else {
            return MoltObject::none().bits();
        };
        let step_type = class_name_for_error(type_of_bits(_py, step_bits));
        let step_err = format!("'{step_type}' object cannot be interpreted as an integer");
        let Some(step) = index_bigint_from_obj(_py, step_bits, &step_err) else {
            return MoltObject::none().bits();
        };
        if step.is_zero() {
            return raise_exception::<_>(_py, "ValueError", "range() arg 3 must not be zero");
        }
        alloc_range_from_bigints(_py, start, stop, step)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_list_from_range(start_bits: u64, stop_bits: u64, step_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let range_bits = molt_range_new(start_bits, stop_bits, step_bits);
        if obj_from_bits(range_bits).is_none() {
            return MoltObject::none().bits();
        }
        let Some(range_ptr) = obj_from_bits(range_bits).as_ptr() else {
            dec_ref_bits(_py, range_bits);
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(range_ptr) != TYPE_ID_RANGE {
                dec_ref_bits(_py, range_bits);
                return MoltObject::none().bits();
            }
            if let Some((start, stop, step)) = range_components_i64(range_ptr) {
                let len = range_len_i128(start, stop, step);
                if len <= 0 {
                    dec_ref_bits(_py, range_bits);
                    let list_ptr = alloc_list(_py, &[]);
                    return if list_ptr.is_null() {
                        MoltObject::none().bits()
                    } else {
                        MoltObject::from_ptr(list_ptr).bits()
                    };
                }
                if len <= usize::MAX as i128 {
                    let len_usize = len as usize;
                    let mut out = Vec::with_capacity(len_usize);
                    let mut cur = start;
                    for idx in 0..len_usize {
                        out.push(MoltObject::from_int(cur).bits());
                        if idx + 1 < len_usize {
                            let Some(next) = cur.checked_add(step) else {
                                let out_bits = list_from_iter_bits(_py, range_bits)
                                    .unwrap_or_else(|| MoltObject::none().bits());
                                dec_ref_bits(_py, range_bits);
                                return out_bits;
                            };
                            cur = next;
                        }
                    }
                    dec_ref_bits(_py, range_bits);
                    let list_ptr = alloc_list(_py, out.as_slice());
                    return if list_ptr.is_null() {
                        MoltObject::none().bits()
                    } else {
                        MoltObject::from_ptr(list_ptr).bits()
                    };
                }
            }
            let out_bits =
                list_from_iter_bits(_py, range_bits).unwrap_or_else(|| MoltObject::none().bits());
            dec_ref_bits(_py, range_bits);
            out_bits
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_slice_new(start_bits: u64, stop_bits: u64, step_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let ptr = alloc_slice_obj(_py, start_bits, stop_bits, step_bits);
        if ptr.is_null() {
            MoltObject::none().bits()
        } else {
            MoltObject::from_ptr(ptr).bits()
        }
    })
}

fn slice_indices_adjust(mut idx: BigInt, len: &BigInt, lower: &BigInt, upper: &BigInt) -> BigInt {
    if idx.is_negative() {
        idx += len;
    }
    if idx < *lower {
        return lower.clone();
    }
    if idx > *upper {
        return upper.clone();
    }
    idx
}

fn slice_reduce_tuple(_py: &PyToken<'_>, slice_ptr: *mut u8) -> u64 {
    unsafe {
        let start_bits = slice_start_bits(slice_ptr);
        let stop_bits = slice_stop_bits(slice_ptr);
        let step_bits = slice_step_bits(slice_ptr);
        let args_ptr = alloc_tuple(_py, &[start_bits, stop_bits, step_bits]);
        if args_ptr.is_null() {
            return MoltObject::none().bits();
        }
        let args_bits = MoltObject::from_ptr(args_ptr).bits();
        let class_bits = builtin_classes(_py).slice;
        let res_ptr = alloc_tuple(_py, &[class_bits, args_bits]);
        if res_ptr.is_null() {
            return MoltObject::none().bits();
        }
        MoltObject::from_ptr(res_ptr).bits()
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_slice_indices(slice_bits: u64, length_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let Some(slice_ptr) = obj_from_bits(slice_bits).as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(slice_ptr) != TYPE_ID_SLICE {
                return MoltObject::none().bits();
            }
            let msg = "slice indices must be integers or None or have an __index__ method";
            let Some(len) = index_bigint_from_obj(_py, length_bits, msg) else {
                return MoltObject::none().bits();
            };
            if len.is_negative() {
                return raise_exception::<_>(_py, "ValueError", "length should not be negative");
            }
            let start_obj = obj_from_bits(slice_start_bits(slice_ptr));
            let stop_obj = obj_from_bits(slice_stop_bits(slice_ptr));
            let step_obj = obj_from_bits(slice_step_bits(slice_ptr));
            let step = if step_obj.is_none() {
                BigInt::from(1)
            } else {
                let Some(step_val) = index_bigint_from_obj(_py, step_obj.bits(), msg) else {
                    return MoltObject::none().bits();
                };
                step_val
            };
            if step.is_zero() {
                return raise_exception::<_>(_py, "ValueError", "slice step cannot be zero");
            }
            let step_neg = step.is_negative();
            let lower = if step_neg {
                BigInt::from(-1)
            } else {
                BigInt::from(0)
            };
            let upper = if step_neg { &len - 1 } else { len.clone() };
            let start = if start_obj.is_none() {
                if step_neg {
                    upper.clone()
                } else {
                    lower.clone()
                }
            } else {
                let Some(idx) = index_bigint_from_obj(_py, start_obj.bits(), msg) else {
                    return MoltObject::none().bits();
                };
                slice_indices_adjust(idx, &len, &lower, &upper)
            };
            let stop = if stop_obj.is_none() {
                if step_neg {
                    lower.clone()
                } else {
                    upper.clone()
                }
            } else {
                let Some(idx) = index_bigint_from_obj(_py, stop_obj.bits(), msg) else {
                    return MoltObject::none().bits();
                };
                slice_indices_adjust(idx, &len, &lower, &upper)
            };
            let start_bits = int_bits_from_bigint(_py, start);
            let stop_bits = int_bits_from_bigint(_py, stop);
            let step_bits = int_bits_from_bigint(_py, step);
            let tuple_ptr = alloc_tuple(_py, &[start_bits, stop_bits, step_bits]);
            if tuple_ptr.is_null() {
                return MoltObject::none().bits();
            }
            MoltObject::from_ptr(tuple_ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_slice_hash(slice_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let Some(slice_ptr) = obj_from_bits(slice_bits).as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(slice_ptr) != TYPE_ID_SLICE {
                return MoltObject::none().bits();
            }
            let start_bits = slice_start_bits(slice_ptr);
            let stop_bits = slice_stop_bits(slice_ptr);
            let step_bits = slice_step_bits(slice_ptr);
            let Some(hash) = hash_slice_bits(_py, start_bits, stop_bits, step_bits) else {
                return MoltObject::none().bits();
            };
            int_bits_from_i64(_py, hash)
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_slice_eq(slice_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let Some(slice_ptr) = obj_from_bits(slice_bits).as_ptr() else {
            return not_implemented_bits(_py);
        };
        let Some(other_ptr) = obj_from_bits(other_bits).as_ptr() else {
            return not_implemented_bits(_py);
        };
        unsafe {
            if object_type_id(slice_ptr) != TYPE_ID_SLICE {
                return not_implemented_bits(_py);
            }
            if object_type_id(other_ptr) != TYPE_ID_SLICE {
                return not_implemented_bits(_py);
            }
            let start_eq = molt_eq(slice_start_bits(slice_ptr), slice_start_bits(other_ptr));
            if exception_pending(_py) {
                return MoltObject::none().bits();
            }
            if !is_truthy(_py, obj_from_bits(start_eq)) {
                return MoltObject::from_bool(false).bits();
            }
            let stop_eq = molt_eq(slice_stop_bits(slice_ptr), slice_stop_bits(other_ptr));
            if exception_pending(_py) {
                return MoltObject::none().bits();
            }
            if !is_truthy(_py, obj_from_bits(stop_eq)) {
                return MoltObject::from_bool(false).bits();
            }
            let step_eq = molt_eq(slice_step_bits(slice_ptr), slice_step_bits(other_ptr));
            if exception_pending(_py) {
                return MoltObject::none().bits();
            }
            if !is_truthy(_py, obj_from_bits(step_eq)) {
                return MoltObject::from_bool(false).bits();
            }
            MoltObject::from_bool(true).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_slice_reduce(slice_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let Some(slice_ptr) = obj_from_bits(slice_bits).as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(slice_ptr) != TYPE_ID_SLICE {
                return MoltObject::none().bits();
            }
            slice_reduce_tuple(_py, slice_ptr)
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_slice_reduce_ex(slice_bits: u64, _protocol_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, { molt_slice_reduce(slice_bits) })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_dataclass_new(
    name_bits: u64,
    field_names_bits: u64,
    values_bits: u64,
    flags_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let name_obj = obj_from_bits(name_bits);
        let name = match string_obj_to_owned(name_obj) {
            Some(val) => val,
            None => return raise_exception::<_>(_py, "TypeError", "dataclass name must be a str"),
        };
        let field_names_obj = obj_from_bits(field_names_bits);
        let field_names = match decode_string_list(field_names_obj) {
            Some(val) => val,
            None => {
                return raise_exception::<_>(
                    _py,
                    "TypeError",
                    "dataclass field names must be a list/tuple of str",
                );
            }
        };
        let values_obj = obj_from_bits(values_bits);
        let values = match decode_value_list(values_obj) {
            Some(val) => val,
            None => {
                return raise_exception::<_>(
                    _py,
                    "TypeError",
                    "dataclass values must be a list/tuple",
                );
            }
        };
        if field_names.len() != values.len() {
            return raise_exception::<_>(
                _py,
                "TypeError",
                "dataclass constructor argument mismatch",
            );
        }
        let flags = to_i64(obj_from_bits(flags_bits)).unwrap_or(0) as u64;
        let frozen = (flags & 0x1) != 0;
        let eq = (flags & 0x2) != 0;
        let repr = (flags & 0x4) != 0;
        let slots = (flags & 0x8) != 0;
        let desc = Box::new(DataclassDesc {
            name,
            field_names,
            frozen,
            eq,
            repr,
            slots,
            class_bits: 0,
            field_flags: Vec::new(),
            hash_mode: 0,
        });
        let desc_ptr = Box::into_raw(desc);

        let total = std::mem::size_of::<MoltHeader>()
            + std::mem::size_of::<*mut DataclassDesc>()
            + std::mem::size_of::<*mut Vec<u64>>()
            + std::mem::size_of::<u64>();
        let ptr = alloc_object(_py, total, TYPE_ID_DATACLASS);
        if ptr.is_null() {
            unsafe { drop(Box::from_raw(desc_ptr)) };
            return MoltObject::none().bits();
        }
        unsafe {
            let mut vec = Vec::with_capacity(values.len());
            vec.extend_from_slice(&values);
            for &val in values.iter() {
                inc_ref_bits(_py, val);
            }
            let vec_ptr = Box::into_raw(Box::new(vec));
            *(ptr as *mut *mut DataclassDesc) = desc_ptr;
            *(ptr.add(std::mem::size_of::<*mut DataclassDesc>()) as *mut *mut Vec<u64>) = vec_ptr;
            dataclass_set_dict_bits(_py, ptr, 0);
        }
        MoltObject::from_ptr(ptr).bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_dataclass_get(obj_bits: u64, index_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(obj_bits);
        let idx = match obj_from_bits(index_bits).as_int() {
            Some(val) => val,
            None => {
                return raise_exception::<_>(_py, "TypeError", "dataclass field index must be int");
            }
        };
        if let Some(ptr) = obj.as_ptr() {
            unsafe {
                if object_type_id(ptr) != TYPE_ID_DATACLASS {
                    return MoltObject::none().bits();
                }
                let fields = dataclass_fields_ref(ptr);
                if idx < 0 || idx as usize >= fields.len() {
                    return raise_exception::<_>(
                        _py,
                        "TypeError",
                        "dataclass field index out of range",
                    );
                }
                let val = fields[idx as usize];
                if is_missing_bits(_py, val) {
                    let desc_ptr = dataclass_desc_ptr(ptr);
                    let name = if !desc_ptr.is_null() {
                        let names = &(*desc_ptr).field_names;
                        names
                            .get(idx as usize)
                            .map(|s| s.as_str())
                            .unwrap_or("field")
                    } else {
                        "field"
                    };
                    return attr_error(_py, "dataclass", name) as u64;
                }
                inc_ref_bits(_py, val);
                return val;
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_dataclass_set(obj_bits: u64, index_bits: u64, val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(obj_bits);
        let idx = match obj_from_bits(index_bits).as_int() {
            Some(val) => val,
            None => {
                return raise_exception::<_>(_py, "TypeError", "dataclass field index must be int");
            }
        };
        if let Some(ptr) = obj.as_ptr() {
            unsafe {
                if object_type_id(ptr) != TYPE_ID_DATACLASS {
                    return MoltObject::none().bits();
                }
                let desc_ptr = dataclass_desc_ptr(ptr);
                if !desc_ptr.is_null() && (*desc_ptr).frozen {
                    return raise_exception::<_>(
                        _py,
                        "TypeError",
                        "cannot assign to frozen dataclass field",
                    );
                }
                let fields = dataclass_fields_mut(ptr);
                if idx < 0 || idx as usize >= fields.len() {
                    return raise_exception::<_>(
                        _py,
                        "TypeError",
                        "dataclass field index out of range",
                    );
                }
                let old_bits = fields[idx as usize];
                if old_bits != val_bits {
                    dec_ref_bits(_py, old_bits);
                    inc_ref_bits(_py, val_bits);
                    fields[idx as usize] = val_bits;
                }
                return obj_bits;
            }
        }
        MoltObject::none().bits()
    })
}

pub(crate) unsafe fn dataclass_set_class_raw(
    _py: &PyToken<'_>,
    ptr: *mut u8,
    class_bits: u64,
) -> u64 {
    unsafe {
        if object_type_id(ptr) != TYPE_ID_DATACLASS {
            return raise_exception::<_>(_py, "TypeError", "dataclass expects object");
        }
        if class_bits != 0 {
            let class_obj = obj_from_bits(class_bits);
            let Some(class_ptr) = class_obj.as_ptr() else {
                return raise_exception::<_>(_py, "TypeError", "class must be a type object");
            };
            if object_type_id(class_ptr) != TYPE_ID_TYPE {
                return raise_exception::<_>(_py, "TypeError", "class must be a type object");
            }
        }
        let desc_ptr = dataclass_desc_ptr(ptr);
        if !desc_ptr.is_null() {
            let old_bits = (*desc_ptr).class_bits;
            if old_bits != 0 {
                dec_ref_bits(_py, old_bits);
            }
            (*desc_ptr).class_bits = class_bits;
            if class_bits != 0 {
                inc_ref_bits(_py, class_bits);
            }
            object_set_class_bits(_py, ptr, class_bits);
            if class_bits != 0 {
                let class_obj = obj_from_bits(class_bits);
                if let Some(class_ptr) = class_obj.as_ptr() {
                    if object_type_id(class_ptr) == TYPE_ID_TYPE {
                        let flags_name =
                            attr_name_bits_from_bytes(_py, b"__molt_dataclass_field_flags__");
                        if let Some(flags_name) = flags_name {
                            if let Some(flags_bits) =
                                class_attr_lookup_raw_mro(_py, class_ptr, flags_name)
                            {
                                let flags_obj = obj_from_bits(flags_bits);
                                let flags_ptr = flags_obj.as_ptr();
                                if let Some(flags_ptr) = flags_ptr {
                                    let type_id = object_type_id(flags_ptr);
                                    if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                                        let elems = seq_vec_ref(flags_ptr);
                                        let mut out = Vec::with_capacity(elems.len());
                                        for &elem_bits in elems.iter() {
                                            let elem_obj = obj_from_bits(elem_bits);
                                            let Some(val) = to_i64(elem_obj) else {
                                                out.clear();
                                                break;
                                            };
                                            if val < 0 || val > u8::MAX as i64 {
                                                out.clear();
                                                break;
                                            }
                                            out.push(val as u8);
                                        }
                                        if !out.is_empty() {
                                            (*desc_ptr).field_flags = out;
                                        }
                                    }
                                }
                            }
                            dec_ref_bits(_py, flags_name);
                        }
                        let hash_name = attr_name_bits_from_bytes(_py, b"__molt_dataclass_hash__");
                        if let Some(hash_name) = hash_name {
                            if let Some(hash_bits) =
                                class_attr_lookup_raw_mro(_py, class_ptr, hash_name)
                            {
                                let hash_obj = obj_from_bits(hash_bits);
                                if let Some(val) = to_i64(hash_obj) {
                                    if val >= 0 && val <= u8::MAX as i64 {
                                        (*desc_ptr).hash_mode = val as u8;
                                    }
                                }
                            }
                            dec_ref_bits(_py, hash_name);
                        }
                    }
                }
            }
        }
        MoltObject::none().bits()
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_dataclass_set_class(obj_bits: u64, class_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(obj_bits);
        let Some(ptr) = obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "dataclass expects object");
        };
        unsafe { dataclass_set_class_raw(_py, ptr, class_bits) }
    })
}

// --- NaN-boxed ops ---

#[unsafe(no_mangle)]
pub extern "C" fn molt_add(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        if exception_pending(_py) {
            if std::env::var("MOLT_DEBUG_ADD").as_deref() == Ok("1") {
                eprintln!("molt_add: exception pending at entry");
            }
            return MoltObject::none().bits();
        }
        let lhs = obj_from_bits(a);
        let rhs = obj_from_bits(b);
        if let (Some(li), Some(ri)) = (to_i64(lhs), to_i64(rhs)) {
            let res = li as i128 + ri as i128;
            return int_bits_from_i128(_py, res);
        }
        if let (Some(lp), Some(rp)) = (lhs.as_ptr(), rhs.as_ptr()) {
            unsafe {
                let ltype = object_type_id(lp);
                let rtype = object_type_id(rp);
                if ltype == TYPE_ID_STRING && rtype == TYPE_ID_STRING {
                    let l_len = string_len(lp);
                    let r_len = string_len(rp);
                    let l_bytes = std::slice::from_raw_parts(string_bytes(lp), l_len);
                    let r_bytes = std::slice::from_raw_parts(string_bytes(rp), r_len);
                    if let Some(bits) = concat_bytes_like(_py, l_bytes, r_bytes, TYPE_ID_STRING) {
                        return bits;
                    }
                    return MoltObject::none().bits();
                }
                if ltype == TYPE_ID_BYTES && rtype == TYPE_ID_BYTES {
                    let l_len = bytes_len(lp);
                    let r_len = bytes_len(rp);
                    let l_bytes = std::slice::from_raw_parts(bytes_data(lp), l_len);
                    let r_bytes = std::slice::from_raw_parts(bytes_data(rp), r_len);
                    if let Some(bits) = concat_bytes_like(_py, l_bytes, r_bytes, TYPE_ID_BYTES) {
                        return bits;
                    }
                    return MoltObject::none().bits();
                }
                if ltype == TYPE_ID_BYTEARRAY && rtype == TYPE_ID_BYTEARRAY {
                    let l_len = bytes_len(lp);
                    let r_len = bytes_len(rp);
                    let l_bytes = std::slice::from_raw_parts(bytes_data(lp), l_len);
                    let r_bytes = std::slice::from_raw_parts(bytes_data(rp), r_len);
                    if let Some(bits) = concat_bytes_like(_py, l_bytes, r_bytes, TYPE_ID_BYTEARRAY)
                    {
                        return bits;
                    }
                    return MoltObject::none().bits();
                }
                if ltype == TYPE_ID_LIST && rtype == TYPE_ID_LIST {
                    let l_len = list_len(lp);
                    let r_len = list_len(rp);
                    let l_elems = seq_vec_ref(lp);
                    let r_elems = seq_vec_ref(rp);
                    let mut combined = Vec::with_capacity(l_len + r_len);
                    combined.extend_from_slice(l_elems);
                    combined.extend_from_slice(r_elems);
                    let ptr = alloc_list(_py, &combined);
                    if ptr.is_null() {
                        return MoltObject::none().bits();
                    }
                    return MoltObject::from_ptr(ptr).bits();
                }
                if ltype == TYPE_ID_TUPLE && rtype == TYPE_ID_TUPLE {
                    let l_len = tuple_len(lp);
                    let r_len = tuple_len(rp);
                    let l_elems = seq_vec_ref(lp);
                    let r_elems = seq_vec_ref(rp);
                    let mut combined = Vec::with_capacity(l_len + r_len);
                    combined.extend_from_slice(l_elems);
                    combined.extend_from_slice(r_elems);
                    let ptr = alloc_tuple(_py, &combined);
                    if ptr.is_null() {
                        return MoltObject::none().bits();
                    }
                    return MoltObject::from_ptr(ptr).bits();
                }
            }
        }
        if let (Some(l_big), Some(r_big)) = (to_bigint(lhs), to_bigint(rhs)) {
            let res = l_big + r_big;
            if let Some(i) = bigint_to_inline(&res) {
                return MoltObject::from_int(i).bits();
            }
            return bigint_bits(_py, res);
        }
        if let Some((lf, rf)) = float_pair_from_obj(_py, lhs, rhs) {
            return MoltObject::from_float(lf + rf).bits();
        }
        if complex_ptr_from_bits(a).is_some() || complex_ptr_from_bits(b).is_some() {
            match (
                complex_from_obj_strict(_py, lhs),
                complex_from_obj_strict(_py, rhs),
            ) {
                (Ok(Some(lc)), Ok(Some(rc))) => {
                    return complex_bits(_py, lc.re + rc.re, lc.im + rc.im);
                }
                (Err(_), _) | (_, Err(_)) => {
                    return raise_exception::<_>(
                        _py,
                        "OverflowError",
                        "int too large to convert to float",
                    );
                }
                _ => {}
            }
        }
        unsafe {
            let add_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.add_name, b"__add__");
            let radd_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.radd_name, b"__radd__");
            if let Some(res_bits) = call_binary_dunder(_py, a, b, add_name_bits, radd_name_bits) {
                return res_bits;
            }
        }
        binary_type_error(_py, lhs, rhs, "+")
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_inplace_add(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        if let Some(ptr) = lhs.as_ptr() {
            unsafe {
                let ltype = object_type_id(ptr);
                if ltype == TYPE_ID_LIST {
                    let _ = molt_list_extend(a, b);
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    inc_ref_bits(_py, a);
                    return a;
                }
                if ltype == TYPE_ID_BYTEARRAY {
                    if bytearray_concat_in_place(_py, ptr, b) {
                        inc_ref_bits(_py, a);
                        return a;
                    }
                    return MoltObject::none().bits();
                }
            }
        }
        unsafe {
            let iadd_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.iadd_name, b"__iadd__");
            if let Some(res_bits) = call_inplace_dunder(_py, a, b, iadd_name_bits) {
                return res_bits;
            }
        }
        molt_add(a, b)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_sub(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        let rhs = obj_from_bits(b);
        if let (Some(li), Some(ri)) = (to_i64(lhs), to_i64(rhs)) {
            let res = li as i128 - ri as i128;
            return int_bits_from_i128(_py, res);
        }
        if let (Some(l_big), Some(r_big)) = (to_bigint(lhs), to_bigint(rhs)) {
            let res = l_big - r_big;
            if let Some(i) = bigint_to_inline(&res) {
                return MoltObject::from_int(i).bits();
            }
            return bigint_bits(_py, res);
        }
        if let Some((lf, rf)) = float_pair_from_obj(_py, lhs, rhs) {
            return MoltObject::from_float(lf - rf).bits();
        }
        if complex_ptr_from_bits(a).is_some() || complex_ptr_from_bits(b).is_some() {
            match (
                complex_from_obj_strict(_py, lhs),
                complex_from_obj_strict(_py, rhs),
            ) {
                (Ok(Some(lc)), Ok(Some(rc))) => {
                    return complex_bits(_py, lc.re - rc.re, lc.im - rc.im);
                }
                (Err(_), _) | (_, Err(_)) => {
                    return raise_exception::<_>(
                        _py,
                        "OverflowError",
                        "int too large to convert to float",
                    );
                }
                _ => {}
            }
        }
        if let (Some(lp), Some(rp)) = (lhs.as_ptr(), rhs.as_ptr()) {
            unsafe {
                let ltype = object_type_id(lp);
                let rtype = object_type_id(rp);
                if is_set_like_type(ltype) && is_set_like_type(rtype) {
                    return set_like_difference(_py, lp, rp, ltype);
                }
                if (is_set_like_type(ltype) || is_set_view_type(ltype))
                    && (is_set_like_type(rtype) || is_set_view_type(rtype))
                {
                    let (lhs_ptr, lhs_bits) = if is_set_like_type(ltype) {
                        (lp, None)
                    } else {
                        let Some(bits) = dict_view_as_set_bits(_py, lp, ltype) else {
                            return MoltObject::none().bits();
                        };
                        let Some(ptr) = obj_from_bits(bits).as_ptr() else {
                            dec_ref_bits(_py, bits);
                            return MoltObject::none().bits();
                        };
                        (ptr, Some(bits))
                    };
                    let (rhs_ptr, rhs_bits) = if is_set_like_type(rtype) {
                        (rp, None)
                    } else {
                        let Some(bits) = dict_view_as_set_bits(_py, rp, rtype) else {
                            if let Some(bits) = lhs_bits {
                                dec_ref_bits(_py, bits);
                            }
                            return MoltObject::none().bits();
                        };
                        let Some(ptr) = obj_from_bits(bits).as_ptr() else {
                            if let Some(bits) = lhs_bits {
                                dec_ref_bits(_py, bits);
                            }
                            dec_ref_bits(_py, bits);
                            return MoltObject::none().bits();
                        };
                        (ptr, Some(bits))
                    };
                    let res = set_like_difference(_py, lhs_ptr, rhs_ptr, TYPE_ID_SET);
                    if let Some(bits) = lhs_bits {
                        dec_ref_bits(_py, bits);
                    }
                    if let Some(bits) = rhs_bits {
                        dec_ref_bits(_py, bits);
                    }
                    return res;
                }
            }
        }
        unsafe {
            let sub_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.sub_name, b"__sub__");
            let rsub_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.rsub_name, b"__rsub__");
            if let Some(res_bits) = call_binary_dunder(_py, a, b, sub_name_bits, rsub_name_bits) {
                return res_bits;
            }
        }
        binary_type_error(_py, lhs, rhs, "-")
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_inplace_sub(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        if let Some(ptr) = lhs.as_ptr() {
            unsafe {
                if object_type_id(ptr) == TYPE_ID_SET {
                    let rhs = obj_from_bits(b);
                    let ok = rhs
                        .as_ptr()
                        .is_some_and(|rhs_ptr| is_set_inplace_rhs_type(object_type_id(rhs_ptr)));
                    if !ok {
                        return raise_unsupported_inplace(_py, "-=", a, b);
                    }
                    let _ = molt_set_difference_update(a, b);
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    inc_ref_bits(_py, a);
                    return a;
                }
            }
        }
        unsafe {
            let isub_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.isub_name, b"__isub__");
            if let Some(res_bits) = call_inplace_dunder(_py, a, b, isub_name_bits) {
                return res_bits;
            }
        }
        molt_sub(a, b)
    })
}

fn repeat_sequence(_py: &PyToken<'_>, ptr: *mut u8, count: i64) -> Option<u64> {
    unsafe {
        let type_id = object_type_id(ptr);
        if count <= 0 {
            let out_ptr = match type_id {
                TYPE_ID_LIST => alloc_list(_py, &[]),
                TYPE_ID_TUPLE => alloc_tuple(_py, &[]),
                TYPE_ID_STRING => alloc_string(_py, &[]),
                TYPE_ID_BYTES => alloc_bytes(_py, &[]),
                TYPE_ID_BYTEARRAY => alloc_bytearray(_py, &[]),
                _ => return None,
            };
            if out_ptr.is_null() {
                return raise_exception::<_>(_py, "MemoryError", "out of memory");
            }
            return Some(MoltObject::from_ptr(out_ptr).bits());
        }
        if count == 1 && type_id == TYPE_ID_TUPLE {
            let bits = MoltObject::from_ptr(ptr).bits();
            inc_ref_bits(_py, bits);
            return Some(bits);
        }

        let times = count as usize;
        match type_id {
            TYPE_ID_LIST => {
                let elems = seq_vec_ref(ptr);
                let total = match elems.len().checked_mul(times) {
                    Some(total) => total,
                    None => return raise_exception::<_>(_py, "MemoryError", "out of memory"),
                };
                let mut combined = Vec::with_capacity(total);
                for _ in 0..times {
                    combined.extend_from_slice(elems);
                }
                let out_ptr = alloc_list(_py, &combined);
                if out_ptr.is_null() {
                    return raise_exception::<_>(_py, "MemoryError", "out of memory");
                }
                Some(MoltObject::from_ptr(out_ptr).bits())
            }
            TYPE_ID_TUPLE => {
                let elems = seq_vec_ref(ptr);
                let total = match elems.len().checked_mul(times) {
                    Some(total) => total,
                    None => return raise_exception::<_>(_py, "MemoryError", "out of memory"),
                };
                let mut combined = Vec::with_capacity(total);
                for _ in 0..times {
                    combined.extend_from_slice(elems);
                }
                let out_ptr = alloc_tuple(_py, &combined);
                if out_ptr.is_null() {
                    return raise_exception::<_>(_py, "MemoryError", "out of memory");
                }
                Some(MoltObject::from_ptr(out_ptr).bits())
            }
            TYPE_ID_STRING => {
                let len = string_len(ptr);
                let bytes = std::slice::from_raw_parts(string_bytes(ptr), len);
                let total = match len.checked_mul(times) {
                    Some(total) => total,
                    None => return raise_exception::<_>(_py, "MemoryError", "out of memory"),
                };
                let out_ptr = alloc_bytes_like_with_len(_py, total, TYPE_ID_STRING);
                if out_ptr.is_null() {
                    return raise_exception::<_>(_py, "MemoryError", "out of memory");
                }
                let data_ptr = out_ptr.add(std::mem::size_of::<usize>());
                let out_slice = std::slice::from_raw_parts_mut(data_ptr, total);
                fill_repeated_bytes(out_slice, bytes);
                Some(MoltObject::from_ptr(out_ptr).bits())
            }
            TYPE_ID_BYTES => {
                let len = bytes_len(ptr);
                let bytes = std::slice::from_raw_parts(bytes_data(ptr), len);
                let total = match len.checked_mul(times) {
                    Some(total) => total,
                    None => return raise_exception::<_>(_py, "MemoryError", "out of memory"),
                };
                let out_ptr = alloc_bytes_like_with_len(_py, total, TYPE_ID_BYTES);
                if out_ptr.is_null() {
                    return raise_exception::<_>(_py, "MemoryError", "out of memory");
                }
                let data_ptr = out_ptr.add(std::mem::size_of::<usize>());
                let out_slice = std::slice::from_raw_parts_mut(data_ptr, total);
                fill_repeated_bytes(out_slice, bytes);
                Some(MoltObject::from_ptr(out_ptr).bits())
            }
            TYPE_ID_BYTEARRAY => {
                let len = bytes_len(ptr);
                let bytes = std::slice::from_raw_parts(bytes_data(ptr), len);
                let total = match len.checked_mul(times) {
                    Some(total) => total,
                    None => return raise_exception::<_>(_py, "MemoryError", "out of memory"),
                };
                let mut out = Vec::with_capacity(total);
                for _ in 0..times {
                    out.extend_from_slice(bytes);
                }
                let out_ptr = alloc_bytearray(_py, &out);
                if out_ptr.is_null() {
                    return raise_exception::<_>(_py, "MemoryError", "out of memory");
                }
                Some(MoltObject::from_ptr(out_ptr).bits())
            }
            _ => None,
        }
    }
}

unsafe fn list_repeat_in_place(_py: &PyToken<'_>, ptr: *mut u8, count: i64) -> bool {
    unsafe {
        let elems = seq_vec(ptr);
        if count <= 0 {
            for &item in elems.iter() {
                dec_ref_bits(_py, item);
            }
            elems.clear();
            return true;
        }
        let count = match usize::try_from(count) {
            Ok(val) => val,
            Err(_) => {
                return raise_exception::<_>(
                    _py,
                    "OverflowError",
                    "cannot fit 'int' into an index-sized integer",
                );
            }
        };
        if count == 1 {
            return true;
        }
        let snapshot = elems.clone();
        if snapshot.is_empty() {
            return true;
        }
        let total = match snapshot.len().checked_mul(count) {
            Some(total) => total,
            None => {
                return raise_exception::<_>(
                    _py,
                    "OverflowError",
                    "cannot fit 'int' into an index-sized integer",
                );
            }
        };
        elems.reserve(total.saturating_sub(snapshot.len()));
        for _ in 1..count {
            for &item in snapshot.iter() {
                elems.push(item);
                inc_ref_bits(_py, item);
            }
        }
        true
    }
}

unsafe fn bytearray_repeat_in_place(_py: &PyToken<'_>, ptr: *mut u8, count: i64) -> bool {
    unsafe {
        let elems = bytearray_vec(ptr);
        if count <= 0 {
            elems.clear();
            return true;
        }
        let count = match usize::try_from(count) {
            Ok(val) => val,
            Err(_) => {
                return raise_exception::<_>(
                    _py,
                    "OverflowError",
                    "cannot fit 'int' into an index-sized integer",
                );
            }
        };
        if count == 1 {
            return true;
        }
        let snapshot = elems.clone();
        if snapshot.is_empty() {
            return true;
        }
        let total = match snapshot.len().checked_mul(count) {
            Some(total) => total,
            None => {
                return raise_exception::<_>(
                    _py,
                    "OverflowError",
                    "cannot fit 'int' into an index-sized integer",
                );
            }
        };
        elems.reserve(total.saturating_sub(snapshot.len()));
        for _ in 1..count {
            elems.extend_from_slice(&snapshot);
        }
        true
    }
}

unsafe fn bytearray_concat_in_place(_py: &PyToken<'_>, ptr: *mut u8, other_bits: u64) -> bool {
    unsafe {
        let other = obj_from_bits(other_bits);
        let Some(other_ptr) = other.as_ptr() else {
            let msg = format!("can't concat {} to bytearray", type_name(_py, other));
            return raise_exception::<_>(_py, "TypeError", &msg);
        };
        let other_type = object_type_id(other_ptr);
        let payload = if other_type == TYPE_ID_MEMORYVIEW {
            if let Some(slice) = memoryview_bytes_slice(other_ptr) {
                slice.to_vec()
            } else if let Some(buf) = memoryview_collect_bytes(other_ptr) {
                buf
            } else {
                let msg = format!("can't concat {} to bytearray", type_name(_py, other));
                return raise_exception::<_>(_py, "TypeError", &msg);
            }
        } else if other_type == TYPE_ID_BYTES || other_type == TYPE_ID_BYTEARRAY {
            if other_ptr == ptr {
                bytearray_vec_ref(ptr).clone()
            } else {
                bytes_like_slice_raw(other_ptr).unwrap_or(&[]).to_vec()
            }
        } else {
            let msg = format!("can't concat {} to bytearray", type_name(_py, other));
            return raise_exception::<_>(_py, "TypeError", &msg);
        };
        bytearray_vec(ptr).extend_from_slice(&payload);
        true
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_inplace_mul(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        if let Some(ptr) = lhs.as_ptr() {
            unsafe {
                let ltype = object_type_id(ptr);
                if ltype == TYPE_ID_LIST || ltype == TYPE_ID_BYTEARRAY {
                    let rhs_type = type_name(_py, obj_from_bits(b));
                    let msg = format!("can't multiply sequence by non-int of type '{rhs_type}'");
                    let count = index_i64_from_obj(_py, b, &msg);
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    let ok = if ltype == TYPE_ID_LIST {
                        list_repeat_in_place(_py, ptr, count)
                    } else {
                        bytearray_repeat_in_place(_py, ptr, count)
                    };
                    if !ok || exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    inc_ref_bits(_py, a);
                    return a;
                }
            }
        }
        molt_mul(a, b)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_mul(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        let rhs = obj_from_bits(b);
        if let (Some(li), Some(ri)) = (to_i64(lhs), to_i64(rhs)) {
            let res = li as i128 * ri as i128;
            return int_bits_from_i128(_py, res);
        }
        if let Some(count) = to_i64(lhs) {
            if let Some(ptr) = rhs.as_ptr() {
                if let Some(bits) = repeat_sequence(_py, ptr, count) {
                    return bits;
                }
            }
        }
        if let Some(count) = to_i64(rhs) {
            if let Some(ptr) = lhs.as_ptr() {
                if let Some(bits) = repeat_sequence(_py, ptr, count) {
                    return bits;
                }
            }
        }
        if let (Some(l_big), Some(r_big)) = (to_bigint(lhs), to_bigint(rhs)) {
            let res = l_big * r_big;
            if let Some(i) = bigint_to_inline(&res) {
                return MoltObject::from_int(i).bits();
            }
            return bigint_bits(_py, res);
        }
        if let Some((lf, rf)) = float_pair_from_obj(_py, lhs, rhs) {
            return MoltObject::from_float(lf * rf).bits();
        }
        if complex_ptr_from_bits(a).is_some() || complex_ptr_from_bits(b).is_some() {
            match (
                complex_from_obj_strict(_py, lhs),
                complex_from_obj_strict(_py, rhs),
            ) {
                (Ok(Some(lc)), Ok(Some(rc))) => {
                    let re = lc.re * rc.re - lc.im * rc.im;
                    let im = lc.im * rc.re + lc.re * rc.im;
                    return complex_bits(_py, re, im);
                }
                (Err(_), _) | (_, Err(_)) => {
                    return raise_exception::<_>(
                        _py,
                        "OverflowError",
                        "int too large to convert to float",
                    );
                }
                _ => {}
            }
        }
        unsafe {
            let mul_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.mul_name, b"__mul__");
            let rmul_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.rmul_name, b"__rmul__");
            if let Some(res_bits) = call_binary_dunder(_py, a, b, mul_name_bits, rmul_name_bits) {
                return res_bits;
            }
        }
        binary_type_error(_py, lhs, rhs, "*")
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_div(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        let rhs = obj_from_bits(b);
        if let Some((lf, rf)) = float_pair_from_obj(_py, lhs, rhs) {
            if rf == 0.0 {
                return raise_exception::<_>(_py, "ZeroDivisionError", "division by zero");
            }
            return MoltObject::from_float(lf / rf).bits();
        }
        if complex_ptr_from_bits(a).is_some() || complex_ptr_from_bits(b).is_some() {
            match (
                complex_from_obj_strict(_py, lhs),
                complex_from_obj_strict(_py, rhs),
            ) {
                (Ok(Some(lc)), Ok(Some(rc))) => {
                    let denom = rc.re * rc.re + rc.im * rc.im;
                    if denom == 0.0 {
                        return raise_exception::<_>(_py, "ZeroDivisionError", "division by zero");
                    }
                    let re = (lc.re * rc.re + lc.im * rc.im) / denom;
                    let im = (lc.im * rc.re - lc.re * rc.im) / denom;
                    return complex_bits(_py, re, im);
                }
                (Err(_), _) | (_, Err(_)) => {
                    return raise_exception::<_>(
                        _py,
                        "OverflowError",
                        "int too large to convert to float",
                    );
                }
                _ => {}
            }
        }
        if bigint_ptr_from_bits(a).is_some() || bigint_ptr_from_bits(b).is_some() {
            return raise_exception::<_>(_py, "OverflowError", "int too large to convert to float");
        }
        unsafe {
            let div_name_bits = intern_static_name(
                _py,
                &runtime_state(_py).interned.truediv_name,
                b"__truediv__",
            );
            let rdiv_name_bits = intern_static_name(
                _py,
                &runtime_state(_py).interned.rtruediv_name,
                b"__rtruediv__",
            );
            if let Some(res_bits) = call_binary_dunder(_py, a, b, div_name_bits, rdiv_name_bits) {
                return res_bits;
            }
        }
        raise_exception::<_>(_py, "TypeError", "unsupported operand type(s) for /")
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_floordiv(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        let rhs = obj_from_bits(b);
        if let (Some(li), Some(ri)) = (to_i64(lhs), to_i64(rhs)) {
            if ri == 0 {
                return raise_exception::<_>(
                    _py,
                    "ZeroDivisionError",
                    "integer division or modulo by zero",
                );
            }
            return MoltObject::from_int(li.div_euclid(ri)).bits();
        }
        if let (Some(l_big), Some(r_big)) = (to_bigint(lhs), to_bigint(rhs)) {
            if r_big.is_zero() {
                return raise_exception::<_>(
                    _py,
                    "ZeroDivisionError",
                    "integer division or modulo by zero",
                );
            }
            let res = l_big.div_floor(&r_big);
            if let Some(i) = bigint_to_inline(&res) {
                return MoltObject::from_int(i).bits();
            }
            return bigint_bits(_py, res);
        }
        if let Some((lf, rf)) = float_pair_from_obj(_py, lhs, rhs) {
            if rf == 0.0 {
                return raise_exception::<_>(
                    _py,
                    "ZeroDivisionError",
                    "float floor division by zero",
                );
            }
            return MoltObject::from_float((lf / rf).floor()).bits();
        }
        unsafe {
            let div_name_bits = intern_static_name(
                _py,
                &runtime_state(_py).interned.floordiv_name,
                b"__floordiv__",
            );
            let rdiv_name_bits = intern_static_name(
                _py,
                &runtime_state(_py).interned.rfloordiv_name,
                b"__rfloordiv__",
            );
            if let Some(res_bits) = call_binary_dunder(_py, a, b, div_name_bits, rdiv_name_bits) {
                return res_bits;
            }
        }
        raise_exception::<_>(_py, "TypeError", "unsupported operand type(s) for //")
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_mod(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        let rhs = obj_from_bits(b);
        if let (Some(li), Some(ri)) = (to_i64(lhs), to_i64(rhs)) {
            if ri == 0 {
                return raise_exception::<_>(
                    _py,
                    "ZeroDivisionError",
                    "integer division or modulo by zero",
                );
            }
            let mut rem = li % ri;
            if rem != 0 && (rem > 0) != (ri > 0) {
                rem += ri;
            }
            return MoltObject::from_int(rem).bits();
        }
        if let (Some(l_big), Some(r_big)) = (to_bigint(lhs), to_bigint(rhs)) {
            if r_big.is_zero() {
                return raise_exception::<_>(
                    _py,
                    "ZeroDivisionError",
                    "integer division or modulo by zero",
                );
            }
            let res = l_big.mod_floor(&r_big);
            if let Some(i) = bigint_to_inline(&res) {
                return MoltObject::from_int(i).bits();
            }
            return bigint_bits(_py, res);
        }
        if let Some((lf, rf)) = float_pair_from_obj(_py, lhs, rhs) {
            if rf == 0.0 {
                return raise_exception::<_>(_py, "ZeroDivisionError", "float modulo");
            }
            let mut rem = lf % rf;
            if rem != 0.0 && (rem > 0.0) != (rf > 0.0) {
                rem += rf;
            }
            return MoltObject::from_float(rem).bits();
        }
        raise_exception::<_>(_py, "TypeError", "unsupported operand type(s) for %")
    })
}

fn complex_pow(base: ComplexParts, exp: ComplexParts) -> Result<ComplexParts, ()> {
    if base.re == 0.0 && base.im == 0.0 {
        if exp.re == 0.0 && exp.im == 0.0 {
            return Ok(ComplexParts { re: 1.0, im: 0.0 });
        }
        if exp.im != 0.0 || exp.re < 0.0 {
            return Err(());
        }
        return Ok(ComplexParts { re: 0.0, im: 0.0 });
    }
    let r = (base.re * base.re + base.im * base.im).sqrt();
    let theta = base.im.atan2(base.re);
    let log_r = r.ln();
    let u = exp.re * log_r - exp.im * theta;
    let v = exp.im * log_r + exp.re * theta;
    let exp_u = u.exp();
    Ok(ComplexParts {
        re: exp_u * v.cos(),
        im: exp_u * v.sin(),
    })
}

fn pow_i64_checked(base: i64, exp: i64) -> Option<i64> {
    if exp < 0 {
        return None;
    }
    let mut result: i128 = 1;
    let mut base_val: i128 = base as i128;
    let mut exp_val = exp as u64;
    let max = (1i128 << 46) - 1;
    let min = -(1i128 << 46);
    while exp_val > 0 {
        if (exp_val & 1) != 0 {
            result = result.saturating_mul(base_val);
            if result > max || result < min {
                return None;
            }
        }
        exp_val >>= 1;
        if exp_val > 0 {
            base_val = base_val.saturating_mul(base_val);
            if base_val > max || base_val < min {
                return None;
            }
        }
    }
    Some(result as i64)
}

fn mod_py_i128(value: i128, modulus: i128) -> i128 {
    let mut rem = value % modulus;
    if rem != 0 && (rem > 0) != (modulus > 0) {
        rem += modulus;
    }
    rem
}

fn mod_pow_i128(_py: &PyToken<'_>, mut base: i128, exp: i64, modulus: i128) -> i128 {
    let mut result: i128 = 1;
    base = mod_py_i128(base, modulus);
    let mut exp_val = exp as u64;
    while exp_val > 0 {
        if (exp_val & 1) != 0 {
            result = mod_py_i128(result * base, modulus);
        }
        exp_val >>= 1;
        if exp_val > 0 {
            base = mod_py_i128(base * base, modulus);
        }
    }
    mod_py_i128(result, modulus)
}

fn egcd_i128(a: i128, b: i128) -> (i128, i128, i128) {
    if b == 0 {
        return (a, 1, 0);
    }
    let (g, x, y) = egcd_i128(b, a % b);
    (g, y, x - (a / b) * y)
}

fn mod_inverse_i128(_py: &PyToken<'_>, value: i128, modulus: i128) -> Option<i128> {
    let (g, x, _) = egcd_i128(value, modulus);
    if g == 1 || g == -1 {
        Some(mod_py_i128(x, modulus))
    } else {
        None
    }
}

fn mod_pow_bigint(base: &BigInt, exp: u64, modulus: &BigInt) -> BigInt {
    let mut result = BigInt::from(1);
    let mut base_val = base.mod_floor(modulus);
    let mut exp_val = exp;
    while exp_val > 0 {
        if (exp_val & 1) != 0 {
            result = (result * &base_val).mod_floor(modulus);
        }
        exp_val >>= 1;
        if exp_val > 0 {
            base_val = (&base_val * &base_val).mod_floor(modulus);
        }
    }
    result
}

fn egcd_bigint(a: BigInt, b: BigInt) -> (BigInt, BigInt, BigInt) {
    if b.is_zero() {
        return (a, BigInt::from(1), BigInt::from(0));
    }
    let (q, r) = a.div_mod_floor(&b);
    let (g, x, y) = egcd_bigint(b, r);
    (g, y.clone(), x - q * y)
}

fn mod_inverse_bigint(value: BigInt, modulus: &BigInt) -> Option<BigInt> {
    let (g, x, _) = egcd_bigint(value, modulus.clone());
    if g == BigInt::from(1) || g == BigInt::from(-1) {
        Some(x.mod_floor(modulus))
    } else {
        None
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_pow(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        let rhs = obj_from_bits(b);
        if complex_ptr_from_bits(a).is_some() || complex_ptr_from_bits(b).is_some() {
            match (
                complex_from_obj_strict(_py, lhs),
                complex_from_obj_strict(_py, rhs),
            ) {
                (Ok(Some(base)), Ok(Some(exp))) => {
                    return match complex_pow(base, exp) {
                        Ok(out) => complex_bits(_py, out.re, out.im),
                        Err(()) => raise_exception::<_>(
                            _py,
                            "ZeroDivisionError",
                            "zero to a negative or complex power",
                        ),
                    };
                }
                (Err(_), _) | (_, Err(_)) => {
                    return raise_exception::<_>(
                        _py,
                        "OverflowError",
                        "int too large to convert to float",
                    );
                }
                _ => {}
            }
        }
        if let (Some(li), Some(ri)) = (to_i64(lhs), to_i64(rhs)) {
            if ri >= 0 {
                if let Some(res) = pow_i64_checked(li, ri) {
                    return MoltObject::from_int(res).bits();
                }
                let res = BigInt::from(li).pow(ri as u32);
                if let Some(i) = bigint_to_inline(&res) {
                    return MoltObject::from_int(i).bits();
                }
                return bigint_bits(_py, res);
            }
            let lf = li as f64;
            let rf = ri as f64;
            if lf == 0.0 && rf < 0.0 {
                return raise_exception::<_>(
                    _py,
                    "ZeroDivisionError",
                    "0.0 cannot be raised to a negative power",
                );
            }
            let out = lf.powf(rf);
            if out.is_infinite() && lf.is_finite() && rf.is_finite() {
                return raise_exception::<_>(_py, "OverflowError", "math range error");
            }
            return MoltObject::from_float(out).bits();
        }
        if let (Some(l_big), Some(r_big)) = (to_bigint(lhs), to_bigint(rhs)) {
            if let Some(exp) = r_big.to_u64() {
                let res = l_big.pow(exp as u32);
                if let Some(i) = bigint_to_inline(&res) {
                    return MoltObject::from_int(i).bits();
                }
                return bigint_bits(_py, res);
            }
            if r_big.is_negative() {
                if let Some(lf) = l_big.to_f64() {
                    let rf = r_big.to_f64().unwrap_or(f64::NEG_INFINITY);
                    if lf == 0.0 && rf < 0.0 {
                        return raise_exception::<_>(
                            _py,
                            "ZeroDivisionError",
                            "0.0 cannot be raised to a negative power",
                        );
                    }
                    return MoltObject::from_float(lf.powf(rf)).bits();
                }
            }
            return raise_exception::<_>(_py, "OverflowError", "exponent too large");
        }
        if let (Some(lf), Some(rf)) = (to_f64(lhs), to_f64(rhs)) {
            if lf == 0.0 && rf < 0.0 {
                return raise_exception::<_>(
                    _py,
                    "ZeroDivisionError",
                    "0.0 cannot be raised to a negative power",
                );
            }
            if lf < 0.0 && rf.is_finite() && rf.fract() != 0.0 {
                let base = ComplexParts { re: lf, im: 0.0 };
                let exp = ComplexParts { re: rf, im: 0.0 };
                if let Ok(out) = complex_pow(base, exp) {
                    return complex_bits(_py, out.re, out.im);
                }
            }
            let out = lf.powf(rf);
            if out.is_infinite() && lf.is_finite() && rf.is_finite() {
                return raise_exception::<_>(_py, "OverflowError", "math range error");
            }
            return MoltObject::from_float(out).bits();
        }
        raise_exception::<_>(_py, "TypeError", "unsupported operand type(s) for **")
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_pow_mod(a: u64, b: u64, m: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        let rhs = obj_from_bits(b);
        let mod_obj = obj_from_bits(m);
        if let (Some(li), Some(ri), Some(mi)) = (to_i64(lhs), to_i64(rhs), to_i64(mod_obj)) {
            let (base, exp, modulus) = (li as i128, ri, mi as i128);
            if modulus == 0 {
                return raise_exception::<_>(_py, "ValueError", "pow() 3rd argument cannot be 0");
            }
            let result = if exp < 0 {
                let mod_abs = modulus.abs();
                let base_mod = mod_py_i128(base, mod_abs);
                let Some(inv) = mod_inverse_i128(_py, base_mod, mod_abs) else {
                    return raise_exception::<_>(
                        _py,
                        "ValueError",
                        "base is not invertible for the given modulus",
                    );
                };
                let inv_mod = mod_py_i128(inv, modulus);
                mod_pow_i128(_py, inv_mod, -exp, modulus)
            } else {
                mod_pow_i128(_py, base, exp, modulus)
            };
            return MoltObject::from_int(result as i64).bits();
        }
        if let (Some(base), Some(exp), Some(modulus)) =
            (to_bigint(lhs), to_bigint(rhs), to_bigint(mod_obj))
        {
            if modulus.is_zero() {
                return raise_exception::<_>(_py, "ValueError", "pow() 3rd argument cannot be 0");
            }
            let result = if exp.is_negative() {
                let mod_abs = modulus.abs();
                let base_mod = base.mod_floor(&mod_abs);
                let Some(inv) = mod_inverse_bigint(base_mod, &mod_abs) else {
                    return raise_exception::<_>(
                        _py,
                        "ValueError",
                        "base is not invertible for the given modulus",
                    );
                };
                let inv_mod = inv.mod_floor(&modulus);
                let neg_exp = -exp;
                if neg_exp.to_u64().is_none() {
                    return raise_exception::<_>(_py, "OverflowError", "exponent too large");
                }
                let exp_u64 = neg_exp.to_u64().unwrap();
                mod_pow_bigint(&inv_mod, exp_u64, &modulus)
            } else {
                if exp.to_u64().is_none() {
                    return raise_exception::<_>(_py, "OverflowError", "exponent too large");
                }
                let exp_u64 = exp.to_u64().unwrap();
                mod_pow_bigint(&base, exp_u64, &modulus)
            };
            if let Some(i) = bigint_to_inline(&result) {
                return MoltObject::from_int(i).bits();
            }
            return bigint_bits(_py, result);
        }
        raise_exception::<_>(
            _py,
            "TypeError",
            "pow() 3rd argument not allowed unless all arguments are integers",
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_round(val_bits: u64, ndigits_bits: u64, has_ndigits_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let val = obj_from_bits(val_bits);
        let has_ndigits = to_i64(obj_from_bits(has_ndigits_bits)).unwrap_or(0) != 0;
        if let Some(ptr) = bigint_ptr_from_bits(val_bits) {
            if !has_ndigits {
                return val_bits;
            }
            let ndigits_obj = obj_from_bits(ndigits_bits);
            if ndigits_obj.is_none() {
                return val_bits;
            }
            let ndigits = index_i64_from_obj(_py, ndigits_bits, "round() ndigits must be int");
            if ndigits >= 0 {
                return val_bits;
            }
            let exp = (-ndigits) as u32;
            let value = unsafe { bigint_ref(ptr).clone() };
            let pow = BigInt::from(10).pow(exp);
            if pow.is_zero() {
                return val_bits;
            }
            let div = value.div_floor(&pow);
            let rem = value.mod_floor(&pow);
            let twice = &rem * 2;
            let mut rounded = div;
            if twice > pow || (twice == pow && !rounded.is_even()) {
                if value.is_negative() {
                    rounded -= 1;
                } else {
                    rounded += 1;
                }
            }
            let result = rounded * pow;
            if let Some(i) = bigint_to_inline(&result) {
                return MoltObject::from_int(i).bits();
            }
            return bigint_bits(_py, result);
        }
        if !val.is_int() && !val.is_bool() && !val.is_float() {
            if let Some(ptr) = maybe_ptr_from_bits(val_bits) {
                unsafe {
                    let round_name_bits = intern_static_name(
                        _py,
                        &runtime_state(_py).interned.round_name,
                        b"__round__",
                    );
                    if let Some(call_bits) = attr_lookup_ptr(_py, ptr, round_name_bits) {
                        let ndigits_obj = obj_from_bits(ndigits_bits);
                        let want_arg = has_ndigits && !ndigits_obj.is_none();
                        let arity = callable_arity(_py, call_bits).unwrap_or(0);
                        let res_bits = if arity <= 1 {
                            if want_arg {
                                call_callable1(_py, call_bits, ndigits_bits)
                            } else {
                                call_callable0(_py, call_bits)
                            }
                        } else {
                            let arg_bits = if want_arg {
                                ndigits_bits
                            } else {
                                MoltObject::none().bits()
                            };
                            call_callable1(_py, call_bits, arg_bits)
                        };
                        dec_ref_bits(_py, call_bits);
                        return res_bits;
                    }
                }
            }
        }
        if let Some(i) = to_i64(val) {
            if !has_ndigits {
                return MoltObject::from_int(i).bits();
            }
            let ndigits_obj = obj_from_bits(ndigits_bits);
            if ndigits_obj.is_none() {
                return MoltObject::from_int(i).bits();
            }
            let Some(ndigits) = to_i64(ndigits_obj) else {
                return raise_exception::<_>(_py, "TypeError", "round() ndigits must be int");
            };
            if ndigits >= 0 {
                return MoltObject::from_int(i).bits();
            }
            let exp = (-ndigits) as u32;
            if exp > 38 {
                return MoltObject::from_int(0).bits();
            }
            let pow = 10_i128.pow(exp);
            let value = i as i128;
            if pow == 0 {
                return MoltObject::from_int(i).bits();
            }
            let div = value / pow;
            let rem = value % pow;
            let abs_rem = rem.abs();
            let twice = abs_rem.saturating_mul(2);
            let mut rounded = div;
            if twice > pow || (twice == pow && (div & 1) != 0) {
                rounded += if value >= 0 { 1 } else { -1 };
            }
            let result = rounded.saturating_mul(pow);
            return MoltObject::from_int(result as i64).bits();
        }
        if let Some(f) = to_f64(val) {
            if !has_ndigits {
                if f.is_nan() {
                    return raise_exception::<_>(
                        _py,
                        "ValueError",
                        "cannot convert float NaN to integer",
                    );
                }
                if f.is_infinite() {
                    return raise_exception::<_>(
                        _py,
                        "OverflowError",
                        "cannot convert float infinity to integer",
                    );
                }
                let rounded = round_half_even(f);
                let big = bigint_from_f64_trunc(rounded);
                if let Some(i) = bigint_to_inline(&big) {
                    return MoltObject::from_int(i).bits();
                }
                return bigint_bits(_py, big);
            }
            let ndigits_obj = obj_from_bits(ndigits_bits);
            if ndigits_obj.is_none() {
                if f.is_nan() {
                    return raise_exception::<_>(
                        _py,
                        "ValueError",
                        "cannot convert float NaN to integer",
                    );
                }
                if f.is_infinite() {
                    return raise_exception::<_>(
                        _py,
                        "OverflowError",
                        "cannot convert float infinity to integer",
                    );
                }
                let rounded = round_half_even(f);
                let big = bigint_from_f64_trunc(rounded);
                if let Some(i) = bigint_to_inline(&big) {
                    return MoltObject::from_int(i).bits();
                }
                return bigint_bits(_py, big);
            }
            let Some(ndigits) = to_i64(ndigits_obj) else {
                return raise_exception::<_>(_py, "TypeError", "round() ndigits must be int");
            };
            let rounded = round_float_ndigits(f, ndigits);
            return MoltObject::from_float(rounded).bits();
        }
        raise_exception::<_>(_py, "TypeError", "round() expects a real number")
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_trunc(val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let val = obj_from_bits(val_bits);
        if let Some(i) = to_i64(val) {
            return MoltObject::from_int(i).bits();
        }
        if bigint_ptr_from_bits(val_bits).is_some() {
            return val_bits;
        }
        if let Some(f) = to_f64(val) {
            if f.is_nan() {
                return raise_exception::<_>(
                    _py,
                    "ValueError",
                    "cannot convert float NaN to integer",
                );
            }
            if f.is_infinite() {
                return raise_exception::<_>(
                    _py,
                    "OverflowError",
                    "cannot convert float infinity to integer",
                );
            }
            let big = bigint_from_f64_trunc(f);
            if let Some(i) = bigint_to_inline(&big) {
                return MoltObject::from_int(i).bits();
            }
            return bigint_bits(_py, big);
        }
        if let Some(ptr) = maybe_ptr_from_bits(val_bits) {
            unsafe {
                let trunc_name_bits =
                    intern_static_name(_py, &runtime_state(_py).interned.trunc_name, b"__trunc__");
                if let Some(call_bits) = attr_lookup_ptr(_py, ptr, trunc_name_bits) {
                    let res_bits = call_callable0(_py, call_bits);
                    dec_ref_bits(_py, call_bits);
                    return res_bits;
                }
            }
        }
        raise_exception::<_>(_py, "TypeError", "trunc() expects a real number")
    })
}

fn set_like_result_type_id(type_id: u32) -> u32 {
    if type_id == TYPE_ID_FROZENSET {
        TYPE_ID_FROZENSET
    } else {
        TYPE_ID_SET
    }
}

unsafe fn set_like_new_bits(type_id: u32, capacity: usize) -> u64 {
    if type_id == TYPE_ID_FROZENSET {
        molt_frozenset_new(capacity as u64)
    } else {
        molt_set_new(capacity as u64)
    }
}

unsafe fn set_like_union(
    _py: &PyToken<'_>,
    lhs_ptr: *mut u8,
    rhs_ptr: *mut u8,
    result_type_id: u32,
) -> u64 {
    unsafe {
        let l_elems = set_order(lhs_ptr);
        let r_elems = set_order(rhs_ptr);
        let res_bits = set_like_new_bits(result_type_id, l_elems.len() + r_elems.len());
        let res_ptr = obj_from_bits(res_bits)
            .as_ptr()
            .unwrap_or(std::ptr::null_mut());
        if res_ptr.is_null() {
            return MoltObject::none().bits();
        }
        for &entry in l_elems.iter() {
            set_add_in_place(_py, res_ptr, entry);
        }
        for &entry in r_elems.iter() {
            set_add_in_place(_py, res_ptr, entry);
        }
        res_bits
    }
}

unsafe fn set_like_intersection(
    _py: &PyToken<'_>,
    lhs_ptr: *mut u8,
    rhs_ptr: *mut u8,
    result_type_id: u32,
) -> u64 {
    unsafe {
        let l_elems = set_order(lhs_ptr);
        let r_elems = set_order(rhs_ptr);
        let (probe_elems, probe_table, output) = if l_elems.len() <= r_elems.len() {
            (r_elems, set_table(rhs_ptr), l_elems)
        } else {
            (l_elems, set_table(lhs_ptr), r_elems)
        };
        let res_bits = set_like_new_bits(result_type_id, output.len());
        let res_ptr = obj_from_bits(res_bits)
            .as_ptr()
            .unwrap_or(std::ptr::null_mut());
        if res_ptr.is_null() {
            return MoltObject::none().bits();
        }
        for &entry in output.iter() {
            let found = set_find_entry(_py, probe_elems, probe_table, entry);
            if exception_pending(_py) {
                dec_ref_bits(_py, res_bits);
                return MoltObject::none().bits();
            }
            if found.is_some() {
                set_add_in_place(_py, res_ptr, entry);
                if exception_pending(_py) {
                    dec_ref_bits(_py, res_bits);
                    return MoltObject::none().bits();
                }
            }
        }
        res_bits
    }
}

unsafe fn set_like_difference(
    _py: &PyToken<'_>,
    lhs_ptr: *mut u8,
    rhs_ptr: *mut u8,
    result_type_id: u32,
) -> u64 {
    unsafe {
        let l_elems = set_order(lhs_ptr);
        let r_elems = set_order(rhs_ptr);
        let r_table = set_table(rhs_ptr);
        let res_bits = set_like_new_bits(result_type_id, l_elems.len());
        let res_ptr = obj_from_bits(res_bits)
            .as_ptr()
            .unwrap_or(std::ptr::null_mut());
        if res_ptr.is_null() {
            return MoltObject::none().bits();
        }
        for &entry in l_elems.iter() {
            let found = set_find_entry(_py, r_elems, r_table, entry);
            if exception_pending(_py) {
                dec_ref_bits(_py, res_bits);
                return MoltObject::none().bits();
            }
            if found.is_none() {
                set_add_in_place(_py, res_ptr, entry);
                if exception_pending(_py) {
                    dec_ref_bits(_py, res_bits);
                    return MoltObject::none().bits();
                }
            }
        }
        res_bits
    }
}

unsafe fn set_like_symdiff(
    _py: &PyToken<'_>,
    lhs_ptr: *mut u8,
    rhs_ptr: *mut u8,
    result_type_id: u32,
) -> u64 {
    unsafe {
        let l_elems = set_order(lhs_ptr);
        let r_elems = set_order(rhs_ptr);
        let l_table = set_table(lhs_ptr);
        let r_table = set_table(rhs_ptr);
        let res_bits = set_like_new_bits(result_type_id, l_elems.len() + r_elems.len());
        let res_ptr = obj_from_bits(res_bits)
            .as_ptr()
            .unwrap_or(std::ptr::null_mut());
        if res_ptr.is_null() {
            return MoltObject::none().bits();
        }
        for &entry in l_elems.iter() {
            let found = set_find_entry(_py, r_elems, r_table, entry);
            if exception_pending(_py) {
                dec_ref_bits(_py, res_bits);
                return MoltObject::none().bits();
            }
            if found.is_none() {
                set_add_in_place(_py, res_ptr, entry);
                if exception_pending(_py) {
                    dec_ref_bits(_py, res_bits);
                    return MoltObject::none().bits();
                }
            }
        }
        for &entry in r_elems.iter() {
            let found = set_find_entry(_py, l_elems, l_table, entry);
            if exception_pending(_py) {
                dec_ref_bits(_py, res_bits);
                return MoltObject::none().bits();
            }
            if found.is_none() {
                set_add_in_place(_py, res_ptr, entry);
                if exception_pending(_py) {
                    dec_ref_bits(_py, res_bits);
                    return MoltObject::none().bits();
                }
            }
        }
        res_bits
    }
}

unsafe fn set_like_copy_bits(_py: &PyToken<'_>, ptr: *mut u8, result_type_id: u32) -> u64 {
    unsafe {
        let elems = set_order(ptr);
        let res_bits = set_like_new_bits(result_type_id, elems.len());
        let res_ptr = obj_from_bits(res_bits)
            .as_ptr()
            .unwrap_or(std::ptr::null_mut());
        if res_ptr.is_null() {
            return MoltObject::none().bits();
        }
        for &entry in elems.iter() {
            set_add_in_place(_py, res_ptr, entry);
            if exception_pending(_py) {
                dec_ref_bits(_py, res_bits);
                return MoltObject::none().bits();
            }
        }
        res_bits
    }
}

unsafe fn set_like_ptr_from_bits(
    _py: &PyToken<'_>,
    other_bits: u64,
) -> Option<(*mut u8, Option<u64>)> {
    unsafe {
        let obj = obj_from_bits(other_bits);
        if let Some(ptr) = obj.as_ptr() {
            let type_id = object_type_id(ptr);
            if type_id == TYPE_ID_SET || type_id == TYPE_ID_FROZENSET {
                return Some((ptr, None));
            }
        }
        let set_bits = set_from_iter_bits(_py, other_bits)?;
        let ptr = obj_from_bits(set_bits).as_ptr()?;
        Some((ptr, Some(set_bits)))
    }
}

fn binary_type_error(_py: &PyToken<'_>, lhs: MoltObject, rhs: MoltObject, op: &str) -> u64 {
    let msg = format!(
        "unsupported operand type(s) for {op}: '{}' and '{}'",
        type_name(_py, lhs),
        type_name(_py, rhs)
    );
    raise_exception::<_>(_py, "TypeError", &msg)
}

fn is_union_operand(_py: &PyToken<'_>, obj: MoltObject) -> bool {
    if obj.is_none() {
        return true;
    }
    let Some(ptr) = obj.as_ptr() else {
        return false;
    };
    unsafe {
        matches!(
            object_type_id(ptr),
            TYPE_ID_TYPE | TYPE_ID_GENERIC_ALIAS | TYPE_ID_UNION
        )
    }
}

fn append_union_arg(_py: &PyToken<'_>, args: &mut Vec<u64>, candidate: u64) {
    for &existing in args.iter() {
        if obj_eq(_py, obj_from_bits(existing), obj_from_bits(candidate)) {
            return;
        }
    }
    args.push(candidate);
}

fn collect_union_args(_py: &PyToken<'_>, bits: u64, args: &mut Vec<u64>) {
    let obj = obj_from_bits(bits);
    if obj.is_none() {
        append_union_arg(_py, args, builtin_classes(_py).none_type);
        return;
    }
    if let Some(ptr) = obj.as_ptr() {
        unsafe {
            if object_type_id(ptr) == TYPE_ID_UNION {
                let args_bits = union_type_args_bits(ptr);
                let args_obj = obj_from_bits(args_bits);
                if let Some(args_ptr) = args_obj.as_ptr() {
                    if object_type_id(args_ptr) == TYPE_ID_TUPLE {
                        let elems = seq_vec_ref(args_ptr);
                        for &elem_bits in elems.iter() {
                            append_union_arg(_py, args, elem_bits);
                        }
                        return;
                    }
                }
                append_union_arg(_py, args, args_bits);
                return;
            }
        }
    }
    append_union_arg(_py, args, bits);
}

fn build_union_type(_py: &PyToken<'_>, lhs: MoltObject, rhs: MoltObject) -> u64 {
    let mut args = Vec::new();
    collect_union_args(_py, lhs.bits(), &mut args);
    collect_union_args(_py, rhs.bits(), &mut args);
    if args.len() == 1 {
        let bits = args[0];
        inc_ref_bits(_py, bits);
        return bits;
    }
    let tuple_ptr = alloc_tuple(_py, args.as_slice());
    if tuple_ptr.is_null() {
        return MoltObject::none().bits();
    }
    let args_bits = MoltObject::from_ptr(tuple_ptr).bits();
    let union_ptr = alloc_union_type(_py, args_bits);
    if union_ptr.is_null() {
        dec_ref_bits(_py, args_bits);
        return MoltObject::none().bits();
    }
    dec_ref_bits(_py, args_bits);
    MoltObject::from_ptr(union_ptr).bits()
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bit_or(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        let rhs = obj_from_bits(b);
        if let (Some(li), Some(ri)) = (to_i64(lhs), to_i64(rhs)) {
            if lhs.is_bool() && rhs.is_bool() {
                return MoltObject::from_bool((li != 0) | (ri != 0)).bits();
            }
            let res = li | ri;
            if inline_int_from_i128(res as i128).is_some() {
                return MoltObject::from_int(res).bits();
            }
            return bigint_bits(_py, BigInt::from(li) | BigInt::from(ri));
        }
        if let (Some(l_big), Some(r_big)) = (to_bigint(lhs), to_bigint(rhs)) {
            let res = l_big | r_big;
            if let Some(i) = bigint_to_inline(&res) {
                return MoltObject::from_int(i).bits();
            }
            return bigint_bits(_py, res);
        }
        if is_union_operand(_py, lhs) && is_union_operand(_py, rhs) {
            return build_union_type(_py, lhs, rhs);
        }
        if let (Some(lp), Some(rp)) = (lhs.as_ptr(), rhs.as_ptr()) {
            unsafe {
                let ltype = object_type_id(lp);
                let rtype = object_type_id(rp);
                if is_set_like_type(ltype) && is_set_like_type(rtype) {
                    return set_like_union(_py, lp, rp, set_like_result_type_id(ltype));
                }
                if (is_set_like_type(ltype) || is_set_view_type(ltype))
                    && (is_set_like_type(rtype) || is_set_view_type(rtype))
                {
                    let (lhs_ptr, lhs_bits) = if is_set_like_type(ltype) {
                        (lp, None)
                    } else {
                        let Some(bits) = dict_view_as_set_bits(_py, lp, ltype) else {
                            return MoltObject::none().bits();
                        };
                        let Some(ptr) = obj_from_bits(bits).as_ptr() else {
                            dec_ref_bits(_py, bits);
                            return MoltObject::none().bits();
                        };
                        (ptr, Some(bits))
                    };
                    let (rhs_ptr, rhs_bits) = if is_set_like_type(rtype) {
                        (rp, None)
                    } else {
                        let Some(bits) = dict_view_as_set_bits(_py, rp, rtype) else {
                            if let Some(bits) = lhs_bits {
                                dec_ref_bits(_py, bits);
                            }
                            return MoltObject::none().bits();
                        };
                        let Some(ptr) = obj_from_bits(bits).as_ptr() else {
                            if let Some(bits) = lhs_bits {
                                dec_ref_bits(_py, bits);
                            }
                            dec_ref_bits(_py, bits);
                            return MoltObject::none().bits();
                        };
                        (ptr, Some(bits))
                    };
                    let res = set_like_union(_py, lhs_ptr, rhs_ptr, TYPE_ID_SET);
                    if let Some(bits) = lhs_bits {
                        dec_ref_bits(_py, bits);
                    }
                    if let Some(bits) = rhs_bits {
                        dec_ref_bits(_py, bits);
                    }
                    return res;
                }
                if ltype == TYPE_ID_DICT && rtype == TYPE_ID_DICT {
                    let builtins = builtin_classes(_py);
                    let lhs_class = object_class_bits(lp);
                    let rhs_class = object_class_bits(rp);
                    let lhs_exact = lhs_class == 0 || lhs_class == builtins.dict;
                    let rhs_exact = rhs_class == 0 || rhs_class == builtins.dict;
                    if !lhs_exact || !rhs_exact {
                        // Dict subclasses must dispatch through dunder resolution.
                        // Skip the dict fast-path so __or__/__ror__ can run.
                        // (Exact dict stays on the optimized union path.)
                    } else if let (Some(lhs_bits), Some(rhs_bits)) = (
                        dict_like_bits_from_ptr(_py, lp),
                        dict_like_bits_from_ptr(_py, rp),
                    ) {
                        let out_bits = molt_dict_copy(lhs_bits);
                        if exception_pending(_py) {
                            return MoltObject::none().bits();
                        }
                        let _ = molt_dict_update(out_bits, rhs_bits);
                        if exception_pending(_py) {
                            dec_ref_bits(_py, out_bits);
                            return MoltObject::none().bits();
                        }
                        return out_bits;
                    }
                }
            }
        }
        unsafe {
            let or_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.or_name, b"__or__");
            let ror_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.ror_name, b"__ror__");
            if let Some(res_bits) = call_binary_dunder(_py, a, b, or_name_bits, ror_name_bits) {
                return res_bits;
            }
        }
        binary_type_error(_py, lhs, rhs, "|")
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_inplace_bit_or(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        if let Some(ptr) = lhs.as_ptr() {
            unsafe {
                if object_type_id(ptr) == TYPE_ID_SET {
                    let rhs = obj_from_bits(b);
                    let ok = rhs
                        .as_ptr()
                        .is_some_and(|rhs_ptr| is_set_inplace_rhs_type(object_type_id(rhs_ptr)));
                    if !ok {
                        return raise_unsupported_inplace(_py, "|=", a, b);
                    }
                    let _ = molt_set_update(a, b);
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    inc_ref_bits(_py, a);
                    return a;
                }
            }
        }
        if let Some(ptr) = lhs.as_ptr() {
            unsafe {
                if object_type_id(ptr) == TYPE_ID_DICT {
                    let builtins = builtin_classes(_py);
                    let class_bits = object_class_bits(ptr);
                    let exact_dict = class_bits == 0 || class_bits == builtins.dict;
                    if exact_dict {
                        if let Some(rhs_ptr) = obj_from_bits(b).as_ptr() {
                            if dict_like_bits_from_ptr(_py, rhs_ptr).is_some() {
                                let _ = molt_dict_update(a, b);
                                if exception_pending(_py) {
                                    return MoltObject::none().bits();
                                }
                                inc_ref_bits(_py, a);
                                return a;
                            }
                        }
                        return raise_unsupported_inplace(_py, "|=", a, b);
                    }
                }
            }
        }
        unsafe {
            let ior_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.ior_name, b"__ior__");
            if let Some(res_bits) = call_inplace_dunder(_py, a, b, ior_name_bits) {
                return res_bits;
            }
        }
        molt_bit_or(a, b)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bit_and(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        let rhs = obj_from_bits(b);
        if let (Some(li), Some(ri)) = (to_i64(lhs), to_i64(rhs)) {
            if lhs.is_bool() && rhs.is_bool() {
                return MoltObject::from_bool((li != 0) & (ri != 0)).bits();
            }
            let res = li & ri;
            if inline_int_from_i128(res as i128).is_some() {
                return MoltObject::from_int(res).bits();
            }
            return bigint_bits(_py, BigInt::from(li) & BigInt::from(ri));
        }
        if let (Some(l_big), Some(r_big)) = (to_bigint(lhs), to_bigint(rhs)) {
            let res = l_big & r_big;
            if let Some(i) = bigint_to_inline(&res) {
                return MoltObject::from_int(i).bits();
            }
            return bigint_bits(_py, res);
        }
        if let (Some(lp), Some(rp)) = (lhs.as_ptr(), rhs.as_ptr()) {
            unsafe {
                let ltype = object_type_id(lp);
                let rtype = object_type_id(rp);
                if is_set_like_type(ltype) && is_set_like_type(rtype) {
                    return set_like_intersection(_py, lp, rp, set_like_result_type_id(ltype));
                }
                if (is_set_like_type(ltype) || is_set_view_type(ltype))
                    && (is_set_like_type(rtype) || is_set_view_type(rtype))
                {
                    let (lhs_ptr, lhs_bits) = if is_set_like_type(ltype) {
                        (lp, None)
                    } else {
                        let Some(bits) = dict_view_as_set_bits(_py, lp, ltype) else {
                            return MoltObject::none().bits();
                        };
                        let Some(ptr) = obj_from_bits(bits).as_ptr() else {
                            dec_ref_bits(_py, bits);
                            return MoltObject::none().bits();
                        };
                        (ptr, Some(bits))
                    };
                    let (rhs_ptr, rhs_bits) = if is_set_like_type(rtype) {
                        (rp, None)
                    } else {
                        let Some(bits) = dict_view_as_set_bits(_py, rp, rtype) else {
                            if let Some(bits) = lhs_bits {
                                dec_ref_bits(_py, bits);
                            }
                            return MoltObject::none().bits();
                        };
                        let Some(ptr) = obj_from_bits(bits).as_ptr() else {
                            if let Some(bits) = lhs_bits {
                                dec_ref_bits(_py, bits);
                            }
                            dec_ref_bits(_py, bits);
                            return MoltObject::none().bits();
                        };
                        (ptr, Some(bits))
                    };
                    let res = set_like_intersection(_py, lhs_ptr, rhs_ptr, TYPE_ID_SET);
                    if let Some(bits) = lhs_bits {
                        dec_ref_bits(_py, bits);
                    }
                    if let Some(bits) = rhs_bits {
                        dec_ref_bits(_py, bits);
                    }
                    return res;
                }
            }
        }
        unsafe {
            let and_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.and_name, b"__and__");
            let rand_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.rand_name, b"__rand__");
            if let Some(res_bits) = call_binary_dunder(_py, a, b, and_name_bits, rand_name_bits) {
                return res_bits;
            }
        }
        binary_type_error(_py, lhs, rhs, "&")
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_inplace_bit_and(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        if let Some(ptr) = lhs.as_ptr() {
            unsafe {
                if object_type_id(ptr) == TYPE_ID_SET {
                    let rhs = obj_from_bits(b);
                    let ok = rhs
                        .as_ptr()
                        .is_some_and(|rhs_ptr| is_set_inplace_rhs_type(object_type_id(rhs_ptr)));
                    if !ok {
                        return raise_unsupported_inplace(_py, "&=", a, b);
                    }
                    let _ = molt_set_intersection_update(a, b);
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    inc_ref_bits(_py, a);
                    return a;
                }
            }
        }
        unsafe {
            let iand_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.iand_name, b"__iand__");
            if let Some(res_bits) = call_inplace_dunder(_py, a, b, iand_name_bits) {
                return res_bits;
            }
        }
        molt_bit_and(a, b)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bit_xor(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        let rhs = obj_from_bits(b);
        if let (Some(li), Some(ri)) = (to_i64(lhs), to_i64(rhs)) {
            if lhs.is_bool() && rhs.is_bool() {
                return MoltObject::from_bool((li != 0) ^ (ri != 0)).bits();
            }
            let res = li ^ ri;
            if inline_int_from_i128(res as i128).is_some() {
                return MoltObject::from_int(res).bits();
            }
            return bigint_bits(_py, BigInt::from(li) ^ BigInt::from(ri));
        }
        if let (Some(l_big), Some(r_big)) = (to_bigint(lhs), to_bigint(rhs)) {
            let res = l_big ^ r_big;
            if let Some(i) = bigint_to_inline(&res) {
                return MoltObject::from_int(i).bits();
            }
            return bigint_bits(_py, res);
        }
        if let (Some(lp), Some(rp)) = (lhs.as_ptr(), rhs.as_ptr()) {
            unsafe {
                let ltype = object_type_id(lp);
                let rtype = object_type_id(rp);
                if is_set_like_type(ltype) && is_set_like_type(rtype) {
                    return set_like_symdiff(_py, lp, rp, set_like_result_type_id(ltype));
                }
                if (is_set_like_type(ltype) || is_set_view_type(ltype))
                    && (is_set_like_type(rtype) || is_set_view_type(rtype))
                {
                    let (lhs_ptr, lhs_bits) = if is_set_like_type(ltype) {
                        (lp, None)
                    } else {
                        let Some(bits) = dict_view_as_set_bits(_py, lp, ltype) else {
                            return MoltObject::none().bits();
                        };
                        let Some(ptr) = obj_from_bits(bits).as_ptr() else {
                            dec_ref_bits(_py, bits);
                            return MoltObject::none().bits();
                        };
                        (ptr, Some(bits))
                    };
                    let (rhs_ptr, rhs_bits) = if is_set_like_type(rtype) {
                        (rp, None)
                    } else {
                        let Some(bits) = dict_view_as_set_bits(_py, rp, rtype) else {
                            if let Some(bits) = lhs_bits {
                                dec_ref_bits(_py, bits);
                            }
                            return MoltObject::none().bits();
                        };
                        let Some(ptr) = obj_from_bits(bits).as_ptr() else {
                            if let Some(bits) = lhs_bits {
                                dec_ref_bits(_py, bits);
                            }
                            dec_ref_bits(_py, bits);
                            return MoltObject::none().bits();
                        };
                        (ptr, Some(bits))
                    };
                    let res = set_like_symdiff(_py, lhs_ptr, rhs_ptr, TYPE_ID_SET);
                    if let Some(bits) = lhs_bits {
                        dec_ref_bits(_py, bits);
                    }
                    if let Some(bits) = rhs_bits {
                        dec_ref_bits(_py, bits);
                    }
                    return res;
                }
            }
        }
        unsafe {
            let xor_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.xor_name, b"__xor__");
            let rxor_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.rxor_name, b"__rxor__");
            if let Some(res_bits) = call_binary_dunder(_py, a, b, xor_name_bits, rxor_name_bits) {
                return res_bits;
            }
        }
        binary_type_error(_py, lhs, rhs, "^")
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_invert(val: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(val);
        if let Some(i) = to_i64(obj) {
            let res = -(i as i128) - 1;
            return int_bits_from_i128(_py, res);
        }
        if let Some(big) = to_bigint(obj) {
            let res = -big - BigInt::from(1);
            if let Some(i) = bigint_to_inline(&res) {
                return MoltObject::from_int(i).bits();
            }
            return bigint_bits(_py, res);
        }
        let msg = format!("bad operand type for unary ~: '{}'", type_name(_py, obj));
        raise_exception::<_>(_py, "TypeError", &msg)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_inplace_bit_xor(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        if let Some(ptr) = lhs.as_ptr() {
            unsafe {
                if object_type_id(ptr) == TYPE_ID_SET {
                    let rhs = obj_from_bits(b);
                    let ok = rhs
                        .as_ptr()
                        .is_some_and(|rhs_ptr| is_set_inplace_rhs_type(object_type_id(rhs_ptr)));
                    if !ok {
                        return raise_unsupported_inplace(_py, "^=", a, b);
                    }
                    let _ = molt_set_symdiff_update(a, b);
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    inc_ref_bits(_py, a);
                    return a;
                }
            }
        }
        unsafe {
            let ixor_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.ixor_name, b"__ixor__");
            if let Some(res_bits) = call_inplace_dunder(_py, a, b, ixor_name_bits) {
                return res_bits;
            }
        }
        molt_bit_xor(a, b)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_lshift(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        let rhs = obj_from_bits(b);
        let shift = index_i64_from_obj(_py, b, "shift count must be int");
        if shift < 0 {
            return raise_exception::<_>(_py, "ValueError", "negative shift count");
        }
        let shift_u = shift as u32;
        if let Some(value) = to_i64(lhs) {
            if shift_u >= 63 {
                return bigint_bits(_py, BigInt::from(value) << shift_u);
            }
            let res = value << shift_u;
            if inline_int_from_i128(res as i128).is_some() {
                return MoltObject::from_int(res).bits();
            }
            return bigint_bits(_py, BigInt::from(value) << shift_u);
        }
        if let Some(value) = to_bigint(lhs) {
            let res = value << shift_u;
            if let Some(i) = bigint_to_inline(&res) {
                return MoltObject::from_int(i).bits();
            }
            return bigint_bits(_py, res);
        }
        binary_type_error(_py, lhs, rhs, "<<")
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_rshift(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        let rhs = obj_from_bits(b);
        let shift = index_i64_from_obj(_py, b, "shift count must be int");
        if shift < 0 {
            return raise_exception::<_>(_py, "ValueError", "negative shift count");
        }
        let shift_u = shift as u32;
        if let Some(value) = to_i64(lhs) {
            let res = if shift_u >= 63 {
                if value >= 0 { 0 } else { -1 }
            } else {
                value >> shift_u
            };
            return MoltObject::from_int(res).bits();
        }
        if let Some(value) = to_bigint(lhs) {
            let res = value >> shift_u;
            if let Some(i) = bigint_to_inline(&res) {
                return MoltObject::from_int(i).bits();
            }
            return bigint_bits(_py, res);
        }
        binary_type_error(_py, lhs, rhs, ">>")
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_matmul(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        let rhs = obj_from_bits(b);
        if let (Some(lp), Some(rp)) = (lhs.as_ptr(), rhs.as_ptr()) {
            unsafe {
                if object_type_id(lp) == TYPE_ID_BUFFER2D && object_type_id(rp) == TYPE_ID_BUFFER2D
                {
                    return molt_buffer2d_matmul(a, b);
                }
            }
        }
        binary_type_error(_py, lhs, rhs, "@")
    })
}

fn compare_type_error(_py: &PyToken<'_>, lhs: MoltObject, rhs: MoltObject, op: &str) -> u64 {
    let msg = format!(
        "'{}' not supported between instances of '{}' and '{}'",
        op,
        type_name(_py, lhs),
        type_name(_py, rhs),
    );
    raise_exception::<_>(_py, "TypeError", &msg)
}

#[derive(Clone, Copy)]
enum CompareOutcome {
    Ordered(Ordering),
    Unordered,
    NotComparable,
    Error,
}

#[derive(Clone, Copy)]
enum CompareBoolOutcome {
    True,
    False,
    NotComparable,
    Error,
}

#[derive(Clone, Copy)]
enum CompareValueOutcome {
    Value(u64),
    NotComparable,
    Error,
}

#[derive(Clone, Copy)]
enum CompareOp {
    Lt,
    Le,
    Gt,
    Ge,
}

fn is_number(obj: MoltObject) -> bool {
    to_i64(obj).is_some() || obj.is_float() || bigint_ptr_from_bits(obj.bits()).is_some()
}

fn compare_numbers_outcome(lhs: MoltObject, rhs: MoltObject) -> CompareOutcome {
    if let Some(ordering) = compare_numbers(lhs, rhs) {
        return CompareOutcome::Ordered(ordering);
    }
    if is_number(lhs) && is_number(rhs) {
        return CompareOutcome::Unordered;
    }
    CompareOutcome::NotComparable
}

unsafe fn compare_string_bytes(lhs_ptr: *mut u8, rhs_ptr: *mut u8) -> Ordering {
    unsafe {
        let l_len = string_len(lhs_ptr);
        let r_len = string_len(rhs_ptr);
        let l_bytes = std::slice::from_raw_parts(string_bytes(lhs_ptr), l_len);
        let r_bytes = std::slice::from_raw_parts(string_bytes(rhs_ptr), r_len);
        l_bytes.cmp(r_bytes)
    }
}

unsafe fn compare_bytes_like(lhs_ptr: *mut u8, rhs_ptr: *mut u8) -> Ordering {
    unsafe {
        let l_len = bytes_len(lhs_ptr);
        let r_len = bytes_len(rhs_ptr);
        let l_bytes = std::slice::from_raw_parts(bytes_data(lhs_ptr), l_len);
        let r_bytes = std::slice::from_raw_parts(bytes_data(rhs_ptr), r_len);
        l_bytes.cmp(r_bytes)
    }
}

unsafe fn compare_sequence(
    _py: &PyToken<'_>,
    lhs_ptr: *mut u8,
    rhs_ptr: *mut u8,
) -> CompareOutcome {
    unsafe {
        let lhs = seq_vec_ref(lhs_ptr);
        let rhs = seq_vec_ref(rhs_ptr);
        let common = lhs.len().min(rhs.len());
        for idx in 0..common {
            let l_bits = lhs[idx];
            let r_bits = rhs[idx];
            if obj_eq(_py, obj_from_bits(l_bits), obj_from_bits(r_bits)) {
                continue;
            }
            return compare_objects(_py, obj_from_bits(l_bits), obj_from_bits(r_bits));
        }
        CompareOutcome::Ordered(lhs.len().cmp(&rhs.len()))
    }
}

fn compare_objects_builtin(_py: &PyToken<'_>, lhs: MoltObject, rhs: MoltObject) -> CompareOutcome {
    match compare_numbers_outcome(lhs, rhs) {
        CompareOutcome::NotComparable => {}
        outcome => return outcome,
    }
    let (Some(lhs_ptr), Some(rhs_ptr)) = (lhs.as_ptr(), rhs.as_ptr()) else {
        return CompareOutcome::NotComparable;
    };
    unsafe {
        let ltype = object_type_id(lhs_ptr);
        let rtype = object_type_id(rhs_ptr);
        if ltype == TYPE_ID_STRING && rtype == TYPE_ID_STRING {
            return CompareOutcome::Ordered(compare_string_bytes(lhs_ptr, rhs_ptr));
        }
        if (ltype == TYPE_ID_BYTES || ltype == TYPE_ID_BYTEARRAY)
            && (rtype == TYPE_ID_BYTES || rtype == TYPE_ID_BYTEARRAY)
        {
            return CompareOutcome::Ordered(compare_bytes_like(lhs_ptr, rhs_ptr));
        }
        if ltype == TYPE_ID_LIST && rtype == TYPE_ID_LIST {
            return compare_sequence(_py, lhs_ptr, rhs_ptr);
        }
        if ltype == TYPE_ID_TUPLE && rtype == TYPE_ID_TUPLE {
            return compare_sequence(_py, lhs_ptr, rhs_ptr);
        }
    }
    CompareOutcome::NotComparable
}

fn ordering_matches(ordering: Ordering, op: CompareOp) -> bool {
    match op {
        CompareOp::Lt => ordering == Ordering::Less,
        CompareOp::Le => ordering != Ordering::Greater,
        CompareOp::Gt => ordering == Ordering::Greater,
        CompareOp::Ge => ordering != Ordering::Less,
    }
}

fn compare_builtin_bool(
    _py: &PyToken<'_>,
    lhs: MoltObject,
    rhs: MoltObject,
    op: CompareOp,
) -> CompareBoolOutcome {
    match compare_objects_builtin(_py, lhs, rhs) {
        CompareOutcome::Ordered(ordering) => {
            if ordering_matches(ordering, op) {
                CompareBoolOutcome::True
            } else {
                CompareBoolOutcome::False
            }
        }
        CompareOutcome::Unordered => CompareBoolOutcome::False,
        CompareOutcome::NotComparable => CompareBoolOutcome::NotComparable,
        CompareOutcome::Error => CompareBoolOutcome::Error,
    }
}

fn rich_compare_bool(
    _py: &PyToken<'_>,
    lhs: MoltObject,
    rhs: MoltObject,
    op_name_bits: u64,
    reverse_name_bits: u64,
) -> CompareBoolOutcome {
    let pending_before = exception_pending(_py);
    let prev_exc_bits = if pending_before {
        exception_last_bits_noinc(_py).unwrap_or(0)
    } else {
        0
    };
    let exception_changed = || {
        if !exception_pending(_py) {
            return false;
        }
        if !pending_before {
            return true;
        }
        exception_last_bits_noinc(_py).unwrap_or(0) != prev_exc_bits
    };
    if let Some(outcome) = rich_compare_type_bool(_py, lhs, rhs, op_name_bits, reverse_name_bits) {
        return outcome;
    }
    unsafe {
        if let Some(lhs_ptr) = lhs.as_ptr() {
            if let Some(call_bits) = attr_lookup_ptr_allow_missing(_py, lhs_ptr, op_name_bits) {
                let res_bits = call_callable1(_py, call_bits, rhs.bits());
                dec_ref_bits(_py, call_bits);
                if exception_changed() {
                    dec_ref_bits(_py, res_bits);
                    return CompareBoolOutcome::Error;
                }
                if is_not_implemented_bits(_py, res_bits) {
                    dec_ref_bits(_py, res_bits);
                } else {
                    let truthy = is_truthy(_py, obj_from_bits(res_bits));
                    dec_ref_bits(_py, res_bits);
                    return if truthy {
                        CompareBoolOutcome::True
                    } else {
                        CompareBoolOutcome::False
                    };
                }
            }
            if exception_changed() {
                return CompareBoolOutcome::Error;
            }
        }
        if let Some(rhs_ptr) = rhs.as_ptr() {
            if let Some(call_bits) = attr_lookup_ptr_allow_missing(_py, rhs_ptr, reverse_name_bits)
            {
                let res_bits = call_callable1(_py, call_bits, lhs.bits());
                dec_ref_bits(_py, call_bits);
                if exception_changed() {
                    dec_ref_bits(_py, res_bits);
                    return CompareBoolOutcome::Error;
                }
                if is_not_implemented_bits(_py, res_bits) {
                    dec_ref_bits(_py, res_bits);
                } else {
                    let truthy = is_truthy(_py, obj_from_bits(res_bits));
                    dec_ref_bits(_py, res_bits);
                    return if truthy {
                        CompareBoolOutcome::True
                    } else {
                        CompareBoolOutcome::False
                    };
                }
            }
            if exception_changed() {
                return CompareBoolOutcome::Error;
            }
        }
    }
    CompareBoolOutcome::NotComparable
}

fn rich_compare_value(
    _py: &PyToken<'_>,
    lhs: MoltObject,
    rhs: MoltObject,
    op_name_bits: u64,
    reverse_name_bits: u64,
) -> CompareValueOutcome {
    let pending_before = exception_pending(_py);
    let prev_exc_bits = if pending_before {
        exception_last_bits_noinc(_py).unwrap_or(0)
    } else {
        0
    };
    let exception_changed = || {
        if !exception_pending(_py) {
            return false;
        }
        if !pending_before {
            return true;
        }
        exception_last_bits_noinc(_py).unwrap_or(0) != prev_exc_bits
    };
    if let Some(outcome) = rich_compare_type_value(_py, lhs, rhs, op_name_bits, reverse_name_bits) {
        return outcome;
    }
    unsafe {
        if let Some(lhs_ptr) = lhs.as_ptr() {
            if let Some(call_bits) = attr_lookup_ptr_allow_missing(_py, lhs_ptr, op_name_bits) {
                let res_bits = call_callable1(_py, call_bits, rhs.bits());
                dec_ref_bits(_py, call_bits);
                if exception_changed() {
                    dec_ref_bits(_py, res_bits);
                    return CompareValueOutcome::Error;
                }
                if is_not_implemented_bits(_py, res_bits) {
                    dec_ref_bits(_py, res_bits);
                } else {
                    return CompareValueOutcome::Value(res_bits);
                }
            }
            if exception_changed() {
                return CompareValueOutcome::Error;
            }
        }
        if let Some(rhs_ptr) = rhs.as_ptr() {
            if let Some(call_bits) = attr_lookup_ptr_allow_missing(_py, rhs_ptr, reverse_name_bits)
            {
                let res_bits = call_callable1(_py, call_bits, lhs.bits());
                dec_ref_bits(_py, call_bits);
                if exception_changed() {
                    dec_ref_bits(_py, res_bits);
                    return CompareValueOutcome::Error;
                }
                if is_not_implemented_bits(_py, res_bits) {
                    dec_ref_bits(_py, res_bits);
                } else {
                    return CompareValueOutcome::Value(res_bits);
                }
            }
            if exception_changed() {
                return CompareValueOutcome::Error;
            }
        }
    }
    CompareValueOutcome::NotComparable
}

fn rich_compare_type_bool(
    _py: &PyToken<'_>,
    lhs: MoltObject,
    rhs: MoltObject,
    op_name_bits: u64,
    reverse_name_bits: u64,
) -> Option<CompareBoolOutcome> {
    unsafe {
        let mut saw_type = false;
        if let Some(lhs_ptr) = lhs.as_ptr() {
            if object_type_id(lhs_ptr) == TYPE_ID_TYPE {
                saw_type = true;
                if let Some(outcome) =
                    rich_compare_type_method(_py, lhs_ptr, rhs.bits(), op_name_bits)
                {
                    return Some(outcome);
                }
            }
        }
        if let Some(rhs_ptr) = rhs.as_ptr() {
            if object_type_id(rhs_ptr) == TYPE_ID_TYPE {
                saw_type = true;
                if let Some(outcome) =
                    rich_compare_type_method(_py, rhs_ptr, lhs.bits(), reverse_name_bits)
                {
                    return Some(outcome);
                }
            }
        }
        if saw_type {
            return Some(CompareBoolOutcome::NotComparable);
        }
    }
    None
}

fn rich_compare_type_value(
    _py: &PyToken<'_>,
    lhs: MoltObject,
    rhs: MoltObject,
    op_name_bits: u64,
    reverse_name_bits: u64,
) -> Option<CompareValueOutcome> {
    unsafe {
        let mut saw_type = false;
        if let Some(lhs_ptr) = lhs.as_ptr() {
            if object_type_id(lhs_ptr) == TYPE_ID_TYPE {
                saw_type = true;
                if let Some(outcome) =
                    rich_compare_type_method_value(_py, lhs_ptr, rhs.bits(), op_name_bits)
                {
                    return Some(outcome);
                }
            }
        }
        if let Some(rhs_ptr) = rhs.as_ptr() {
            if object_type_id(rhs_ptr) == TYPE_ID_TYPE {
                saw_type = true;
                if let Some(outcome) =
                    rich_compare_type_method_value(_py, rhs_ptr, lhs.bits(), reverse_name_bits)
                {
                    return Some(outcome);
                }
            }
        }
        if saw_type {
            return Some(CompareValueOutcome::NotComparable);
        }
    }
    None
}

unsafe fn rich_compare_type_method(
    _py: &PyToken<'_>,
    type_ptr: *mut u8,
    other_bits: u64,
    op_name_bits: u64,
) -> Option<CompareBoolOutcome> {
    unsafe {
        let pending_before = exception_pending(_py);
        let prev_exc_bits = if pending_before {
            exception_last_bits_noinc(_py).unwrap_or(0)
        } else {
            0
        };
        let exception_changed = || {
            if !exception_pending(_py) {
                return false;
            }
            if !pending_before {
                return true;
            }
            exception_last_bits_noinc(_py).unwrap_or(0) != prev_exc_bits
        };
        let mut meta_bits = object_class_bits(type_ptr);
        if meta_bits == 0 {
            meta_bits = builtin_classes(_py).type_obj;
        }
        let meta_ptr = match obj_from_bits(meta_bits).as_ptr() {
            Some(ptr) if object_type_id(ptr) == TYPE_ID_TYPE => ptr,
            _ => return None,
        };
        let method_bits = class_attr_lookup_raw_mro(_py, meta_ptr, op_name_bits)?;
        let Some(bound_bits) = descriptor_bind(_py, method_bits, meta_ptr, Some(type_ptr)) else {
            if exception_changed() {
                return Some(CompareBoolOutcome::Error);
            }
            return None;
        };
        let res_bits = call_callable1(_py, bound_bits, other_bits);
        dec_ref_bits(_py, bound_bits);
        if exception_changed() {
            dec_ref_bits(_py, res_bits);
            return Some(CompareBoolOutcome::Error);
        }
        if is_not_implemented_bits(_py, res_bits) {
            dec_ref_bits(_py, res_bits);
            return None;
        }
        let truthy = is_truthy(_py, obj_from_bits(res_bits));
        dec_ref_bits(_py, res_bits);
        Some(if truthy {
            CompareBoolOutcome::True
        } else {
            CompareBoolOutcome::False
        })
    }
}

unsafe fn rich_compare_type_method_value(
    _py: &PyToken<'_>,
    type_ptr: *mut u8,
    other_bits: u64,
    op_name_bits: u64,
) -> Option<CompareValueOutcome> {
    unsafe {
        let pending_before = exception_pending(_py);
        let prev_exc_bits = if pending_before {
            exception_last_bits_noinc(_py).unwrap_or(0)
        } else {
            0
        };
        let exception_changed = || {
            if !exception_pending(_py) {
                return false;
            }
            if !pending_before {
                return true;
            }
            exception_last_bits_noinc(_py).unwrap_or(0) != prev_exc_bits
        };
        let mut meta_bits = object_class_bits(type_ptr);
        if meta_bits == 0 {
            meta_bits = builtin_classes(_py).type_obj;
        }
        let meta_ptr = match obj_from_bits(meta_bits).as_ptr() {
            Some(ptr) if object_type_id(ptr) == TYPE_ID_TYPE => ptr,
            _ => return None,
        };
        let method_bits = class_attr_lookup_raw_mro(_py, meta_ptr, op_name_bits)?;
        let Some(bound_bits) = descriptor_bind(_py, method_bits, meta_ptr, Some(type_ptr)) else {
            if exception_changed() {
                return Some(CompareValueOutcome::Error);
            }
            return None;
        };
        let res_bits = call_callable1(_py, bound_bits, other_bits);
        dec_ref_bits(_py, bound_bits);
        if exception_changed() {
            dec_ref_bits(_py, res_bits);
            return Some(CompareValueOutcome::Error);
        }
        if is_not_implemented_bits(_py, res_bits) {
            dec_ref_bits(_py, res_bits);
            return None;
        }
        Some(CompareValueOutcome::Value(res_bits))
    }
}

fn rich_compare_order(_py: &PyToken<'_>, lhs: MoltObject, rhs: MoltObject) -> CompareOutcome {
    let lt_name_bits = intern_static_name(_py, &runtime_state(_py).interned.lt_name, b"__lt__");
    let gt_name_bits = intern_static_name(_py, &runtime_state(_py).interned.gt_name, b"__gt__");
    match rich_compare_bool(_py, lhs, rhs, lt_name_bits, gt_name_bits) {
        CompareBoolOutcome::True => return CompareOutcome::Ordered(Ordering::Less),
        CompareBoolOutcome::False => {}
        CompareBoolOutcome::NotComparable => return CompareOutcome::NotComparable,
        CompareBoolOutcome::Error => return CompareOutcome::Error,
    }
    match rich_compare_bool(_py, rhs, lhs, lt_name_bits, gt_name_bits) {
        CompareBoolOutcome::True => CompareOutcome::Ordered(Ordering::Greater),
        CompareBoolOutcome::False => CompareOutcome::Ordered(Ordering::Equal),
        CompareBoolOutcome::NotComparable => CompareOutcome::NotComparable,
        CompareBoolOutcome::Error => CompareOutcome::Error,
    }
}

fn compare_objects(_py: &PyToken<'_>, lhs: MoltObject, rhs: MoltObject) -> CompareOutcome {
    match compare_objects_builtin(_py, lhs, rhs) {
        CompareOutcome::NotComparable => {}
        outcome => return outcome,
    }
    rich_compare_order(_py, lhs, rhs)
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_lt(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        let rhs = obj_from_bits(b);
        match compare_builtin_bool(_py, lhs, rhs, CompareOp::Lt) {
            CompareBoolOutcome::True => return MoltObject::from_bool(true).bits(),
            CompareBoolOutcome::False => return MoltObject::from_bool(false).bits(),
            CompareBoolOutcome::Error => return MoltObject::none().bits(),
            CompareBoolOutcome::NotComparable => {}
        }
        let lt_name_bits = intern_static_name(_py, &runtime_state(_py).interned.lt_name, b"__lt__");
        let gt_name_bits = intern_static_name(_py, &runtime_state(_py).interned.gt_name, b"__gt__");
        match rich_compare_value(_py, lhs, rhs, lt_name_bits, gt_name_bits) {
            CompareValueOutcome::Value(bits) => bits,
            CompareValueOutcome::Error => MoltObject::none().bits(),
            CompareValueOutcome::NotComparable => compare_type_error(_py, lhs, rhs, "<"),
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_le(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        let rhs = obj_from_bits(b);
        match compare_builtin_bool(_py, lhs, rhs, CompareOp::Le) {
            CompareBoolOutcome::True => return MoltObject::from_bool(true).bits(),
            CompareBoolOutcome::False => return MoltObject::from_bool(false).bits(),
            CompareBoolOutcome::Error => return MoltObject::none().bits(),
            CompareBoolOutcome::NotComparable => {}
        }
        let le_name_bits = intern_static_name(_py, &runtime_state(_py).interned.le_name, b"__le__");
        let ge_name_bits = intern_static_name(_py, &runtime_state(_py).interned.ge_name, b"__ge__");
        match rich_compare_value(_py, lhs, rhs, le_name_bits, ge_name_bits) {
            CompareValueOutcome::Value(bits) => bits,
            CompareValueOutcome::Error => MoltObject::none().bits(),
            CompareValueOutcome::NotComparable => compare_type_error(_py, lhs, rhs, "<="),
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_gt(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        let rhs = obj_from_bits(b);
        match compare_builtin_bool(_py, lhs, rhs, CompareOp::Gt) {
            CompareBoolOutcome::True => return MoltObject::from_bool(true).bits(),
            CompareBoolOutcome::False => return MoltObject::from_bool(false).bits(),
            CompareBoolOutcome::Error => return MoltObject::none().bits(),
            CompareBoolOutcome::NotComparable => {}
        }
        let gt_name_bits = intern_static_name(_py, &runtime_state(_py).interned.gt_name, b"__gt__");
        let lt_name_bits = intern_static_name(_py, &runtime_state(_py).interned.lt_name, b"__lt__");
        match rich_compare_value(_py, lhs, rhs, gt_name_bits, lt_name_bits) {
            CompareValueOutcome::Value(bits) => bits,
            CompareValueOutcome::Error => MoltObject::none().bits(),
            CompareValueOutcome::NotComparable => compare_type_error(_py, lhs, rhs, ">"),
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_ge(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        let rhs = obj_from_bits(b);
        match compare_builtin_bool(_py, lhs, rhs, CompareOp::Ge) {
            CompareBoolOutcome::True => return MoltObject::from_bool(true).bits(),
            CompareBoolOutcome::False => return MoltObject::from_bool(false).bits(),
            CompareBoolOutcome::Error => return MoltObject::none().bits(),
            CompareBoolOutcome::NotComparable => {}
        }
        let ge_name_bits = intern_static_name(_py, &runtime_state(_py).interned.ge_name, b"__ge__");
        let le_name_bits = intern_static_name(_py, &runtime_state(_py).interned.le_name, b"__le__");
        match rich_compare_value(_py, lhs, rhs, ge_name_bits, le_name_bits) {
            CompareValueOutcome::Value(bits) => bits,
            CompareValueOutcome::Error => MoltObject::none().bits(),
            CompareValueOutcome::NotComparable => compare_type_error(_py, lhs, rhs, ">="),
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_eq(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        let rhs = obj_from_bits(b);
        let ellipsis = ellipsis_bits(_py);
        if a == ellipsis || b == ellipsis {
            return MoltObject::from_bool(a == b).bits();
        }
        let eq_name_bits = intern_static_name(_py, &runtime_state(_py).interned.eq_name, b"__eq__");
        match rich_compare_value(_py, lhs, rhs, eq_name_bits, eq_name_bits) {
            CompareValueOutcome::Value(bits) => return bits,
            CompareValueOutcome::Error => return MoltObject::none().bits(),
            CompareValueOutcome::NotComparable => {}
        }
        MoltObject::from_bool(obj_eq(_py, lhs, rhs)).bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_ne(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        let rhs = obj_from_bits(b);
        match compare_objects_builtin(_py, lhs, rhs) {
            CompareOutcome::Ordered(ordering) => {
                return MoltObject::from_bool(ordering != Ordering::Equal).bits();
            }
            CompareOutcome::Unordered => return MoltObject::from_bool(true).bits(),
            CompareOutcome::Error => return MoltObject::none().bits(),
            CompareOutcome::NotComparable => {}
        }
        let lhs_type_bits = type_of_bits(_py, a);
        let rhs_type_bits = type_of_bits(_py, b);
        let lhs_type_ptr = obj_from_bits(lhs_type_bits).as_ptr();
        let rhs_type_ptr = obj_from_bits(rhs_type_bits).as_ptr();
        let ne_name_bits = intern_static_name(_py, &runtime_state(_py).interned.ne_name, b"__ne__");
        let object_ne_raw = unsafe {
            obj_from_bits(builtin_classes(_py).object)
                .as_ptr()
                .and_then(|ptr| class_attr_lookup_raw_mro(_py, ptr, ne_name_bits))
        };
        let lhs_ne_raw = unsafe {
            lhs_type_ptr.and_then(|ptr| class_attr_lookup_raw_mro(_py, ptr, ne_name_bits))
        };
        let rhs_ne_raw = unsafe {
            rhs_type_ptr.and_then(|ptr| class_attr_lookup_raw_mro(_py, ptr, ne_name_bits))
        };
        let lhs_ne_is_object_default = lhs_ne_raw.is_some() && lhs_ne_raw == object_ne_raw;

        let mut lhs_ne_notimplemented_or_missing = true;
        if let (Some(lhs_ptr), Some(lhs_tp), Some(lhs_raw)) =
            (lhs.as_ptr(), lhs_type_ptr, lhs_ne_raw)
        {
            unsafe {
                match call_dunder_raw(_py, lhs_raw, lhs_tp, Some(lhs_ptr), b) {
                    BinaryDunderOutcome::Value(bits) => return bits,
                    BinaryDunderOutcome::Error => return MoltObject::none().bits(),
                    BinaryDunderOutcome::NotImplemented | BinaryDunderOutcome::Missing => {
                        lhs_ne_notimplemented_or_missing = true;
                    }
                }
            }
        }

        if lhs_ne_notimplemented_or_missing {
            let rhs_is_subclass =
                rhs_type_bits != lhs_type_bits && issubclass_bits(rhs_type_bits, lhs_type_bits);
            let rhs_has_custom_ne = rhs_ne_raw.is_some() && rhs_ne_raw != object_ne_raw;
            let rhs_differs_from_lhs = lhs_ne_raw.is_none_or(|lhs_raw| Some(lhs_raw) != rhs_ne_raw);
            let should_call_rhs = rhs_type_bits != lhs_type_bits
                && rhs_has_custom_ne
                && (rhs_is_subclass || lhs_ne_raw.is_none() || rhs_differs_from_lhs);
            if should_call_rhs {
                if let (Some(rhs_ptr), Some(rhs_tp), Some(rhs_raw)) =
                    (rhs.as_ptr(), rhs_type_ptr, rhs_ne_raw)
                {
                    unsafe {
                        match call_dunder_raw(_py, rhs_raw, rhs_tp, Some(rhs_ptr), a) {
                            BinaryDunderOutcome::Value(bits) => return bits,
                            BinaryDunderOutcome::Error => return MoltObject::none().bits(),
                            BinaryDunderOutcome::NotImplemented | BinaryDunderOutcome::Missing => {}
                        }
                    }
                }
            }
        }

        if lhs_ne_is_object_default || lhs_ne_raw.is_none() {
            let eq_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.eq_name, b"__eq__");
            match rich_compare_value(_py, lhs, rhs, eq_name_bits, eq_name_bits) {
                CompareValueOutcome::Value(bits) => {
                    let truthy = is_truthy(_py, obj_from_bits(bits));
                    let had_exc = exception_pending(_py);
                    dec_ref_bits(_py, bits);
                    if had_exc {
                        return MoltObject::none().bits();
                    }
                    return MoltObject::from_bool(!truthy).bits();
                }
                CompareValueOutcome::Error => return MoltObject::none().bits(),
                CompareValueOutcome::NotComparable => {}
            }
        }

        MoltObject::from_bool(a != b).bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_eq(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a);
        let rhs = obj_from_bits(b);
        let Some(lp) = lhs.as_ptr() else {
            return MoltObject::from_bool(false).bits();
        };
        let Some(rp) = rhs.as_ptr() else {
            return MoltObject::from_bool(false).bits();
        };
        unsafe {
            if object_type_id(lp) != TYPE_ID_STRING || object_type_id(rp) != TYPE_ID_STRING {
                return MoltObject::from_bool(false).bits();
            }
            if lp == rp {
                return MoltObject::from_bool(true).bits();
            }
            let l_len = string_len(lp);
            let r_len = string_len(rp);
            if l_len != r_len {
                return MoltObject::from_bool(false).bits();
            }
            let l_bytes = std::slice::from_raw_parts(string_bytes(lp), l_len);
            let r_bytes = std::slice::from_raw_parts(string_bytes(rp), r_len);
            MoltObject::from_bool(l_bytes == r_bytes).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_is(a: u64, b: u64) -> u64 {
    crate::with_gil_entry!(_py, { MoltObject::from_bool(a == b).bits() })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_str_from_obj(val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(val_bits);
        if let Some(ptr) = obj.as_ptr() {
            unsafe {
                if object_type_id(ptr) == TYPE_ID_STRING {
                    molt_inc_ref(ptr);
                    return val_bits;
                }
            }
        }
        let rendered = format_obj_str(_py, obj);
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        let ptr = alloc_string(_py, rendered.as_bytes());
        if ptr.is_null() {
            return MoltObject::none().bits();
        }
        MoltObject::from_ptr(ptr).bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_repr_from_obj(val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(val_bits);
        let rendered = format_obj(_py, obj);
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        let ptr = alloc_string(_py, rendered.as_bytes());
        if ptr.is_null() {
            return MoltObject::none().bits();
        }
        MoltObject::from_ptr(ptr).bits()
    })
}

fn ascii_escape(text: &str) -> String {
    let mut out = String::with_capacity(text.len());
    for ch in text.chars() {
        if ch.is_ascii() {
            out.push(ch);
        } else {
            let code = ch as u32;
            if code <= 0xff {
                out.push_str(&format!("\\x{:02x}", code));
            } else if code <= 0xffff {
                out.push_str(&format!("\\u{:04x}", code));
            } else {
                out.push_str(&format!("\\U{:08x}", code));
            }
        }
    }
    out
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_ascii_from_obj(val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(val_bits);
        let rendered = format_obj(_py, obj);
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        let escaped = ascii_escape(&rendered);
        let ptr = alloc_string(_py, escaped.as_bytes());
        if ptr.is_null() {
            return MoltObject::none().bits();
        }
        MoltObject::from_ptr(ptr).bits()
    })
}

fn format_int_base(value: &BigInt, base: u32, prefix: &str, upper: bool) -> String {
    let negative = value.is_negative();
    let mut abs_val = if negative { -value } else { value.clone() };
    if abs_val.is_zero() {
        abs_val = BigInt::from(0);
    }
    let mut digits = abs_val.to_str_radix(base);
    if upper {
        digits = digits.to_uppercase();
    }
    if negative {
        format!("-{prefix}{digits}")
    } else {
        format!("{prefix}{digits}")
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bin_builtin(val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let type_name = class_name_for_error(type_of_bits(_py, val_bits));
        let msg = format!("'{type_name}' object cannot be interpreted as an integer");
        let Some(value) = index_bigint_from_obj(_py, val_bits, &msg) else {
            return MoltObject::none().bits();
        };
        let text = format_int_base(&value, 2, "0b", false);
        let ptr = alloc_string(_py, text.as_bytes());
        if ptr.is_null() {
            return MoltObject::none().bits();
        }
        MoltObject::from_ptr(ptr).bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_oct_builtin(val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let type_name = class_name_for_error(type_of_bits(_py, val_bits));
        let msg = format!("'{type_name}' object cannot be interpreted as an integer");
        let Some(value) = index_bigint_from_obj(_py, val_bits, &msg) else {
            return MoltObject::none().bits();
        };
        let text = format_int_base(&value, 8, "0o", false);
        let ptr = alloc_string(_py, text.as_bytes());
        if ptr.is_null() {
            return MoltObject::none().bits();
        }
        MoltObject::from_ptr(ptr).bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_hex_builtin(val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let type_name = class_name_for_error(type_of_bits(_py, val_bits));
        let msg = format!("'{type_name}' object cannot be interpreted as an integer");
        let Some(value) = index_bigint_from_obj(_py, val_bits, &msg) else {
            return MoltObject::none().bits();
        };
        let text = format_int_base(&value, 16, "0x", false);
        let ptr = alloc_string(_py, text.as_bytes());
        if ptr.is_null() {
            return MoltObject::none().bits();
        }
        MoltObject::from_ptr(ptr).bits()
    })
}

fn parse_float_from_bytes(bytes: &[u8]) -> Result<f64, ()> {
    let text = std::str::from_utf8(bytes).map_err(|_| ())?;
    let trimmed = text.trim();
    trimmed.parse::<f64>().map_err(|_| ())
}

fn parse_complex_from_str(text: &str) -> Result<ComplexParts, ()> {
    let mut trimmed = text.trim();
    if trimmed.is_empty() {
        return Err(());
    }
    if trimmed.starts_with('(') && trimmed.ends_with(')') && trimmed.len() >= 2 {
        trimmed = trimmed[1..trimmed.len() - 1].trim();
        if trimmed.is_empty() {
            return Err(());
        }
    }
    if trimmed.chars().any(|ch| ch.is_whitespace()) {
        return Err(());
    }
    let bytes = trimmed.as_bytes();
    let ends_with_j = matches!(bytes.last(), Some(b'j') | Some(b'J'));
    if ends_with_j {
        let core = &trimmed[..trimmed.len() - 1];
        if core.is_empty() {
            return Ok(ComplexParts { re: 0.0, im: 1.0 });
        }
        if core == "+" {
            return Ok(ComplexParts { re: 0.0, im: 1.0 });
        }
        if core == "-" {
            return Ok(ComplexParts { re: 0.0, im: -1.0 });
        }
        let mut sep_idx = None;
        let core_bytes = core.as_bytes();
        for idx in 1..core_bytes.len() {
            let ch = core_bytes[idx] as char;
            if ch == '+' || ch == '-' {
                let prev = core_bytes[idx - 1] as char;
                if prev == 'e' || prev == 'E' {
                    continue;
                }
                sep_idx = Some(idx);
            }
        }
        if let Some(idx) = sep_idx {
            let real_part = &core[..idx];
            let imag_part = &core[idx..];
            let real = parse_float_from_bytes(real_part.as_bytes())?;
            let imag = if imag_part == "+" {
                1.0
            } else if imag_part == "-" {
                -1.0
            } else {
                parse_float_from_bytes(imag_part.as_bytes())?
            };
            return Ok(ComplexParts { re: real, im: imag });
        }
        let imag = parse_float_from_bytes(core.as_bytes())?;
        return Ok(ComplexParts { re: 0.0, im: imag });
    }
    let real = parse_float_from_bytes(trimmed.as_bytes())?;
    Ok(ComplexParts { re: real, im: 0.0 })
}

fn parse_int_from_str(text: &str, base: i64) -> Result<(BigInt, i64), ()> {
    let trimmed = text.trim();
    if trimmed.is_empty() {
        return Err(());
    }
    let mut sign = 1i32;
    let mut digits = trimmed;
    if let Some(rest) = digits.strip_prefix('+') {
        digits = rest;
    } else if let Some(rest) = digits.strip_prefix('-') {
        digits = rest;
        sign = -1;
    }
    let mut base_val = base;
    if base_val == 0 {
        if let Some(rest) = digits
            .strip_prefix("0x")
            .or_else(|| digits.strip_prefix("0X"))
        {
            base_val = 16;
            digits = rest;
        } else if let Some(rest) = digits
            .strip_prefix("0o")
            .or_else(|| digits.strip_prefix("0O"))
        {
            base_val = 8;
            digits = rest;
        } else if let Some(rest) = digits
            .strip_prefix("0b")
            .or_else(|| digits.strip_prefix("0B"))
        {
            base_val = 2;
            digits = rest;
        } else {
            base_val = 10;
        }
    } else if base_val == 16 {
        if let Some(rest) = digits
            .strip_prefix("0x")
            .or_else(|| digits.strip_prefix("0X"))
        {
            digits = rest;
        }
    } else if base_val == 8 {
        if let Some(rest) = digits
            .strip_prefix("0o")
            .or_else(|| digits.strip_prefix("0O"))
        {
            digits = rest;
        }
    } else if base_val == 2 {
        if let Some(rest) = digits
            .strip_prefix("0b")
            .or_else(|| digits.strip_prefix("0B"))
        {
            digits = rest;
        }
    }
    let digits = digits.replace('_', "");
    if digits.is_empty() {
        return Err(());
    }
    let parsed = BigInt::parse_bytes(digits.as_bytes(), base_val as u32).ok_or(())?;
    let parsed = if sign < 0 { -parsed } else { parsed };
    Ok((parsed, base_val))
}

/// # Safety
/// - `ptr` must be null or valid for `len_bits` bytes.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn molt_bigint_from_str(ptr: *const u8, len_bits: u64) -> u64 {
    unsafe {
        crate::with_gil_entry!(_py, {
            let len = usize_from_bits(len_bits);
            if ptr.is_null() {
                return MoltObject::none().bits();
            }
            let bytes = std::slice::from_raw_parts(ptr, len);
            let text = match std::str::from_utf8(bytes) {
                Ok(val) => val,
                Err(_) => {
                    return raise_exception::<_>(_py, "ValueError", "invalid literal for int()");
                }
            };
            let (parsed, _base_used) = match parse_int_from_str(text, 10) {
                Ok(val) => val,
                Err(_) => {
                    return raise_exception::<_>(_py, "ValueError", "invalid literal for int()");
                }
            };
            if let Some(i) = bigint_to_inline(&parsed) {
                return MoltObject::from_int(i).bits();
            }
            bigint_bits(_py, parsed)
        })
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_float_from_obj(val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(val_bits);
        if obj.is_float() {
            return val_bits;
        }
        if complex_ptr_from_bits(val_bits).is_some() {
            let type_label = type_name(_py, obj);
            let msg =
                format!("float() argument must be a string or a real number, not '{type_label}'");
            return raise_exception::<_>(_py, "TypeError", &msg);
        }
        if let Some(i) = to_i64(obj) {
            return MoltObject::from_float(i as f64).bits();
        }
        if let Some(ptr) = bigint_ptr_from_bits(val_bits) {
            let big = unsafe { bigint_ref(ptr) };
            if let Some(val) = big.to_f64() {
                return MoltObject::from_float(val).bits();
            }
            return raise_exception::<_>(_py, "OverflowError", "int too large to convert to float");
        }
        if let Some(ptr) = maybe_ptr_from_bits(val_bits) {
            unsafe {
                let type_id = object_type_id(ptr);
                if type_id == TYPE_ID_STRING {
                    let len = string_len(ptr);
                    let bytes = std::slice::from_raw_parts(string_bytes(ptr), len);
                    if let Ok(parsed) = parse_float_from_bytes(bytes) {
                        return MoltObject::from_float(parsed).bits();
                    }
                    let rendered = String::from_utf8_lossy(bytes);
                    let msg = format!("could not convert string to float: '{rendered}'");
                    return raise_exception::<_>(_py, "ValueError", &msg);
                }
                if type_id == TYPE_ID_BYTES || type_id == TYPE_ID_BYTEARRAY {
                    let len = bytes_len(ptr);
                    let bytes = std::slice::from_raw_parts(bytes_data(ptr), len);
                    if let Ok(parsed) = parse_float_from_bytes(bytes) {
                        return MoltObject::from_float(parsed).bits();
                    }
                    let rendered = String::from_utf8_lossy(bytes);
                    let msg = format!("could not convert string to float: '{rendered}'");
                    return raise_exception::<_>(_py, "ValueError", &msg);
                }
                let float_name_bits =
                    intern_static_name(_py, &runtime_state(_py).interned.float_name, b"__float__");
                if let Some(call_bits) = attr_lookup_ptr_allow_missing(_py, ptr, float_name_bits) {
                    let res_bits = call_callable0(_py, call_bits);
                    dec_ref_bits(_py, call_bits);
                    let res_obj = obj_from_bits(res_bits);
                    if res_obj.is_float() {
                        return res_bits;
                    }
                    let owner = class_name_for_error(type_of_bits(_py, val_bits));
                    let res_type = class_name_for_error(type_of_bits(_py, res_bits));
                    if res_obj.as_ptr().is_some() {
                        dec_ref_bits(_py, res_bits);
                    }
                    let msg = format!("{owner}.__float__ returned non-float (type {res_type})");
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
                if exception_pending(_py) {
                    return MoltObject::none().bits();
                }
                let index_name_bits =
                    intern_static_name(_py, &runtime_state(_py).interned.index_name, b"__index__");
                if let Some(call_bits) = attr_lookup_ptr_allow_missing(_py, ptr, index_name_bits) {
                    let res_bits = call_callable0(_py, call_bits);
                    dec_ref_bits(_py, call_bits);
                    let res_obj = obj_from_bits(res_bits);
                    if let Some(i) = to_i64(res_obj) {
                        return MoltObject::from_float(i as f64).bits();
                    }
                    let res_type = class_name_for_error(type_of_bits(_py, res_bits));
                    if res_obj.as_ptr().is_some() {
                        dec_ref_bits(_py, res_bits);
                    }
                    let msg = format!("__index__ returned non-int (type {res_type})");
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
                if exception_pending(_py) {
                    return MoltObject::none().bits();
                }
            }
        }
        raise_exception::<_>(
            _py,
            "TypeError",
            "float() argument must be a string or a number",
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_complex_from_obj(val_bits: u64, imag_bits: u64, has_imag_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let has_imag = to_i64(obj_from_bits(has_imag_bits)).unwrap_or(0) != 0;
        let val_obj = obj_from_bits(val_bits);
        if !has_imag {
            if complex_ptr_from_bits(val_bits).is_some() {
                inc_ref_bits(_py, val_bits);
                return val_bits;
            }
            if let Some(f) = val_obj.as_float() {
                return complex_bits(_py, f, 0.0);
            }
            if let Some(i) = to_i64(val_obj) {
                return complex_bits(_py, i as f64, 0.0);
            }
            if let Some(ptr) = bigint_ptr_from_bits(val_bits) {
                if let Some(val) = unsafe { bigint_ref(ptr) }.to_f64() {
                    return complex_bits(_py, val, 0.0);
                }
                return raise_exception::<_>(
                    _py,
                    "OverflowError",
                    "int too large to convert to float",
                );
            }
            if let Some(ptr) = maybe_ptr_from_bits(val_bits) {
                unsafe {
                    let type_id = object_type_id(ptr);
                    if type_id == TYPE_ID_STRING {
                        let len = string_len(ptr);
                        let bytes = std::slice::from_raw_parts(string_bytes(ptr), len);
                        let text = match std::str::from_utf8(bytes) {
                            Ok(val) => val,
                            Err(_) => {
                                return raise_exception::<_>(
                                    _py,
                                    "ValueError",
                                    "complex() arg is a malformed string",
                                );
                            }
                        };
                        match parse_complex_from_str(text) {
                            Ok(parts) => {
                                return complex_bits(_py, parts.re, parts.im);
                            }
                            Err(()) => {
                                return raise_exception::<_>(
                                    _py,
                                    "ValueError",
                                    "complex() arg is a malformed string",
                                );
                            }
                        }
                    }
                    if type_id == TYPE_ID_BYTES || type_id == TYPE_ID_BYTEARRAY {
                        let type_label = type_name(_py, val_obj);
                        let msg = format!(
                            "complex() argument must be a string or a number, not {type_label}"
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                    if let Some(name_bits) = attr_name_bits_from_bytes(_py, b"__complex__") {
                        if let Some(call_bits) = attr_lookup_ptr_allow_missing(_py, ptr, name_bits)
                        {
                            let res_bits = call_callable0(_py, call_bits);
                            dec_ref_bits(_py, call_bits);
                            if exception_pending(_py) {
                                return MoltObject::none().bits();
                            }
                            if complex_ptr_from_bits(res_bits).is_some() {
                                return res_bits;
                            }
                            let owner = class_name_for_error(type_of_bits(_py, val_bits));
                            let res_type = class_name_for_error(type_of_bits(_py, res_bits));
                            if obj_from_bits(res_bits).as_ptr().is_some() {
                                dec_ref_bits(_py, res_bits);
                            }
                            let msg = format!(
                                "{owner}.__complex__ returned non-complex (type {res_type})"
                            );
                            return raise_exception::<_>(_py, "TypeError", &msg);
                        }
                        dec_ref_bits(_py, name_bits);
                    }
                    let float_name_bits = intern_static_name(
                        _py,
                        &runtime_state(_py).interned.float_name,
                        b"__float__",
                    );
                    if let Some(call_bits) =
                        attr_lookup_ptr_allow_missing(_py, ptr, float_name_bits)
                    {
                        let res_bits = call_callable0(_py, call_bits);
                        dec_ref_bits(_py, call_bits);
                        let res_obj = obj_from_bits(res_bits);
                        if let Some(f) = res_obj.as_float() {
                            return complex_bits(_py, f, 0.0);
                        }
                        let owner = class_name_for_error(type_of_bits(_py, val_bits));
                        let res_type = class_name_for_error(type_of_bits(_py, res_bits));
                        if res_obj.as_ptr().is_some() {
                            dec_ref_bits(_py, res_bits);
                        }
                        let msg = format!("{owner}.__float__ returned non-float (type {res_type})");
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    let index_name_bits = intern_static_name(
                        _py,
                        &runtime_state(_py).interned.index_name,
                        b"__index__",
                    );
                    if let Some(call_bits) =
                        attr_lookup_ptr_allow_missing(_py, ptr, index_name_bits)
                    {
                        let res_bits = call_callable0(_py, call_bits);
                        dec_ref_bits(_py, call_bits);
                        let res_obj = obj_from_bits(res_bits);
                        if let Some(i) = to_i64(res_obj) {
                            return complex_bits(_py, i as f64, 0.0);
                        }
                        let res_type = class_name_for_error(type_of_bits(_py, res_bits));
                        if res_obj.as_ptr().is_some() {
                            dec_ref_bits(_py, res_bits);
                        }
                        let msg = format!("__index__ returned non-int (type {res_type})");
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                }
            }
            return raise_exception::<_>(
                _py,
                "TypeError",
                "complex() argument must be a string or a number",
            );
        }
        let imag_obj = obj_from_bits(imag_bits);
        if let Some(ptr) = maybe_ptr_from_bits(val_bits) {
            unsafe {
                let type_id = object_type_id(ptr);
                if type_id == TYPE_ID_STRING
                    || type_id == TYPE_ID_BYTES
                    || type_id == TYPE_ID_BYTEARRAY
                {
                    let type_label = type_name(_py, val_obj);
                    let msg = format!(
                        "complex() argument 'real' must be a real number, not {type_label}"
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            }
        }
        if let Some(ptr) = maybe_ptr_from_bits(imag_bits) {
            unsafe {
                let type_id = object_type_id(ptr);
                if type_id == TYPE_ID_STRING
                    || type_id == TYPE_ID_BYTES
                    || type_id == TYPE_ID_BYTEARRAY
                {
                    let type_label = type_name(_py, imag_obj);
                    let msg = format!(
                        "complex() argument 'imag' must be a real number, not {type_label}"
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            }
        }
        let real = match complex_from_obj_strict(_py, val_obj) {
            Ok(Some(val)) => val,
            Ok(None) => {
                let type_label = type_name(_py, val_obj);
                let msg =
                    format!("complex() argument 'real' must be a real number, not {type_label}");
                return raise_exception::<_>(_py, "TypeError", &msg);
            }
            Err(()) => {
                return raise_exception::<_>(
                    _py,
                    "OverflowError",
                    "int too large to convert to float",
                );
            }
        };
        let imag = match complex_from_obj_strict(_py, imag_obj) {
            Ok(Some(val)) => val,
            Ok(None) => {
                let type_label = type_name(_py, imag_obj);
                let msg =
                    format!("complex() argument 'imag' must be a real number, not {type_label}");
                return raise_exception::<_>(_py, "TypeError", &msg);
            }
            Err(()) => {
                return raise_exception::<_>(
                    _py,
                    "OverflowError",
                    "int too large to convert to float",
                );
            }
        };
        let re = real.re - imag.im;
        let im = real.im + imag.re;
        complex_bits(_py, re, im)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_complex_conjugate(val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let Some(ptr) = complex_ptr_from_bits(val_bits) else {
            return raise_exception::<_>(_py, "TypeError", "complex.conjugate expects complex");
        };
        let value = unsafe { *complex_ref(ptr) };
        complex_bits(_py, value.re, -value.im)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_int_new(cls_bits: u64, val_bits: u64, base_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let cls_obj = obj_from_bits(cls_bits);
        let Some(cls_ptr) = cls_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "int.__new__ expects type");
        };
        unsafe {
            if object_type_id(cls_ptr) != TYPE_ID_TYPE {
                return raise_exception::<_>(_py, "TypeError", "int.__new__ expects type");
            }
        }
        let has_base = base_bits != missing_bits(_py);
        let has_base_bits = MoltObject::from_int(if has_base { 1 } else { 0 }).bits();
        let int_bits = molt_int_from_obj(val_bits, base_bits, has_base_bits);
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        let builtins = builtin_classes(_py);
        if cls_bits == builtins.int {
            return int_bits;
        }
        if !issubclass_bits(cls_bits, builtins.int) {
            let type_label = class_name_for_error(cls_bits);
            let msg = format!("int.__new__ expects type, got {}", type_label);
            return raise_exception::<_>(_py, "TypeError", &msg);
        }
        let inst_bits = unsafe { alloc_instance_for_class(_py, cls_ptr) };
        let Some(inst_ptr) = obj_from_bits(inst_bits).as_ptr() else {
            return MoltObject::none().bits();
        };
        let Some(slot_name_bits) = attr_name_bits_from_bytes(_py, b"__molt_int_value__") else {
            return raise_exception::<_>(
                _py,
                "TypeError",
                "int subclass layout missing value slot",
            );
        };
        let Some(offset) = (unsafe { class_field_offset(_py, cls_ptr, slot_name_bits) }) else {
            dec_ref_bits(_py, slot_name_bits);
            return raise_exception::<_>(
                _py,
                "TypeError",
                "int subclass layout missing value slot",
            );
        };
        dec_ref_bits(_py, slot_name_bits);
        unsafe {
            let _ = object_field_init_ptr_raw(_py, inst_ptr, offset, int_bits);
        }
        inst_bits
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_int_int(self_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(self_bits);
        if obj.is_int() {
            return self_bits;
        }
        if obj.is_bool() {
            return MoltObject::from_int(if obj.as_bool().unwrap_or(false) { 1 } else { 0 }).bits();
        }
        if bigint_ptr_from_bits(self_bits).is_some() {
            inc_ref_bits(_py, self_bits);
            return self_bits;
        }
        if let Some(bits) = int_subclass_value_bits_raw(self_bits) {
            if obj_from_bits(bits).as_ptr().is_some() {
                inc_ref_bits(_py, bits);
            }
            return bits;
        }
        let type_label = class_name_for_error(type_of_bits(_py, self_bits));
        let msg = format!(
            "descriptor '__int__' requires a 'int' object but received '{}'",
            type_label
        );
        raise_exception::<_>(_py, "TypeError", &msg)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_int_index(self_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(self_bits);
        if obj.is_int() {
            return self_bits;
        }
        if obj.is_bool() {
            return MoltObject::from_int(if obj.as_bool().unwrap_or(false) { 1 } else { 0 }).bits();
        }
        if bigint_ptr_from_bits(self_bits).is_some() {
            inc_ref_bits(_py, self_bits);
            return self_bits;
        }
        if let Some(bits) = int_subclass_value_bits_raw(self_bits) {
            if obj_from_bits(bits).as_ptr().is_some() {
                inc_ref_bits(_py, bits);
            }
            return bits;
        }
        let type_label = class_name_for_error(type_of_bits(_py, self_bits));
        let msg = format!(
            "descriptor '__index__' requires a 'int' object but received '{}'",
            type_label
        );
        raise_exception::<_>(_py, "TypeError", &msg)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_int_bit_length(self_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(self_bits);
        let Some(value) = to_bigint(obj) else {
            let type_label = class_name_for_error(type_of_bits(_py, self_bits));
            let msg = format!(
                "descriptor 'bit_length' requires a 'int' object but received '{}'",
                type_label
            );
            return raise_exception::<_>(_py, "TypeError", &msg);
        };
        let (_sign, bytes) = value.to_bytes_be();
        if bytes.is_empty() {
            return MoltObject::from_int(0).bits();
        }
        let lead = bytes[0];
        let lead_bits = 8usize.saturating_sub(lead.leading_zeros() as usize);
        let total_bits = (bytes.len().saturating_sub(1) * 8) + lead_bits;
        MoltObject::from_int(total_bits as i64).bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_int_from_obj(val_bits: u64, base_bits: u64, has_base_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(val_bits);
        let has_base = to_i64(obj_from_bits(has_base_bits)).unwrap_or(0) != 0;
        let base_val = if has_base {
            let base = index_i64_from_obj(_py, base_bits, "int() base must be int");
            if base != 0 && !(2..=36).contains(&base) {
                return raise_exception::<_>(
                    _py,
                    "ValueError",
                    "base must be 0 or between 2 and 36",
                );
            }
            base
        } else {
            10
        };
        let invalid_literal = |base: i64, literal: &str| -> u64 {
            let msg = format!("invalid literal for int() with base {base}: '{literal}'");
            raise_exception::<_>(_py, "ValueError", &msg)
        };
        if has_base {
            let Some(ptr) = maybe_ptr_from_bits(val_bits) else {
                return raise_exception::<_>(
                    _py,
                    "TypeError",
                    "int() can't convert non-string with explicit base",
                );
            };
            unsafe {
                let type_id = object_type_id(ptr);
                if type_id != TYPE_ID_STRING
                    && type_id != TYPE_ID_BYTES
                    && type_id != TYPE_ID_BYTEARRAY
                {
                    return raise_exception::<_>(
                        _py,
                        "TypeError",
                        "int() can't convert non-string with explicit base",
                    );
                }
            }
        }
        if !has_base {
            if complex_ptr_from_bits(val_bits).is_some() {
                let type_label = type_name(_py, obj);
                let msg = format!(
                    "int() argument must be a string, a bytes-like object or a real number, not '{type_label}'"
                );
                return raise_exception::<_>(_py, "TypeError", &msg);
            }
            if let Some(i) = to_i64(obj) {
                return MoltObject::from_int(i).bits();
            }
            if bigint_ptr_from_bits(val_bits).is_some() {
                return val_bits;
            }
            if let Some(f) = to_f64(obj) {
                if f.is_nan() {
                    return raise_exception::<_>(
                        _py,
                        "ValueError",
                        "cannot convert float NaN to integer",
                    );
                }
                if f.is_infinite() {
                    return raise_exception::<_>(
                        _py,
                        "OverflowError",
                        "cannot convert float infinity to integer",
                    );
                }
                let big = bigint_from_f64_trunc(f);
                if let Some(i) = bigint_to_inline(&big) {
                    return MoltObject::from_int(i).bits();
                }
                return bigint_bits(_py, big);
            }
        }
        if let Some(ptr) = maybe_ptr_from_bits(val_bits) {
            unsafe {
                let type_id = object_type_id(ptr);
                if type_id == TYPE_ID_STRING {
                    let len = string_len(ptr);
                    let bytes = std::slice::from_raw_parts(string_bytes(ptr), len);
                    let text = match std::str::from_utf8(bytes) {
                        Ok(val) => val,
                        Err(_) => return invalid_literal(base_val, "<bytes>"),
                    };
                    let base = if has_base { base_val } else { 10 };
                    let (parsed, _base_used) = match parse_int_from_str(text, base) {
                        Ok(val) => val,
                        Err(_) => return invalid_literal(base, text),
                    };
                    if let Some(i) = bigint_to_inline(&parsed) {
                        return MoltObject::from_int(i).bits();
                    }
                    return bigint_bits(_py, parsed);
                }
                if type_id == TYPE_ID_BYTES || type_id == TYPE_ID_BYTEARRAY {
                    let len = bytes_len(ptr);
                    let bytes = std::slice::from_raw_parts(bytes_data(ptr), len);
                    let text = String::from_utf8_lossy(bytes);
                    let base = if has_base { base_val } else { 10 };
                    let (parsed, _base_used) = match parse_int_from_str(&text, base) {
                        Ok(val) => val,
                        Err(_) => return invalid_literal(base, &format!("b'{text}'")),
                    };
                    if let Some(i) = bigint_to_inline(&parsed) {
                        return MoltObject::from_int(i).bits();
                    }
                    return bigint_bits(_py, parsed);
                }
                if !has_base {
                    let int_name_bits =
                        intern_static_name(_py, &runtime_state(_py).interned.int_name, b"__int__");
                    if let Some(call_bits) = attr_lookup_ptr_allow_missing(_py, ptr, int_name_bits)
                    {
                        let res_bits = call_callable0(_py, call_bits);
                        dec_ref_bits(_py, call_bits);
                        let res_obj = obj_from_bits(res_bits);
                        if let Some(i) = to_i64(res_obj) {
                            return MoltObject::from_int(i).bits();
                        }
                        if bigint_ptr_from_bits(res_bits).is_some() {
                            return res_bits;
                        }
                        let res_type = class_name_for_error(type_of_bits(_py, res_bits));
                        if res_obj.as_ptr().is_some() {
                            dec_ref_bits(_py, res_bits);
                        }
                        let msg = format!("__int__ returned non-int (type {res_type})");
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    let index_name_bits = intern_static_name(
                        _py,
                        &runtime_state(_py).interned.index_name,
                        b"__index__",
                    );
                    if let Some(call_bits) =
                        attr_lookup_ptr_allow_missing(_py, ptr, index_name_bits)
                    {
                        let res_bits = call_callable0(_py, call_bits);
                        dec_ref_bits(_py, call_bits);
                        let res_obj = obj_from_bits(res_bits);
                        if let Some(i) = to_i64(res_obj) {
                            return MoltObject::from_int(i).bits();
                        }
                        if bigint_ptr_from_bits(res_bits).is_some() {
                            return res_bits;
                        }
                        let res_type = class_name_for_error(type_of_bits(_py, res_bits));
                        if res_obj.as_ptr().is_some() {
                            dec_ref_bits(_py, res_bits);
                        }
                        let msg = format!("__index__ returned non-int (type {res_type})");
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                }
            }
        }
        if has_base {
            return raise_exception::<_>(_py, "ValueError", "invalid literal for int()");
        }
        raise_exception::<_>(
            _py,
            "TypeError",
            "int() argument must be a string or a number",
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_guard_type(val_bits: u64, expected_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let expected = match to_i64(obj_from_bits(expected_bits)) {
            Some(val) => val,
            None => return raise_exception::<_>(_py, "TypeError", "guard type tag must be int"),
        };
        if expected == TYPE_TAG_ANY {
            return val_bits;
        }
        let obj = obj_from_bits(val_bits);
        let matches = match expected {
            TYPE_TAG_INT => obj.is_int() || bigint_ptr_from_bits(val_bits).is_some(),
            TYPE_TAG_FLOAT => obj.is_float(),
            TYPE_TAG_COMPLEX => obj
                .as_ptr()
                .is_some_and(|ptr| unsafe { object_type_id(ptr) == TYPE_ID_COMPLEX }),
            TYPE_TAG_BOOL => obj.is_bool(),
            TYPE_TAG_NONE => obj.is_none(),
            TYPE_TAG_STR => obj
                .as_ptr()
                .is_some_and(|ptr| unsafe { object_type_id(ptr) == TYPE_ID_STRING }),
            TYPE_TAG_BYTES => obj
                .as_ptr()
                .is_some_and(|ptr| unsafe { object_type_id(ptr) == TYPE_ID_BYTES }),
            TYPE_TAG_BYTEARRAY => obj
                .as_ptr()
                .is_some_and(|ptr| unsafe { object_type_id(ptr) == TYPE_ID_BYTEARRAY }),
            TYPE_TAG_LIST => obj
                .as_ptr()
                .is_some_and(|ptr| unsafe { object_type_id(ptr) == TYPE_ID_LIST }),
            TYPE_TAG_TUPLE => obj
                .as_ptr()
                .is_some_and(|ptr| unsafe { object_type_id(ptr) == TYPE_ID_TUPLE }),
            TYPE_TAG_INTARRAY => obj
                .as_ptr()
                .is_some_and(|ptr| unsafe { object_type_id(ptr) == TYPE_ID_INTARRAY }),
            TYPE_TAG_DICT => obj
                .as_ptr()
                .is_some_and(|ptr| unsafe { object_type_id(ptr) == TYPE_ID_DICT }),
            TYPE_TAG_SET => obj
                .as_ptr()
                .is_some_and(|ptr| unsafe { object_type_id(ptr) == TYPE_ID_SET }),
            TYPE_TAG_FROZENSET => obj
                .as_ptr()
                .is_some_and(|ptr| unsafe { object_type_id(ptr) == TYPE_ID_FROZENSET }),
            TYPE_TAG_RANGE => obj
                .as_ptr()
                .is_some_and(|ptr| unsafe { object_type_id(ptr) == TYPE_ID_RANGE }),
            TYPE_TAG_SLICE => obj
                .as_ptr()
                .is_some_and(|ptr| unsafe { object_type_id(ptr) == TYPE_ID_SLICE }),
            TYPE_TAG_DATACLASS => obj
                .as_ptr()
                .is_some_and(|ptr| unsafe { object_type_id(ptr) == TYPE_ID_DATACLASS }),
            TYPE_TAG_BUFFER2D => obj
                .as_ptr()
                .is_some_and(|ptr| unsafe { object_type_id(ptr) == TYPE_ID_BUFFER2D }),
            TYPE_TAG_MEMORYVIEW => obj
                .as_ptr()
                .is_some_and(|ptr| unsafe { object_type_id(ptr) == TYPE_ID_MEMORYVIEW }),
            _ => false,
        };
        if !matches {
            profile_hit_unchecked(&GUARD_TAG_TYPE_MISMATCH_DEOPT_COUNT);
            return raise_exception::<_>(_py, "TypeError", "type guard mismatch");
        }
        val_bits
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_is_truthy(val: u64) -> i64 {
    crate::with_gil_entry!(_py, {
        if is_truthy(_py, obj_from_bits(val)) {
            1
        } else {
            0
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_not(val: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        MoltObject::from_bool(!is_truthy(_py, obj_from_bits(val))).bits()
    })
}

fn env_flag_enabled(name: &str) -> bool {
    std::env::var(name)
        .map(|val| !val.is_empty() && val != "0")
        .unwrap_or(false)
}

fn maybe_emit_runtime_feedback_file(payload: &serde_json::Value) {
    if !env_flag_enabled("MOLT_RUNTIME_FEEDBACK") {
        return;
    }
    let out_path = std::env::var("MOLT_RUNTIME_FEEDBACK_FILE")
        .ok()
        .filter(|val| !val.is_empty())
        .unwrap_or_else(|| "molt_runtime_feedback.json".to_string());
    let path = std::path::Path::new(&out_path);
    if let Some(parent) = path.parent() {
        if !parent.as_os_str().is_empty() {
            if let Err(err) = std::fs::create_dir_all(parent) {
                eprintln!(
                    "molt_runtime_feedback_error stage=create_dir path={} err={}",
                    path.display(),
                    err
                );
                return;
            }
        }
    }
    let encoded = match serde_json::to_string_pretty(payload) {
        Ok(value) => value,
        Err(err) => {
            eprintln!(
                "molt_runtime_feedback_error stage=encode path={} err={}",
                path.display(),
                err
            );
            return;
        }
    };
    if let Err(err) = std::fs::write(path, encoded) {
        eprintln!(
            "molt_runtime_feedback_error stage=write path={} err={}",
            path.display(),
            err
        );
        return;
    }
    eprintln!("molt_runtime_feedback_file {}", path.display());
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_profile_dump() {
    crate::with_gil_entry!(_py, {
        if !profile_enabled(_py) {
            return;
        }
        let call_dispatch = CALL_DISPATCH_COUNT.load(AtomicOrdering::Relaxed);
        let cache_hit = runtime_state(_py)
            .string_count_cache_hit
            .load(AtomicOrdering::Relaxed);
        let cache_miss = runtime_state(_py)
            .string_count_cache_miss
            .load(AtomicOrdering::Relaxed);
        let struct_stores = STRUCT_FIELD_STORE_COUNT.load(AtomicOrdering::Relaxed);
        let attr_lookups = ATTR_LOOKUP_COUNT.load(AtomicOrdering::Relaxed);
        let handle_resolves = HANDLE_RESOLVE_COUNT.load(AtomicOrdering::Relaxed);
        let layout_guard = LAYOUT_GUARD_COUNT.load(AtomicOrdering::Relaxed);
        let layout_guard_fail = LAYOUT_GUARD_FAIL.load(AtomicOrdering::Relaxed);
        let allocs = ALLOC_COUNT.load(AtomicOrdering::Relaxed);
        let alloc_objects = ALLOC_OBJECT_COUNT.load(AtomicOrdering::Relaxed);
        let alloc_exceptions = ALLOC_EXCEPTION_COUNT.load(AtomicOrdering::Relaxed);
        let alloc_dicts = ALLOC_DICT_COUNT.load(AtomicOrdering::Relaxed);
        let alloc_tuples = ALLOC_TUPLE_COUNT.load(AtomicOrdering::Relaxed);
        let alloc_strings = ALLOC_STRING_COUNT.load(AtomicOrdering::Relaxed);
        let alloc_callargs = ALLOC_CALLARGS_COUNT.load(AtomicOrdering::Relaxed);
        let tb_builds = TRACEBACK_BUILD_COUNT.load(AtomicOrdering::Relaxed);
        let tb_frames = TRACEBACK_BUILD_FRAMES.load(AtomicOrdering::Relaxed);
        let tb_suppressed = TRACEBACK_SUPPRESS_COUNT.load(AtomicOrdering::Relaxed);
        let async_polls = ASYNC_POLL_COUNT.load(AtomicOrdering::Relaxed);
        let async_pending = ASYNC_PENDING_COUNT.load(AtomicOrdering::Relaxed);
        let async_wakeups = ASYNC_WAKEUP_COUNT.load(AtomicOrdering::Relaxed);
        let async_sleep_reg = ASYNC_SLEEP_REGISTER_COUNT.load(AtomicOrdering::Relaxed);
        let call_bind_ic_hit = CALL_BIND_IC_HIT_COUNT.load(AtomicOrdering::Relaxed);
        let call_bind_ic_miss = CALL_BIND_IC_MISS_COUNT.load(AtomicOrdering::Relaxed);
        let call_indirect_noncallable_deopt =
            CALL_INDIRECT_NONCALLABLE_DEOPT_COUNT.load(AtomicOrdering::Relaxed);
        let invoke_ffi_bridge_capability_denied =
            INVOKE_FFI_BRIDGE_CAPABILITY_DENIED_COUNT.load(AtomicOrdering::Relaxed);
        let guard_tag_type_mismatch_deopt =
            GUARD_TAG_TYPE_MISMATCH_DEOPT_COUNT.load(AtomicOrdering::Relaxed);
        let guard_dict_shape_layout_mismatch_deopt =
            GUARD_DICT_SHAPE_LAYOUT_MISMATCH_DEOPT_COUNT.load(AtomicOrdering::Relaxed);
        let guard_dict_shape_layout_fail_null_obj =
            GUARD_DICT_SHAPE_LAYOUT_FAIL_NULL_OBJ_COUNT.load(AtomicOrdering::Relaxed);
        let guard_dict_shape_layout_fail_non_object =
            GUARD_DICT_SHAPE_LAYOUT_FAIL_NON_OBJECT_COUNT.load(AtomicOrdering::Relaxed);
        let guard_dict_shape_layout_fail_class_mismatch =
            GUARD_DICT_SHAPE_LAYOUT_FAIL_CLASS_MISMATCH_COUNT.load(AtomicOrdering::Relaxed);
        let guard_dict_shape_layout_fail_non_type_class =
            GUARD_DICT_SHAPE_LAYOUT_FAIL_NON_TYPE_CLASS_COUNT.load(AtomicOrdering::Relaxed);
        let guard_dict_shape_layout_fail_expected_version_invalid =
            GUARD_DICT_SHAPE_LAYOUT_FAIL_EXPECTED_VERSION_INVALID_COUNT
                .load(AtomicOrdering::Relaxed);
        let guard_dict_shape_layout_fail_version_mismatch =
            GUARD_DICT_SHAPE_LAYOUT_FAIL_VERSION_MISMATCH_COUNT.load(AtomicOrdering::Relaxed);
        let attr_site_name_hit = ATTR_SITE_NAME_CACHE_HIT_COUNT.load(AtomicOrdering::Relaxed);
        let attr_site_name_miss = ATTR_SITE_NAME_CACHE_MISS_COUNT.load(AtomicOrdering::Relaxed);
        let split_ws_ascii = SPLIT_WS_ASCII_FAST_PATH_COUNT.load(AtomicOrdering::Relaxed);
        let split_ws_unicode = SPLIT_WS_UNICODE_PATH_COUNT.load(AtomicOrdering::Relaxed);
        let dict_str_int_prehash_hit = DICT_STR_INT_PREHASH_HIT_COUNT.load(AtomicOrdering::Relaxed);
        let dict_str_int_prehash_miss =
            DICT_STR_INT_PREHASH_MISS_COUNT.load(AtomicOrdering::Relaxed);
        let dict_str_int_prehash_deopt =
            DICT_STR_INT_PREHASH_DEOPT_COUNT.load(AtomicOrdering::Relaxed);
        let taq_ingest_calls = TAQ_INGEST_CALL_COUNT.load(AtomicOrdering::Relaxed);
        let taq_ingest_skip_marker = TAQ_INGEST_SKIP_MARKER_COUNT.load(AtomicOrdering::Relaxed);
        let ascii_i64_parse_fail = ASCII_I64_PARSE_FAIL_COUNT.load(AtomicOrdering::Relaxed);
        eprintln!(
            "molt_profile call_dispatch={} string_count_cache_hit={} string_count_cache_miss={} struct_field_store={} attr_lookup={} handle_resolve={} layout_guard={} layout_guard_fail={} alloc_count={} alloc_object={} alloc_exception={} alloc_dict={} alloc_tuple={} alloc_string={} alloc_callargs={} tb_builds={} tb_frames={} tb_suppressed={} async_polls={} async_pending={} async_wakeups={} async_sleep_register={} call_bind_ic_hit={} call_bind_ic_miss={} call_indirect_noncallable_deopt={} invoke_ffi_bridge_capability_denied={} guard_tag_type_mismatch_deopt={} guard_dict_shape_layout_mismatch_deopt={} attr_site_name_hit={} attr_site_name_miss={} split_ws_ascii={} split_ws_unicode={} dict_str_int_prehash_hit={} dict_str_int_prehash_miss={} dict_str_int_prehash_deopt={} taq_ingest_calls={} taq_ingest_skip_marker={} ascii_i64_parse_fail={}",
            call_dispatch,
            cache_hit,
            cache_miss,
            struct_stores,
            attr_lookups,
            handle_resolves,
            layout_guard,
            layout_guard_fail,
            allocs,
            alloc_objects,
            alloc_exceptions,
            alloc_dicts,
            alloc_tuples,
            alloc_strings,
            alloc_callargs,
            tb_builds,
            tb_frames,
            tb_suppressed,
            async_polls,
            async_pending,
            async_wakeups,
            async_sleep_reg,
            call_bind_ic_hit,
            call_bind_ic_miss,
            call_indirect_noncallable_deopt,
            invoke_ffi_bridge_capability_denied,
            guard_tag_type_mismatch_deopt,
            guard_dict_shape_layout_mismatch_deopt,
            attr_site_name_hit,
            attr_site_name_miss,
            split_ws_ascii,
            split_ws_unicode,
            dict_str_int_prehash_hit,
            dict_str_int_prehash_miss,
            dict_str_int_prehash_deopt,
            taq_ingest_calls,
            taq_ingest_skip_marker,
            ascii_i64_parse_fail
        );
        let payload = serde_json::json!({
            "schema_version": 1,
            "kind": "runtime_feedback",
            "profile": {
                "call_dispatch": call_dispatch,
                "string_count_cache_hit": cache_hit,
                "string_count_cache_miss": cache_miss,
                "struct_field_store": struct_stores,
                "attr_lookup": attr_lookups,
                "handle_resolve": handle_resolves,
                "layout_guard": layout_guard,
                "layout_guard_fail": layout_guard_fail,
                "alloc_count": allocs,
                "alloc_object": alloc_objects,
                "alloc_exception": alloc_exceptions,
                "alloc_dict": alloc_dicts,
                "alloc_tuple": alloc_tuples,
                "alloc_string": alloc_strings,
                "alloc_callargs": alloc_callargs,
                "tb_builds": tb_builds,
                "tb_frames": tb_frames,
                "tb_suppressed": tb_suppressed,
                "async_polls": async_polls,
                "async_pending": async_pending,
                "async_wakeups": async_wakeups,
                "async_sleep_register": async_sleep_reg,
            },
            "hot_paths": {
                "call_bind_ic_hit": call_bind_ic_hit,
                "call_bind_ic_miss": call_bind_ic_miss,
                "attr_site_name_hit": attr_site_name_hit,
                "attr_site_name_miss": attr_site_name_miss,
                "split_ws_ascii": split_ws_ascii,
                "split_ws_unicode": split_ws_unicode,
                "dict_str_int_prehash_hit": dict_str_int_prehash_hit,
                "dict_str_int_prehash_miss": dict_str_int_prehash_miss,
                "dict_str_int_prehash_deopt": dict_str_int_prehash_deopt,
                "taq_ingest_calls": taq_ingest_calls,
                "taq_ingest_skip_marker": taq_ingest_skip_marker,
                "ascii_i64_parse_fail": ascii_i64_parse_fail,
            },
            "deopt_reasons": {
                "call_indirect_noncallable": call_indirect_noncallable_deopt,
                "invoke_ffi_bridge_capability_denied": invoke_ffi_bridge_capability_denied,
                "guard_tag_type_mismatch": guard_tag_type_mismatch_deopt,
                "guard_dict_shape_layout_mismatch": guard_dict_shape_layout_mismatch_deopt,
                "guard_dict_shape_layout_fail_null_obj": guard_dict_shape_layout_fail_null_obj,
                "guard_dict_shape_layout_fail_non_object": guard_dict_shape_layout_fail_non_object,
                "guard_dict_shape_layout_fail_class_mismatch": guard_dict_shape_layout_fail_class_mismatch,
                "guard_dict_shape_layout_fail_non_type_class": guard_dict_shape_layout_fail_non_type_class,
                "guard_dict_shape_layout_fail_expected_version_invalid": guard_dict_shape_layout_fail_expected_version_invalid,
                "guard_dict_shape_layout_fail_version_mismatch": guard_dict_shape_layout_fail_version_mismatch,
            },
        });
        if env_flag_enabled("MOLT_PROFILE_JSON") {
            eprintln!("molt_profile_json {}", payload);
        }
        maybe_emit_runtime_feedback_file(&payload);
    })
}

fn vec_sum_result(_py: &PyToken<'_>, sum_bits: u64, ok: bool) -> u64 {
    let ok_bits = MoltObject::from_bool(ok).bits();
    let tuple_ptr = alloc_tuple(_py, &[sum_bits, ok_bits]);
    if tuple_ptr.is_null() {
        return MoltObject::none().bits();
    }
    MoltObject::from_ptr(tuple_ptr).bits()
}

fn vec_sum_i64_result(_py: &PyToken<'_>, value: i64, ok: bool) -> u64 {
    let value_bits = int_bits_from_i64(_py, value);
    let out = vec_sum_result(_py, value_bits, ok);
    dec_ref_bits(_py, value_bits);
    out
}

fn vec_sum_f64_result(_py: &PyToken<'_>, value: f64, ok: bool) -> u64 {
    vec_sum_result(_py, MoltObject::from_float(value).bits(), ok)
}

fn number_as_f64(obj: MoltObject) -> Option<f64> {
    if let Some(f) = obj.as_float() {
        return Some(f);
    }
    obj.as_int().map(|i| i as f64)
}

fn sum_floats_scalar(elems: &[u64], acc: f64) -> Option<f64> {
    let mut sum = acc;
    for &bits in elems {
        let obj = MoltObject::from_bits(bits);
        sum += number_as_f64(obj)?;
    }
    Some(sum)
}

fn sum_float_range_arith_checked(start: i64, stop: i64, step: i64, acc: f64) -> Option<f64> {
    let len = range_len_i128(start, stop, step);
    if len <= 0 {
        return Some(acc);
    }
    let n = len as f64;
    let first = start as f64;
    let stride = step as f64;
    let last = first + stride * (n - 1.0);
    let total = acc + (n * (first + last) * 0.5);
    total.is_finite().then_some(total)
}

fn sum_ints_scalar(elems: &[u64], acc: i64) -> Option<i64> {
    let mut sum = acc;
    for &bits in elems {
        let obj = MoltObject::from_bits(bits);
        if let Some(val) = obj.as_int() {
            sum += val;
        } else {
            return None;
        }
    }
    Some(sum)
}

const VEC_LANE_WARMUP_SAMPLES: u64 = 128;
const VEC_LANE_MISS_RATIO_LIMIT: u64 = 4;

static VEC_SUM_INT_HITS: AtomicU64 = AtomicU64::new(0);
static VEC_SUM_INT_MISSES: AtomicU64 = AtomicU64::new(0);
static VEC_SUM_FLOAT_HITS: AtomicU64 = AtomicU64::new(0);
static VEC_SUM_FLOAT_MISSES: AtomicU64 = AtomicU64::new(0);

fn adaptive_vec_lanes_enabled() -> bool {
    static FLAG: OnceLock<bool> = OnceLock::new();
    *FLAG.get_or_init(|| {
        std::env::var("MOLT_ADAPTIVE_VEC_LANES")
            .ok()
            .map(|raw| {
                let norm = raw.trim().to_ascii_lowercase();
                !matches!(norm.as_str(), "0" | "false" | "off" | "no")
            })
            .unwrap_or(true)
    })
}

fn vec_lane_allowed(hits: &AtomicU64, misses: &AtomicU64) -> bool {
    if !adaptive_vec_lanes_enabled() {
        return true;
    }
    let hit = hits.load(AtomicOrdering::Relaxed);
    let miss = misses.load(AtomicOrdering::Relaxed);
    let samples = hit.saturating_add(miss);
    if samples < VEC_LANE_WARMUP_SAMPLES {
        return true;
    }
    miss <= hit.saturating_mul(VEC_LANE_MISS_RATIO_LIMIT)
}

fn vec_lane_record(hits: &AtomicU64, misses: &AtomicU64, success: bool) {
    if !adaptive_vec_lanes_enabled() {
        return;
    }
    if success {
        hits.fetch_add(1, AtomicOrdering::Relaxed);
    } else {
        misses.fetch_add(1, AtomicOrdering::Relaxed);
    }
}

#[cfg(target_arch = "x86_64")]
unsafe fn sum_ints_simd_x86_64(elems: &[u64], acc: i64) -> Option<i64> {
    use std::arch::x86_64::*;
    let mut i = 0usize;
    let mut vec_sum = _mm_setzero_si128();
    while i + 2 <= elems.len() {
        let obj0 = MoltObject::from_bits(elems[i]);
        let obj1 = MoltObject::from_bits(elems[i + 1]);
        let v0 = obj0.as_int()?;
        let v1 = obj1.as_int()?;
        let vec = _mm_set_epi64x(v1, v0);
        vec_sum = _mm_add_epi64(vec_sum, vec);
        i += 2;
    }
    let mut lanes = [0i64; 2];
    _mm_storeu_si128(lanes.as_mut_ptr() as *mut __m128i, vec_sum);
    let mut sum = acc + lanes[0] + lanes[1];
    for &bits in &elems[i..] {
        let obj = MoltObject::from_bits(bits);
        let val = obj.as_int()?;
        sum += val;
    }
    Some(sum)
}

#[cfg(target_arch = "x86_64")]
unsafe fn sum_ints_simd_x86_64_avx2(elems: &[u64], acc: i64) -> Option<i64> {
    use std::arch::x86_64::*;
    let mut i = 0usize;
    let mut vec_sum = _mm256_setzero_si256();
    while i + 4 <= elems.len() {
        let obj0 = MoltObject::from_bits(elems[i]);
        let obj1 = MoltObject::from_bits(elems[i + 1]);
        let obj2 = MoltObject::from_bits(elems[i + 2]);
        let obj3 = MoltObject::from_bits(elems[i + 3]);
        let v0 = obj0.as_int()?;
        let v1 = obj1.as_int()?;
        let v2 = obj2.as_int()?;
        let v3 = obj3.as_int()?;
        let vec = _mm256_set_epi64x(v3, v2, v1, v0);
        vec_sum = _mm256_add_epi64(vec_sum, vec);
        i += 4;
    }
    let mut lanes = [0i64; 4];
    _mm256_storeu_si256(lanes.as_mut_ptr() as *mut __m256i, vec_sum);
    let mut sum = acc + lanes.iter().sum::<i64>();
    for &bits in &elems[i..] {
        let obj = MoltObject::from_bits(bits);
        let val = obj.as_int()?;
        sum += val;
    }
    Some(sum)
}

#[cfg(target_arch = "aarch64")]
unsafe fn sum_ints_simd_aarch64(elems: &[u64], acc: i64) -> Option<i64> {
    unsafe {
        use std::arch::aarch64::*;
        let mut i = 0usize;
        let mut vec_sum = vdupq_n_s64(0);
        while i + 2 <= elems.len() {
            let obj0 = MoltObject::from_bits(elems[i]);
            let obj1 = MoltObject::from_bits(elems[i + 1]);
            let v0 = obj0.as_int()?;
            let v1 = obj1.as_int()?;
            let lanes = [v0, v1];
            let vec = vld1q_s64(lanes.as_ptr());
            vec_sum = vaddq_s64(vec_sum, vec);
            i += 2;
        }
        let mut lanes = [0i64; 2];
        vst1q_s64(lanes.as_mut_ptr(), vec_sum);
        let mut sum = acc + lanes[0] + lanes[1];
        for &bits in &elems[i..] {
            let obj = MoltObject::from_bits(bits);
            let val = obj.as_int()?;
            sum += val;
        }
        Some(sum)
    }
}

fn sum_ints_checked(elems: &[u64], acc: i64) -> Option<i64> {
    #[cfg(target_arch = "x86_64")]
    {
        if std::arch::is_x86_feature_detected!("avx2") {
            return unsafe { sum_ints_simd_x86_64_avx2(elems, acc) };
        }
        if std::arch::is_x86_feature_detected!("sse2") {
            return unsafe { sum_ints_simd_x86_64(elems, acc) };
        }
    }
    #[cfg(target_arch = "aarch64")]
    {
        if std::arch::is_aarch64_feature_detected!("neon") {
            return unsafe { sum_ints_simd_aarch64(elems, acc) };
        }
    }
    sum_ints_scalar(elems, acc)
}

fn prod_ints_scalar(elems: &[u64], acc: i64) -> Option<i64> {
    let mut prod = acc;
    for &bits in elems {
        let obj = MoltObject::from_bits(bits);
        if let Some(val) = obj.as_int() {
            prod *= val;
        } else {
            return None;
        }
    }
    Some(prod)
}

fn prod_ints_unboxed(elems: &[i64], acc: i64) -> i64 {
    let mut prod = acc;
    if prod == 0 {
        return 0;
    }
    if prod == 1 {
        if let Some(result) = prod_ints_unboxed_trivial(elems) {
            return result;
        }
    }
    for &val in elems {
        if val == 0 {
            return 0;
        }
        prod *= val;
    }
    prod
}

fn prod_ints_unboxed_trivial(_elems: &[i64]) -> Option<i64> {
    #[cfg(target_arch = "x86_64")]
    {
        if std::arch::is_x86_feature_detected!("avx2") {
            return unsafe { prod_ints_unboxed_avx2_trivial(_elems) };
        }
    }
    None
}

#[cfg(target_arch = "x86_64")]
unsafe fn prod_ints_unboxed_avx2_trivial(elems: &[i64]) -> Option<i64> {
    use std::arch::x86_64::*;
    let mut idx = 0usize;
    let ones = _mm256_set1_epi64x(1);
    let zeros = _mm256_setzero_si256();
    let mut all_ones = true;
    while idx + 4 <= elems.len() {
        let vec = _mm256_loadu_si256(elems.as_ptr().add(idx) as *const __m256i);
        let eq_zero = _mm256_cmpeq_epi64(vec, zeros);
        if _mm256_movemask_epi8(eq_zero) != 0 {
            return Some(0);
        }
        if all_ones {
            let eq_one = _mm256_cmpeq_epi64(vec, ones);
            if _mm256_movemask_epi8(eq_one) != -1 {
                all_ones = false;
            }
        }
        idx += 4;
    }
    for &val in &elems[idx..] {
        if val == 0 {
            return Some(0);
        }
        if val != 1 {
            all_ones = false;
        }
    }
    if all_ones {
        return Some(1);
    }
    None
}

#[cfg(target_arch = "aarch64")]
unsafe fn prod_ints_simd_aarch64(elems: &[u64], acc: i64) -> Option<i64> {
    prod_ints_scalar(elems, acc)
}

fn prod_ints_checked(elems: &[u64], acc: i64) -> Option<i64> {
    #[cfg(target_arch = "aarch64")]
    {
        if std::arch::is_aarch64_feature_detected!("neon") {
            return unsafe { prod_ints_simd_aarch64(elems, acc) };
        }
    }
    prod_ints_scalar(elems, acc)
}

fn min_ints_scalar(elems: &[u64], acc: i64) -> Option<i64> {
    let mut min_val = acc;
    for &bits in elems {
        let obj = MoltObject::from_bits(bits);
        if let Some(val) = obj.as_int() {
            if val < min_val {
                min_val = val;
            }
        } else {
            return None;
        }
    }
    Some(min_val)
}

#[cfg(target_arch = "x86_64")]
unsafe fn min_ints_simd_x86_64(elems: &[u64], acc: i64) -> Option<i64> {
    use std::arch::x86_64::*;
    let mut i = 0usize;
    let mut vec_min = _mm_set1_epi64x(acc);
    while i + 2 <= elems.len() {
        let obj0 = MoltObject::from_bits(elems[i]);
        let obj1 = MoltObject::from_bits(elems[i + 1]);
        let v0 = obj0.as_int()?;
        let v1 = obj1.as_int()?;
        let vec = _mm_set_epi64x(v1, v0);
        let cmp = _mm_cmpgt_epi64(vec_min, vec);
        vec_min = _mm_blendv_epi8(vec_min, vec, cmp);
        i += 2;
    }
    let mut lanes = [0i64; 2];
    _mm_storeu_si128(lanes.as_mut_ptr() as *mut __m128i, vec_min);
    let mut min_val = acc.min(lanes[0]).min(lanes[1]);
    for &bits in &elems[i..] {
        let obj = MoltObject::from_bits(bits);
        let val = obj.as_int()?;
        if val < min_val {
            min_val = val;
        }
    }
    Some(min_val)
}

#[cfg(target_arch = "x86_64")]
unsafe fn min_ints_simd_x86_64_avx2(elems: &[u64], acc: i64) -> Option<i64> {
    use std::arch::x86_64::*;
    let mut i = 0usize;
    let mut vec_min = _mm256_set1_epi64x(acc);
    while i + 4 <= elems.len() {
        let obj0 = MoltObject::from_bits(elems[i]);
        let obj1 = MoltObject::from_bits(elems[i + 1]);
        let obj2 = MoltObject::from_bits(elems[i + 2]);
        let obj3 = MoltObject::from_bits(elems[i + 3]);
        let v0 = obj0.as_int()?;
        let v1 = obj1.as_int()?;
        let v2 = obj2.as_int()?;
        let v3 = obj3.as_int()?;
        let vec = _mm256_set_epi64x(v3, v2, v1, v0);
        let cmp = _mm256_cmpgt_epi64(vec_min, vec);
        vec_min = _mm256_blendv_epi8(vec_min, vec, cmp);
        i += 4;
    }
    let mut lanes = [0i64; 4];
    _mm256_storeu_si256(lanes.as_mut_ptr() as *mut __m256i, vec_min);
    let mut min_val = acc;
    for lane in lanes {
        if lane < min_val {
            min_val = lane;
        }
    }
    for &bits in &elems[i..] {
        let obj = MoltObject::from_bits(bits);
        let val = obj.as_int()?;
        if val < min_val {
            min_val = val;
        }
    }
    Some(min_val)
}

#[cfg(target_arch = "aarch64")]
unsafe fn min_ints_simd_aarch64(elems: &[u64], acc: i64) -> Option<i64> {
    unsafe {
        use std::arch::aarch64::*;
        let mut i = 0usize;
        let mut vec_min = vdupq_n_s64(acc);
        while i + 2 <= elems.len() {
            let obj0 = MoltObject::from_bits(elems[i]);
            let obj1 = MoltObject::from_bits(elems[i + 1]);
            let v0 = obj0.as_int()?;
            let v1 = obj1.as_int()?;
            let lanes = [v0, v1];
            let vec = vld1q_s64(lanes.as_ptr());
            let mask = vcgtq_s64(vec_min, vec);
            let vec_min_u = vreinterpretq_u64_s64(vec_min);
            let vec_u = vreinterpretq_u64_s64(vec);
            let blended_u = vbslq_u64(mask, vec_u, vec_min_u);
            vec_min = vreinterpretq_s64_u64(blended_u);
            i += 2;
        }
        let mut lanes = [0i64; 2];
        vst1q_s64(lanes.as_mut_ptr(), vec_min);
        let mut min_val = acc.min(lanes[0]).min(lanes[1]);
        for &bits in &elems[i..] {
            let obj = MoltObject::from_bits(bits);
            let val = obj.as_int()?;
            if val < min_val {
                min_val = val;
            }
        }
        Some(min_val)
    }
}

fn min_ints_checked(elems: &[u64], acc: i64) -> Option<i64> {
    #[cfg(target_arch = "x86_64")]
    {
        if std::arch::is_x86_feature_detected!("avx2") {
            return unsafe { min_ints_simd_x86_64_avx2(elems, acc) };
        }
        if std::arch::is_x86_feature_detected!("sse4.2") {
            return unsafe { min_ints_simd_x86_64(elems, acc) };
        }
    }
    #[cfg(target_arch = "aarch64")]
    {
        if std::arch::is_aarch64_feature_detected!("neon") {
            return unsafe { min_ints_simd_aarch64(elems, acc) };
        }
    }
    min_ints_scalar(elems, acc)
}

fn max_ints_scalar(elems: &[u64], acc: i64) -> Option<i64> {
    let mut max_val = acc;
    for &bits in elems {
        let obj = MoltObject::from_bits(bits);
        if let Some(val) = obj.as_int() {
            if val > max_val {
                max_val = val;
            }
        } else {
            return None;
        }
    }
    Some(max_val)
}

#[cfg(target_arch = "x86_64")]
unsafe fn max_ints_simd_x86_64(elems: &[u64], acc: i64) -> Option<i64> {
    use std::arch::x86_64::*;
    let mut i = 0usize;
    let mut vec_max = _mm_set1_epi64x(acc);
    while i + 2 <= elems.len() {
        let obj0 = MoltObject::from_bits(elems[i]);
        let obj1 = MoltObject::from_bits(elems[i + 1]);
        let v0 = obj0.as_int()?;
        let v1 = obj1.as_int()?;
        let vec = _mm_set_epi64x(v1, v0);
        let cmp = _mm_cmpgt_epi64(vec, vec_max);
        vec_max = _mm_blendv_epi8(vec_max, vec, cmp);
        i += 2;
    }
    let mut lanes = [0i64; 2];
    _mm_storeu_si128(lanes.as_mut_ptr() as *mut __m128i, vec_max);
    let mut max_val = acc.max(lanes[0]).max(lanes[1]);
    for &bits in &elems[i..] {
        let obj = MoltObject::from_bits(bits);
        let val = obj.as_int()?;
        if val > max_val {
            max_val = val;
        }
    }
    Some(max_val)
}

#[cfg(target_arch = "x86_64")]
unsafe fn max_ints_simd_x86_64_avx2(elems: &[u64], acc: i64) -> Option<i64> {
    use std::arch::x86_64::*;
    let mut i = 0usize;
    let mut vec_max = _mm256_set1_epi64x(acc);
    while i + 4 <= elems.len() {
        let obj0 = MoltObject::from_bits(elems[i]);
        let obj1 = MoltObject::from_bits(elems[i + 1]);
        let obj2 = MoltObject::from_bits(elems[i + 2]);
        let obj3 = MoltObject::from_bits(elems[i + 3]);
        let v0 = obj0.as_int()?;
        let v1 = obj1.as_int()?;
        let v2 = obj2.as_int()?;
        let v3 = obj3.as_int()?;
        let vec = _mm256_set_epi64x(v3, v2, v1, v0);
        let cmp = _mm256_cmpgt_epi64(vec, vec_max);
        vec_max = _mm256_blendv_epi8(vec_max, vec, cmp);
        i += 4;
    }
    let mut lanes = [0i64; 4];
    _mm256_storeu_si256(lanes.as_mut_ptr() as *mut __m256i, vec_max);
    let mut max_val = acc;
    for lane in lanes {
        if lane > max_val {
            max_val = lane;
        }
    }
    for &bits in &elems[i..] {
        let obj = MoltObject::from_bits(bits);
        let val = obj.as_int()?;
        if val > max_val {
            max_val = val;
        }
    }
    Some(max_val)
}

#[cfg(target_arch = "aarch64")]
unsafe fn max_ints_simd_aarch64(elems: &[u64], acc: i64) -> Option<i64> {
    unsafe {
        use std::arch::aarch64::*;
        let mut i = 0usize;
        let mut vec_max = vdupq_n_s64(acc);
        while i + 2 <= elems.len() {
            let obj0 = MoltObject::from_bits(elems[i]);
            let obj1 = MoltObject::from_bits(elems[i + 1]);
            let v0 = obj0.as_int()?;
            let v1 = obj1.as_int()?;
            let lanes = [v0, v1];
            let vec = vld1q_s64(lanes.as_ptr());
            let mask = vcgtq_s64(vec, vec_max);
            let vec_max_u = vreinterpretq_u64_s64(vec_max);
            let vec_u = vreinterpretq_u64_s64(vec);
            let blended_u = vbslq_u64(mask, vec_u, vec_max_u);
            vec_max = vreinterpretq_s64_u64(blended_u);
            i += 2;
        }
        let mut lanes = [0i64; 2];
        vst1q_s64(lanes.as_mut_ptr(), vec_max);
        let mut max_val = acc.max(lanes[0]).max(lanes[1]);
        for &bits in &elems[i..] {
            let obj = MoltObject::from_bits(bits);
            let val = obj.as_int()?;
            if val > max_val {
                max_val = val;
            }
        }
        Some(max_val)
    }
}

fn max_ints_checked(elems: &[u64], acc: i64) -> Option<i64> {
    #[cfg(target_arch = "x86_64")]
    {
        if std::arch::is_x86_feature_detected!("avx2") {
            return unsafe { max_ints_simd_x86_64_avx2(elems, acc) };
        }
        if std::arch::is_x86_feature_detected!("sse4.2") {
            return unsafe { max_ints_simd_x86_64(elems, acc) };
        }
    }
    #[cfg(target_arch = "aarch64")]
    {
        if std::arch::is_aarch64_feature_detected!("neon") {
            return unsafe { max_ints_simd_aarch64(elems, acc) };
        }
    }
    max_ints_scalar(elems, acc)
}

fn sum_ints_trusted_scalar(elems: &[u64], acc: i64) -> i64 {
    let mut sum = acc;
    for &bits in elems {
        let obj = MoltObject::from_bits(bits);
        sum += obj.as_int_unchecked();
    }
    sum
}

#[cfg(target_arch = "x86_64")]
unsafe fn sum_ints_trusted_simd_x86_64(elems: &[u64], acc: i64) -> i64 {
    use std::arch::x86_64::*;
    let mut i = 0usize;
    let mut vec_sum = _mm_setzero_si128();
    while i + 2 <= elems.len() {
        let obj0 = MoltObject::from_bits(elems[i]);
        let obj1 = MoltObject::from_bits(elems[i + 1]);
        let v0 = obj0.as_int_unchecked();
        let v1 = obj1.as_int_unchecked();
        let vec = _mm_set_epi64x(v1, v0);
        vec_sum = _mm_add_epi64(vec_sum, vec);
        i += 2;
    }
    let mut lanes = [0i64; 2];
    _mm_storeu_si128(lanes.as_mut_ptr() as *mut __m128i, vec_sum);
    let mut sum = acc + lanes[0] + lanes[1];
    for &bits in &elems[i..] {
        let obj = MoltObject::from_bits(bits);
        sum += obj.as_int_unchecked();
    }
    sum
}

#[cfg(target_arch = "x86_64")]
unsafe fn sum_ints_trusted_simd_x86_64_avx2(elems: &[u64], acc: i64) -> i64 {
    use std::arch::x86_64::*;
    let mut i = 0usize;
    let mut vec_sum = _mm256_setzero_si256();
    while i + 4 <= elems.len() {
        let obj0 = MoltObject::from_bits(elems[i]);
        let obj1 = MoltObject::from_bits(elems[i + 1]);
        let obj2 = MoltObject::from_bits(elems[i + 2]);
        let obj3 = MoltObject::from_bits(elems[i + 3]);
        let v0 = obj0.as_int_unchecked();
        let v1 = obj1.as_int_unchecked();
        let v2 = obj2.as_int_unchecked();
        let v3 = obj3.as_int_unchecked();
        let vec = _mm256_set_epi64x(v3, v2, v1, v0);
        vec_sum = _mm256_add_epi64(vec_sum, vec);
        i += 4;
    }
    let mut lanes = [0i64; 4];
    _mm256_storeu_si256(lanes.as_mut_ptr() as *mut __m256i, vec_sum);
    let mut sum = acc + lanes.iter().sum::<i64>();
    for &bits in &elems[i..] {
        let obj = MoltObject::from_bits(bits);
        sum += obj.as_int_unchecked();
    }
    sum
}

#[cfg(target_arch = "aarch64")]
unsafe fn sum_ints_trusted_simd_aarch64(elems: &[u64], acc: i64) -> i64 {
    unsafe {
        use std::arch::aarch64::*;
        let mut i = 0usize;
        let mut vec_sum = vdupq_n_s64(0);
        while i + 2 <= elems.len() {
            let obj0 = MoltObject::from_bits(elems[i]);
            let obj1 = MoltObject::from_bits(elems[i + 1]);
            let v0 = obj0.as_int_unchecked();
            let v1 = obj1.as_int_unchecked();
            let lanes = [v0, v1];
            let vec = vld1q_s64(lanes.as_ptr());
            vec_sum = vaddq_s64(vec_sum, vec);
            i += 2;
        }
        let mut lanes = [0i64; 2];
        vst1q_s64(lanes.as_mut_ptr(), vec_sum);
        let mut sum = acc + lanes[0] + lanes[1];
        for &bits in &elems[i..] {
            let obj = MoltObject::from_bits(bits);
            sum += obj.as_int_unchecked();
        }
        sum
    }
}

fn sum_ints_trusted(elems: &[u64], acc: i64) -> i64 {
    #[cfg(target_arch = "x86_64")]
    {
        if std::arch::is_x86_feature_detected!("avx2") {
            return unsafe { sum_ints_trusted_simd_x86_64_avx2(elems, acc) };
        }
        if std::arch::is_x86_feature_detected!("sse2") {
            return unsafe { sum_ints_trusted_simd_x86_64(elems, acc) };
        }
    }
    #[cfg(target_arch = "aarch64")]
    {
        if std::arch::is_aarch64_feature_detected!("neon") {
            return unsafe { sum_ints_trusted_simd_aarch64(elems, acc) };
        }
    }
    sum_ints_trusted_scalar(elems, acc)
}

fn prod_ints_trusted_scalar(elems: &[u64], acc: i64) -> i64 {
    let mut prod = acc;
    if prod == 0 {
        return 0;
    }
    for &bits in elems {
        let obj = MoltObject::from_bits(bits);
        let val = obj.as_int_unchecked();
        if val == 0 {
            return 0;
        }
        prod *= val;
    }
    prod
}

#[cfg(target_arch = "aarch64")]
unsafe fn prod_ints_trusted_simd_aarch64(elems: &[u64], acc: i64) -> i64 {
    prod_ints_trusted_scalar(elems, acc)
}

fn prod_ints_trusted(elems: &[u64], acc: i64) -> i64 {
    #[cfg(target_arch = "aarch64")]
    {
        if std::arch::is_aarch64_feature_detected!("neon") {
            return unsafe { prod_ints_trusted_simd_aarch64(elems, acc) };
        }
    }
    prod_ints_trusted_scalar(elems, acc)
}

fn min_ints_trusted_scalar(elems: &[u64], acc: i64) -> i64 {
    let mut min_val = acc;
    for &bits in elems {
        let obj = MoltObject::from_bits(bits);
        let val = obj.as_int_unchecked();
        if val < min_val {
            min_val = val;
        }
    }
    min_val
}

#[cfg(target_arch = "x86_64")]
unsafe fn min_ints_trusted_simd_x86_64(elems: &[u64], acc: i64) -> i64 {
    use std::arch::x86_64::*;
    let mut i = 0usize;
    let mut vec_min = _mm_set1_epi64x(acc);
    while i + 2 <= elems.len() {
        let obj0 = MoltObject::from_bits(elems[i]);
        let obj1 = MoltObject::from_bits(elems[i + 1]);
        let v0 = obj0.as_int_unchecked();
        let v1 = obj1.as_int_unchecked();
        let vec = _mm_set_epi64x(v1, v0);
        let cmp = _mm_cmpgt_epi64(vec_min, vec);
        vec_min = _mm_blendv_epi8(vec_min, vec, cmp);
        i += 2;
    }
    let mut lanes = [0i64; 2];
    _mm_storeu_si128(lanes.as_mut_ptr() as *mut __m128i, vec_min);
    let mut min_val = acc.min(lanes[0]).min(lanes[1]);
    for &bits in &elems[i..] {
        let obj = MoltObject::from_bits(bits);
        let val = obj.as_int_unchecked();
        if val < min_val {
            min_val = val;
        }
    }
    min_val
}

#[cfg(target_arch = "x86_64")]
unsafe fn min_ints_trusted_simd_x86_64_avx2(elems: &[u64], acc: i64) -> i64 {
    use std::arch::x86_64::*;
    let mut i = 0usize;
    let mut vec_min = _mm256_set1_epi64x(acc);
    while i + 4 <= elems.len() {
        let obj0 = MoltObject::from_bits(elems[i]);
        let obj1 = MoltObject::from_bits(elems[i + 1]);
        let obj2 = MoltObject::from_bits(elems[i + 2]);
        let obj3 = MoltObject::from_bits(elems[i + 3]);
        let v0 = obj0.as_int_unchecked();
        let v1 = obj1.as_int_unchecked();
        let v2 = obj2.as_int_unchecked();
        let v3 = obj3.as_int_unchecked();
        let vec = _mm256_set_epi64x(v3, v2, v1, v0);
        let cmp = _mm256_cmpgt_epi64(vec_min, vec);
        vec_min = _mm256_blendv_epi8(vec_min, vec, cmp);
        i += 4;
    }
    let mut lanes = [0i64; 4];
    _mm256_storeu_si256(lanes.as_mut_ptr() as *mut __m256i, vec_min);
    let mut min_val = acc;
    for lane in lanes {
        if lane < min_val {
            min_val = lane;
        }
    }
    for &bits in &elems[i..] {
        let obj = MoltObject::from_bits(bits);
        let val = obj.as_int_unchecked();
        if val < min_val {
            min_val = val;
        }
    }
    min_val
}

#[cfg(target_arch = "aarch64")]
unsafe fn min_ints_trusted_simd_aarch64(elems: &[u64], acc: i64) -> i64 {
    unsafe {
        use std::arch::aarch64::*;
        let mut i = 0usize;
        let mut vec_min = vdupq_n_s64(acc);
        while i + 2 <= elems.len() {
            let obj0 = MoltObject::from_bits(elems[i]);
            let obj1 = MoltObject::from_bits(elems[i + 1]);
            let v0 = obj0.as_int_unchecked();
            let v1 = obj1.as_int_unchecked();
            let lanes = [v0, v1];
            let vec = vld1q_s64(lanes.as_ptr());
            let mask = vcgtq_s64(vec_min, vec);
            let vec_min_u = vreinterpretq_u64_s64(vec_min);
            let vec_u = vreinterpretq_u64_s64(vec);
            let blended_u = vbslq_u64(mask, vec_u, vec_min_u);
            vec_min = vreinterpretq_s64_u64(blended_u);
            i += 2;
        }
        let mut lanes = [0i64; 2];
        vst1q_s64(lanes.as_mut_ptr(), vec_min);
        let mut min_val = acc.min(lanes[0]).min(lanes[1]);
        for &bits in &elems[i..] {
            let obj = MoltObject::from_bits(bits);
            let val = obj.as_int_unchecked();
            if val < min_val {
                min_val = val;
            }
        }
        min_val
    }
}

fn min_ints_trusted(elems: &[u64], acc: i64) -> i64 {
    #[cfg(target_arch = "x86_64")]
    {
        if std::arch::is_x86_feature_detected!("avx2") {
            return unsafe { min_ints_trusted_simd_x86_64_avx2(elems, acc) };
        }
        if std::arch::is_x86_feature_detected!("sse4.2") {
            return unsafe { min_ints_trusted_simd_x86_64(elems, acc) };
        }
    }
    #[cfg(target_arch = "aarch64")]
    {
        if std::arch::is_aarch64_feature_detected!("neon") {
            return unsafe { min_ints_trusted_simd_aarch64(elems, acc) };
        }
    }
    min_ints_trusted_scalar(elems, acc)
}

fn max_ints_trusted_scalar(elems: &[u64], acc: i64) -> i64 {
    let mut max_val = acc;
    for &bits in elems {
        let obj = MoltObject::from_bits(bits);
        let val = obj.as_int_unchecked();
        if val > max_val {
            max_val = val;
        }
    }
    max_val
}

#[cfg(target_arch = "x86_64")]
unsafe fn max_ints_trusted_simd_x86_64(elems: &[u64], acc: i64) -> i64 {
    use std::arch::x86_64::*;
    let mut i = 0usize;
    let mut vec_max = _mm_set1_epi64x(acc);
    while i + 2 <= elems.len() {
        let obj0 = MoltObject::from_bits(elems[i]);
        let obj1 = MoltObject::from_bits(elems[i + 1]);
        let v0 = obj0.as_int_unchecked();
        let v1 = obj1.as_int_unchecked();
        let vec = _mm_set_epi64x(v1, v0);
        let cmp = _mm_cmpgt_epi64(vec, vec_max);
        vec_max = _mm_blendv_epi8(vec_max, vec, cmp);
        i += 2;
    }
    let mut lanes = [0i64; 2];
    _mm_storeu_si128(lanes.as_mut_ptr() as *mut __m128i, vec_max);
    let mut max_val = acc.max(lanes[0]).max(lanes[1]);
    for &bits in &elems[i..] {
        let obj = MoltObject::from_bits(bits);
        let val = obj.as_int_unchecked();
        if val > max_val {
            max_val = val;
        }
    }
    max_val
}

#[cfg(target_arch = "x86_64")]
unsafe fn max_ints_trusted_simd_x86_64_avx2(elems: &[u64], acc: i64) -> i64 {
    use std::arch::x86_64::*;
    let mut i = 0usize;
    let mut vec_max = _mm256_set1_epi64x(acc);
    while i + 4 <= elems.len() {
        let obj0 = MoltObject::from_bits(elems[i]);
        let obj1 = MoltObject::from_bits(elems[i + 1]);
        let obj2 = MoltObject::from_bits(elems[i + 2]);
        let obj3 = MoltObject::from_bits(elems[i + 3]);
        let v0 = obj0.as_int_unchecked();
        let v1 = obj1.as_int_unchecked();
        let v2 = obj2.as_int_unchecked();
        let v3 = obj3.as_int_unchecked();
        let vec = _mm256_set_epi64x(v3, v2, v1, v0);
        let cmp = _mm256_cmpgt_epi64(vec, vec_max);
        vec_max = _mm256_blendv_epi8(vec_max, vec, cmp);
        i += 4;
    }
    let mut lanes = [0i64; 4];
    _mm256_storeu_si256(lanes.as_mut_ptr() as *mut __m256i, vec_max);
    let mut max_val = acc;
    for lane in lanes {
        if lane > max_val {
            max_val = lane;
        }
    }
    for &bits in &elems[i..] {
        let obj = MoltObject::from_bits(bits);
        let val = obj.as_int_unchecked();
        if val > max_val {
            max_val = val;
        }
    }
    max_val
}

#[cfg(target_arch = "aarch64")]
unsafe fn max_ints_trusted_simd_aarch64(elems: &[u64], acc: i64) -> i64 {
    unsafe {
        use std::arch::aarch64::*;
        let mut i = 0usize;
        let mut vec_max = vdupq_n_s64(acc);
        while i + 2 <= elems.len() {
            let obj0 = MoltObject::from_bits(elems[i]);
            let obj1 = MoltObject::from_bits(elems[i + 1]);
            let v0 = obj0.as_int_unchecked();
            let v1 = obj1.as_int_unchecked();
            let lanes = [v0, v1];
            let vec = vld1q_s64(lanes.as_ptr());
            let mask = vcgtq_s64(vec, vec_max);
            let vec_max_u = vreinterpretq_u64_s64(vec_max);
            let vec_u = vreinterpretq_u64_s64(vec);
            let blended_u = vbslq_u64(mask, vec_u, vec_max_u);
            vec_max = vreinterpretq_s64_u64(blended_u);
            i += 2;
        }
        let mut lanes = [0i64; 2];
        vst1q_s64(lanes.as_mut_ptr(), vec_max);
        let mut max_val = acc.max(lanes[0]).max(lanes[1]);
        for &bits in &elems[i..] {
            let obj = MoltObject::from_bits(bits);
            let val = obj.as_int_unchecked();
            if val > max_val {
                max_val = val;
            }
        }
        max_val
    }
}

fn max_ints_trusted(elems: &[u64], acc: i64) -> i64 {
    #[cfg(target_arch = "x86_64")]
    {
        if std::arch::is_x86_feature_detected!("avx2") {
            return unsafe { max_ints_trusted_simd_x86_64_avx2(elems, acc) };
        }
        if std::arch::is_x86_feature_detected!("sse4.2") {
            return unsafe { max_ints_trusted_simd_x86_64(elems, acc) };
        }
    }
    #[cfg(target_arch = "aarch64")]
    {
        if std::arch::is_aarch64_feature_detected!("neon") {
            return unsafe { max_ints_trusted_simd_aarch64(elems, acc) };
        }
    }
    max_ints_trusted_scalar(elems, acc)
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_sum_int(seq_bits: u64, acc_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc_obj = obj_from_bits(acc_bits);
        let acc = match acc_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        if !vec_lane_allowed(&VEC_SUM_INT_HITS, &VEC_SUM_INT_MISSES) {
            return vec_sum_i64_result(_py, acc, false);
        }
        let seq_obj = obj_from_bits(seq_bits);
        let ptr = match seq_obj.as_ptr() {
            Some(ptr) => ptr,
            None => {
                vec_lane_record(&VEC_SUM_INT_HITS, &VEC_SUM_INT_MISSES, false);
                return vec_sum_i64_result(_py, acc, false);
            }
        };
        unsafe {
            let type_id = object_type_id(ptr);
            let elems = if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                seq_vec_ref(ptr)
            } else {
                vec_lane_record(&VEC_SUM_INT_HITS, &VEC_SUM_INT_MISSES, false);
                return vec_sum_i64_result(_py, acc, false);
            };
            if let Some(sum) = sum_ints_checked(elems, acc) {
                vec_lane_record(&VEC_SUM_INT_HITS, &VEC_SUM_INT_MISSES, true);
                return vec_sum_i64_result(_py, sum, true);
            }
        }
        vec_lane_record(&VEC_SUM_INT_HITS, &VEC_SUM_INT_MISSES, false);
        vec_sum_i64_result(_py, acc, false)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_sum_int_trusted(seq_bits: u64, acc_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc_obj = obj_from_bits(acc_bits);
        let acc = match acc_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        if !vec_lane_allowed(&VEC_SUM_INT_HITS, &VEC_SUM_INT_MISSES) {
            return vec_sum_i64_result(_py, acc, false);
        }
        let seq_obj = obj_from_bits(seq_bits);
        let ptr = match seq_obj.as_ptr() {
            Some(ptr) => ptr,
            None => {
                vec_lane_record(&VEC_SUM_INT_HITS, &VEC_SUM_INT_MISSES, false);
                return vec_sum_i64_result(_py, acc, false);
            }
        };
        unsafe {
            let type_id = object_type_id(ptr);
            let elems = if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                seq_vec_ref(ptr)
            } else {
                vec_lane_record(&VEC_SUM_INT_HITS, &VEC_SUM_INT_MISSES, false);
                return vec_sum_i64_result(_py, acc, false);
            };
            let sum = sum_ints_trusted(elems, acc);
            vec_lane_record(&VEC_SUM_INT_HITS, &VEC_SUM_INT_MISSES, true);
            vec_sum_i64_result(_py, sum, true)
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_prod_int(seq_bits: u64, acc_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc_obj = obj_from_bits(acc_bits);
        let acc = match acc_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        let seq_obj = obj_from_bits(seq_bits);
        let ptr = match seq_obj.as_ptr() {
            Some(ptr) => ptr,
            None => return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false),
        };
        unsafe {
            let type_id = object_type_id(ptr);
            if type_id == TYPE_ID_INTARRAY {
                let elems = intarray_slice(ptr);
                let prod = prod_ints_unboxed(elems, acc);
                return vec_sum_result(_py, MoltObject::from_int(prod).bits(), true);
            }
            let elems = if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                seq_vec_ref(ptr)
            } else {
                return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false);
            };
            if let Some(prod) = prod_ints_checked(elems, acc) {
                return vec_sum_result(_py, MoltObject::from_int(prod).bits(), true);
            }
        }
        vec_sum_result(_py, MoltObject::from_int(acc).bits(), false)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_prod_int_trusted(seq_bits: u64, acc_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc_obj = obj_from_bits(acc_bits);
        let acc = match acc_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        let seq_obj = obj_from_bits(seq_bits);
        let ptr = match seq_obj.as_ptr() {
            Some(ptr) => ptr,
            None => return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false),
        };
        unsafe {
            let type_id = object_type_id(ptr);
            if type_id == TYPE_ID_INTARRAY {
                let elems = intarray_slice(ptr);
                let prod = prod_ints_unboxed(elems, acc);
                return vec_sum_result(_py, MoltObject::from_int(prod).bits(), true);
            }
            let elems = if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                seq_vec_ref(ptr)
            } else {
                return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false);
            };
            let prod = prod_ints_trusted(elems, acc);
            vec_sum_result(_py, MoltObject::from_int(prod).bits(), true)
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_min_int(seq_bits: u64, acc_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc_obj = obj_from_bits(acc_bits);
        let acc = match acc_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        let seq_obj = obj_from_bits(seq_bits);
        let ptr = match seq_obj.as_ptr() {
            Some(ptr) => ptr,
            None => return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false),
        };
        unsafe {
            let type_id = object_type_id(ptr);
            let elems = if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                seq_vec_ref(ptr)
            } else {
                return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false);
            };
            if let Some(val) = min_ints_checked(elems, acc) {
                return vec_sum_result(_py, MoltObject::from_int(val).bits(), true);
            }
        }
        vec_sum_result(_py, MoltObject::from_int(acc).bits(), false)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_min_int_trusted(seq_bits: u64, acc_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc_obj = obj_from_bits(acc_bits);
        let acc = match acc_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        let seq_obj = obj_from_bits(seq_bits);
        let ptr = match seq_obj.as_ptr() {
            Some(ptr) => ptr,
            None => return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false),
        };
        unsafe {
            let type_id = object_type_id(ptr);
            let elems = if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                seq_vec_ref(ptr)
            } else {
                return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false);
            };
            let val = min_ints_trusted(elems, acc);
            vec_sum_result(_py, MoltObject::from_int(val).bits(), true)
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_max_int(seq_bits: u64, acc_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc_obj = obj_from_bits(acc_bits);
        let acc = match acc_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        let seq_obj = obj_from_bits(seq_bits);
        let ptr = match seq_obj.as_ptr() {
            Some(ptr) => ptr,
            None => return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false),
        };
        unsafe {
            let type_id = object_type_id(ptr);
            let elems = if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                seq_vec_ref(ptr)
            } else {
                return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false);
            };
            if let Some(val) = max_ints_checked(elems, acc) {
                return vec_sum_result(_py, MoltObject::from_int(val).bits(), true);
            }
        }
        vec_sum_result(_py, MoltObject::from_int(acc).bits(), false)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_max_int_trusted(seq_bits: u64, acc_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc_obj = obj_from_bits(acc_bits);
        let acc = match acc_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        let seq_obj = obj_from_bits(seq_bits);
        let ptr = match seq_obj.as_ptr() {
            Some(ptr) => ptr,
            None => return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false),
        };
        unsafe {
            let type_id = object_type_id(ptr);
            let elems = if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                seq_vec_ref(ptr)
            } else {
                return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false);
            };
            let val = max_ints_trusted(elems, acc);
            vec_sum_result(_py, MoltObject::from_int(val).bits(), true)
        }
    })
}

fn sum_int_range_arith_checked(start: i64, stop: i64, step: i64, acc: i64) -> Option<i64> {
    let len = range_len_i128(start, stop, step);
    if len <= 0 {
        return Some(acc);
    }
    let n = len;
    let first = i128::from(start);
    let stride = i128::from(step);
    let last = first.checked_add(stride.checked_mul(n.checked_sub(1)?)?)?;
    let two_term_sum = first.checked_add(last)?;
    let range_sum = n.checked_mul(two_term_sum)?.checked_div(2)?;
    let total = i128::from(acc).checked_add(range_sum)?;
    i64::try_from(total).ok()
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_sum_int_range(seq_bits: u64, acc_bits: u64, start_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc_obj = obj_from_bits(acc_bits);
        let acc = match acc_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        let start_obj = obj_from_bits(start_bits);
        let start = match start_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_i64_result(_py, acc, false),
        };
        if start < 0 {
            return vec_sum_i64_result(_py, acc, false);
        }
        let seq_obj = obj_from_bits(seq_bits);
        let ptr = match seq_obj.as_ptr() {
            Some(ptr) => ptr,
            None => return vec_sum_i64_result(_py, acc, false),
        };
        unsafe {
            let type_id = object_type_id(ptr);
            let elems = if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                seq_vec_ref(ptr)
            } else {
                return vec_sum_i64_result(_py, acc, false);
            };
            let start_idx = (start as usize).min(elems.len());
            let slice = &elems[start_idx..];
            if let Some(sum) = sum_ints_checked(slice, acc) {
                return vec_sum_i64_result(_py, sum, true);
            }
        }
        vec_sum_i64_result(_py, acc, false)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_sum_int_range_trusted(
    seq_bits: u64,
    acc_bits: u64,
    start_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc_obj = obj_from_bits(acc_bits);
        let acc = match acc_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        let start_obj = obj_from_bits(start_bits);
        let start = match start_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_i64_result(_py, acc, false),
        };
        if start < 0 {
            return vec_sum_i64_result(_py, acc, false);
        }
        let seq_obj = obj_from_bits(seq_bits);
        let ptr = match seq_obj.as_ptr() {
            Some(ptr) => ptr,
            None => return vec_sum_i64_result(_py, acc, false),
        };
        unsafe {
            let type_id = object_type_id(ptr);
            let elems = if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                seq_vec_ref(ptr)
            } else {
                return vec_sum_i64_result(_py, acc, false);
            };
            let start_idx = (start as usize).min(elems.len());
            let slice = &elems[start_idx..];
            let sum = sum_ints_trusted(slice, acc);
            vec_sum_i64_result(_py, sum, true)
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_sum_int_range_iter(seq_bits: u64, acc_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc = match obj_from_bits(acc_bits).as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        let ptr = match obj_from_bits(seq_bits).as_ptr() {
            Some(ptr) => ptr,
            None => return vec_sum_i64_result(_py, acc, false),
        };
        unsafe {
            if object_type_id(ptr) != TYPE_ID_RANGE {
                return vec_sum_i64_result(_py, acc, false);
            }
            let Some((start, stop, step)) = range_components_i64(ptr) else {
                return vec_sum_i64_result(_py, acc, false);
            };
            if let Some(sum) = sum_int_range_arith_checked(start, stop, step, acc) {
                return vec_sum_i64_result(_py, sum, true);
            }
        }
        vec_sum_i64_result(_py, acc, false)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_sum_int_range_iter_trusted(seq_bits: u64, acc_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc = match obj_from_bits(acc_bits).as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        let ptr = match obj_from_bits(seq_bits).as_ptr() {
            Some(ptr) => ptr,
            None => return vec_sum_i64_result(_py, acc, false),
        };
        unsafe {
            if object_type_id(ptr) != TYPE_ID_RANGE {
                return vec_sum_i64_result(_py, acc, false);
            }
            let Some((start, stop, step)) = range_components_i64(ptr) else {
                return vec_sum_i64_result(_py, acc, false);
            };
            if let Some(sum) = sum_int_range_arith_checked(start, stop, step, acc) {
                return vec_sum_i64_result(_py, sum, true);
            }
        }
        vec_sum_i64_result(_py, acc, false)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_sum_float(seq_bits: u64, acc_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc = match number_as_f64(obj_from_bits(acc_bits)) {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        if !vec_lane_allowed(&VEC_SUM_FLOAT_HITS, &VEC_SUM_FLOAT_MISSES) {
            return vec_sum_f64_result(_py, acc, false);
        }
        let ptr = match obj_from_bits(seq_bits).as_ptr() {
            Some(ptr) => ptr,
            None => {
                vec_lane_record(&VEC_SUM_FLOAT_HITS, &VEC_SUM_FLOAT_MISSES, false);
                return vec_sum_f64_result(_py, acc, false);
            }
        };
        unsafe {
            let type_id = object_type_id(ptr);
            let elems = if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                seq_vec_ref(ptr)
            } else {
                vec_lane_record(&VEC_SUM_FLOAT_HITS, &VEC_SUM_FLOAT_MISSES, false);
                return vec_sum_f64_result(_py, acc, false);
            };
            if let Some(sum) = sum_floats_scalar(elems, acc) {
                vec_lane_record(&VEC_SUM_FLOAT_HITS, &VEC_SUM_FLOAT_MISSES, true);
                return vec_sum_f64_result(_py, sum, true);
            }
        }
        vec_lane_record(&VEC_SUM_FLOAT_HITS, &VEC_SUM_FLOAT_MISSES, false);
        vec_sum_f64_result(_py, acc, false)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_sum_float_trusted(seq_bits: u64, acc_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc = match number_as_f64(obj_from_bits(acc_bits)) {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        if !vec_lane_allowed(&VEC_SUM_FLOAT_HITS, &VEC_SUM_FLOAT_MISSES) {
            return vec_sum_f64_result(_py, acc, false);
        }
        let ptr = match obj_from_bits(seq_bits).as_ptr() {
            Some(ptr) => ptr,
            None => {
                vec_lane_record(&VEC_SUM_FLOAT_HITS, &VEC_SUM_FLOAT_MISSES, false);
                return vec_sum_f64_result(_py, acc, false);
            }
        };
        unsafe {
            let type_id = object_type_id(ptr);
            let elems = if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                seq_vec_ref(ptr)
            } else {
                vec_lane_record(&VEC_SUM_FLOAT_HITS, &VEC_SUM_FLOAT_MISSES, false);
                return vec_sum_f64_result(_py, acc, false);
            };
            if let Some(sum) = sum_floats_scalar(elems, acc) {
                vec_lane_record(&VEC_SUM_FLOAT_HITS, &VEC_SUM_FLOAT_MISSES, true);
                return vec_sum_f64_result(_py, sum, true);
            }
        }
        vec_lane_record(&VEC_SUM_FLOAT_HITS, &VEC_SUM_FLOAT_MISSES, false);
        vec_sum_f64_result(_py, acc, false)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_sum_float_range(seq_bits: u64, acc_bits: u64, start_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc = match number_as_f64(obj_from_bits(acc_bits)) {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        let start = match obj_from_bits(start_bits).as_int() {
            Some(val) => val,
            None => return vec_sum_f64_result(_py, acc, false),
        };
        if start < 0 {
            return vec_sum_f64_result(_py, acc, false);
        }
        let ptr = match obj_from_bits(seq_bits).as_ptr() {
            Some(ptr) => ptr,
            None => return vec_sum_f64_result(_py, acc, false),
        };
        unsafe {
            let type_id = object_type_id(ptr);
            let elems = if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                seq_vec_ref(ptr)
            } else {
                return vec_sum_f64_result(_py, acc, false);
            };
            let start_idx = (start as usize).min(elems.len());
            let slice = &elems[start_idx..];
            if let Some(sum) = sum_floats_scalar(slice, acc) {
                return vec_sum_f64_result(_py, sum, true);
            }
        }
        vec_sum_f64_result(_py, acc, false)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_sum_float_range_trusted(
    seq_bits: u64,
    acc_bits: u64,
    start_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc = match number_as_f64(obj_from_bits(acc_bits)) {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        let start = match obj_from_bits(start_bits).as_int() {
            Some(val) => val,
            None => return vec_sum_f64_result(_py, acc, false),
        };
        if start < 0 {
            return vec_sum_f64_result(_py, acc, false);
        }
        let ptr = match obj_from_bits(seq_bits).as_ptr() {
            Some(ptr) => ptr,
            None => return vec_sum_f64_result(_py, acc, false),
        };
        unsafe {
            let type_id = object_type_id(ptr);
            let elems = if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                seq_vec_ref(ptr)
            } else {
                return vec_sum_f64_result(_py, acc, false);
            };
            let start_idx = (start as usize).min(elems.len());
            let slice = &elems[start_idx..];
            if let Some(sum) = sum_floats_scalar(slice, acc) {
                return vec_sum_f64_result(_py, sum, true);
            }
        }
        vec_sum_f64_result(_py, acc, false)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_sum_float_range_iter(seq_bits: u64, acc_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc = match number_as_f64(obj_from_bits(acc_bits)) {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        let ptr = match obj_from_bits(seq_bits).as_ptr() {
            Some(ptr) => ptr,
            None => return vec_sum_f64_result(_py, acc, false),
        };
        unsafe {
            if object_type_id(ptr) != TYPE_ID_RANGE {
                return vec_sum_f64_result(_py, acc, false);
            }
            let Some((start, stop, step)) = range_components_i64(ptr) else {
                return vec_sum_f64_result(_py, acc, false);
            };
            if let Some(sum) = sum_float_range_arith_checked(start, stop, step, acc) {
                return vec_sum_f64_result(_py, sum, true);
            }
        }
        vec_sum_f64_result(_py, acc, false)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_sum_float_range_iter_trusted(seq_bits: u64, acc_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc = match number_as_f64(obj_from_bits(acc_bits)) {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        let ptr = match obj_from_bits(seq_bits).as_ptr() {
            Some(ptr) => ptr,
            None => return vec_sum_f64_result(_py, acc, false),
        };
        unsafe {
            if object_type_id(ptr) != TYPE_ID_RANGE {
                return vec_sum_f64_result(_py, acc, false);
            }
            let Some((start, stop, step)) = range_components_i64(ptr) else {
                return vec_sum_f64_result(_py, acc, false);
            };
            if let Some(sum) = sum_float_range_arith_checked(start, stop, step, acc) {
                return vec_sum_f64_result(_py, sum, true);
            }
        }
        vec_sum_f64_result(_py, acc, false)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_prod_int_range(seq_bits: u64, acc_bits: u64, start_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc_obj = obj_from_bits(acc_bits);
        let acc = match acc_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        let start_obj = obj_from_bits(start_bits);
        let start = match start_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false),
        };
        if start < 0 {
            return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false);
        }
        let seq_obj = obj_from_bits(seq_bits);
        let ptr = match seq_obj.as_ptr() {
            Some(ptr) => ptr,
            None => return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false),
        };
        unsafe {
            let type_id = object_type_id(ptr);
            if type_id == TYPE_ID_INTARRAY {
                let elems = intarray_slice(ptr);
                let start_idx = (start as usize).min(elems.len());
                let slice = &elems[start_idx..];
                let prod = prod_ints_unboxed(slice, acc);
                return vec_sum_result(_py, MoltObject::from_int(prod).bits(), true);
            }
            let elems = if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                seq_vec_ref(ptr)
            } else {
                return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false);
            };
            let start_idx = (start as usize).min(elems.len());
            let slice = &elems[start_idx..];
            if let Some(prod) = prod_ints_checked(slice, acc) {
                return vec_sum_result(_py, MoltObject::from_int(prod).bits(), true);
            }
        }
        vec_sum_result(_py, MoltObject::from_int(acc).bits(), false)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_prod_int_range_trusted(
    seq_bits: u64,
    acc_bits: u64,
    start_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc_obj = obj_from_bits(acc_bits);
        let acc = match acc_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        let start_obj = obj_from_bits(start_bits);
        let start = match start_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false),
        };
        if start < 0 {
            return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false);
        }
        let seq_obj = obj_from_bits(seq_bits);
        let ptr = match seq_obj.as_ptr() {
            Some(ptr) => ptr,
            None => return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false),
        };
        unsafe {
            let type_id = object_type_id(ptr);
            if type_id == TYPE_ID_INTARRAY {
                let elems = intarray_slice(ptr);
                let start_idx = (start as usize).min(elems.len());
                let slice = &elems[start_idx..];
                let prod = prod_ints_unboxed(slice, acc);
                return vec_sum_result(_py, MoltObject::from_int(prod).bits(), true);
            }
            let elems = if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                seq_vec_ref(ptr)
            } else {
                return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false);
            };
            let start_idx = (start as usize).min(elems.len());
            let slice = &elems[start_idx..];
            let prod = prod_ints_trusted(slice, acc);
            vec_sum_result(_py, MoltObject::from_int(prod).bits(), true)
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_min_int_range(seq_bits: u64, acc_bits: u64, start_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc_obj = obj_from_bits(acc_bits);
        let acc = match acc_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        let start_obj = obj_from_bits(start_bits);
        let start = match start_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false),
        };
        if start < 0 {
            return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false);
        }
        let seq_obj = obj_from_bits(seq_bits);
        let ptr = match seq_obj.as_ptr() {
            Some(ptr) => ptr,
            None => return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false),
        };
        unsafe {
            let type_id = object_type_id(ptr);
            let elems = if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                seq_vec_ref(ptr)
            } else {
                return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false);
            };
            let start_idx = (start as usize).min(elems.len());
            let slice = &elems[start_idx..];
            if let Some(val) = min_ints_checked(slice, acc) {
                return vec_sum_result(_py, MoltObject::from_int(val).bits(), true);
            }
        }
        vec_sum_result(_py, MoltObject::from_int(acc).bits(), false)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_min_int_range_trusted(
    seq_bits: u64,
    acc_bits: u64,
    start_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc_obj = obj_from_bits(acc_bits);
        let acc = match acc_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        let start_obj = obj_from_bits(start_bits);
        let start = match start_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false),
        };
        if start < 0 {
            return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false);
        }
        let seq_obj = obj_from_bits(seq_bits);
        let ptr = match seq_obj.as_ptr() {
            Some(ptr) => ptr,
            None => return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false),
        };
        unsafe {
            let type_id = object_type_id(ptr);
            let elems = if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                seq_vec_ref(ptr)
            } else {
                return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false);
            };
            let start_idx = (start as usize).min(elems.len());
            let slice = &elems[start_idx..];
            let val = min_ints_trusted(slice, acc);
            vec_sum_result(_py, MoltObject::from_int(val).bits(), true)
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_max_int_range(seq_bits: u64, acc_bits: u64, start_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc_obj = obj_from_bits(acc_bits);
        let acc = match acc_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        let start_obj = obj_from_bits(start_bits);
        let start = match start_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false),
        };
        if start < 0 {
            return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false);
        }
        let seq_obj = obj_from_bits(seq_bits);
        let ptr = match seq_obj.as_ptr() {
            Some(ptr) => ptr,
            None => return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false),
        };
        unsafe {
            let type_id = object_type_id(ptr);
            let elems = if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                seq_vec_ref(ptr)
            } else {
                return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false);
            };
            let start_idx = (start as usize).min(elems.len());
            let slice = &elems[start_idx..];
            if let Some(val) = max_ints_checked(slice, acc) {
                return vec_sum_result(_py, MoltObject::from_int(val).bits(), true);
            }
        }
        vec_sum_result(_py, MoltObject::from_int(acc).bits(), false)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vec_max_int_range_trusted(
    seq_bits: u64,
    acc_bits: u64,
    start_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let acc_obj = obj_from_bits(acc_bits);
        let acc = match acc_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::none().bits(), false),
        };
        let start_obj = obj_from_bits(start_bits);
        let start = match start_obj.as_int() {
            Some(val) => val,
            None => return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false),
        };
        if start < 0 {
            return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false);
        }
        let seq_obj = obj_from_bits(seq_bits);
        let ptr = match seq_obj.as_ptr() {
            Some(ptr) => ptr,
            None => return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false),
        };
        unsafe {
            let type_id = object_type_id(ptr);
            let elems = if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                seq_vec_ref(ptr)
            } else {
                return vec_sum_result(_py, MoltObject::from_int(acc).bits(), false);
            };
            let start_idx = (start as usize).min(elems.len());
            let slice = &elems[start_idx..];
            let val = max_ints_trusted(slice, acc);
            vec_sum_result(_py, MoltObject::from_int(val).bits(), true)
        }
    })
}

enum SliceError {
    Type,
    Value,
}

fn slice_error(_py: &PyToken<'_>, err: SliceError) -> u64 {
    if exception_pending(_py) {
        return MoltObject::none().bits();
    }
    match err {
        SliceError::Type => raise_exception::<_>(
            _py,
            "TypeError",
            "slice indices must be integers or None or have an __index__ method",
        ),
        SliceError::Value => raise_exception::<_>(_py, "ValueError", "slice step cannot be zero"),
    }
}

fn decode_slice_bound(
    _py: &PyToken<'_>,
    obj: MoltObject,
    len: isize,
    default: isize,
) -> Result<isize, SliceError> {
    if obj.is_none() {
        return Ok(default);
    }
    let msg = "slice indices must be integers or None or have an __index__ method";
    let Some(mut idx) = index_bigint_from_obj(_py, obj.bits(), msg) else {
        return Err(SliceError::Type);
    };
    let len_big = BigInt::from(len);
    if idx.is_negative() {
        idx += &len_big;
    }
    if idx < BigInt::zero() {
        return Ok(0);
    }
    if idx > len_big {
        return Ok(len);
    }
    Ok(idx.to_isize().unwrap_or(len))
}

fn decode_slice_bound_neg(
    _py: &PyToken<'_>,
    obj: MoltObject,
    len: isize,
    default: isize,
) -> Result<isize, SliceError> {
    if obj.is_none() {
        return Ok(default);
    }
    let msg = "slice indices must be integers or None or have an __index__ method";
    let Some(mut idx) = index_bigint_from_obj(_py, obj.bits(), msg) else {
        return Err(SliceError::Type);
    };
    let len_big = BigInt::from(len);
    if idx.is_negative() {
        idx += &len_big;
    }
    let neg_one = BigInt::from(-1);
    if idx < neg_one {
        return Ok(-1);
    }
    if idx >= len_big {
        return Ok(len - 1);
    }
    Ok(idx.to_isize().unwrap_or(len - 1))
}

fn decode_slice_step(_py: &PyToken<'_>, obj: MoltObject) -> Result<isize, SliceError> {
    if obj.is_none() {
        return Ok(1);
    }
    let msg = "slice indices must be integers or None or have an __index__ method";
    let Some(step) = index_bigint_from_obj(_py, obj.bits(), msg) else {
        return Err(SliceError::Type);
    };
    if step.is_zero() {
        return Err(SliceError::Value);
    }
    if let Some(step) = step.to_i64() {
        return Ok(step as isize);
    }
    if step.is_negative() {
        return Ok(-(i64::MAX as isize));
    }
    Ok(i64::MAX as isize)
}

fn normalize_slice_indices(
    _py: &PyToken<'_>,
    len: isize,
    start_obj: MoltObject,
    stop_obj: MoltObject,
    step_obj: MoltObject,
) -> Result<(isize, isize, isize), SliceError> {
    let step = decode_slice_step(_py, step_obj)?;
    if step > 0 {
        let start = decode_slice_bound(_py, start_obj, len, 0)?;
        let stop = decode_slice_bound(_py, stop_obj, len, len)?;
        return Ok((start, stop, step));
    }
    let start_default = if len == 0 { -1 } else { len - 1 };
    let stop_default = -1;
    let start = decode_slice_bound_neg(_py, start_obj, len, start_default)?;
    let stop = decode_slice_bound_neg(_py, stop_obj, len, stop_default)?;
    Ok((start, stop, step))
}

fn collect_slice_indices(start: isize, stop: isize, step: isize) -> Vec<usize> {
    let mut out = Vec::new();
    if step > 0 {
        let mut i = start;
        while i < stop {
            out.push(i as usize);
            let Some(next) = i.checked_add(step) else {
                break;
            };
            i = next;
        }
    } else {
        let mut i = start;
        while i > stop {
            out.push(i as usize);
            let Some(next) = i.checked_add(step) else {
                break;
            };
            i = next;
        }
    }
    out
}

fn collect_iterable_values(_py: &PyToken<'_>, bits: u64, err_msg: &str) -> Option<Vec<u64>> {
    let iter_bits = molt_iter(bits);
    if obj_from_bits(iter_bits).is_none() {
        if exception_pending(_py) {
            return None;
        }
        return raise_exception::<_>(_py, "TypeError", err_msg);
    }
    let mut out = Vec::new();
    loop {
        let pair_bits = molt_iter_next(iter_bits);
        if exception_pending(_py) {
            return None;
        }
        let pair_ptr = obj_from_bits(pair_bits).as_ptr()?;
        unsafe {
            if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                return None;
            }
            let elems = seq_vec_ref(pair_ptr);
            if elems.len() < 2 {
                return None;
            }
            let done_bits = elems[1];
            if is_truthy(_py, obj_from_bits(done_bits)) {
                break;
            }
            out.push(elems[0]);
        }
    }
    Some(out)
}

fn collect_bytearray_assign_bytes(_py: &PyToken<'_>, bits: u64) -> Option<Vec<u8>> {
    let obj = obj_from_bits(bits);
    if let Some(ptr) = obj.as_ptr() {
        unsafe {
            let type_id = object_type_id(ptr);
            if type_id == TYPE_ID_BYTES || type_id == TYPE_ID_BYTEARRAY {
                return Some(bytes_like_slice_raw(ptr).unwrap_or(&[]).to_vec());
            }
            if type_id == TYPE_ID_STRING {
                return raise_exception::<_>(
                    _py,
                    "TypeError",
                    "can assign only bytes, buffers, or iterables of ints in range(0, 256)",
                );
            }
            if type_id == TYPE_ID_MEMORYVIEW {
                if let Some(slice) = memoryview_bytes_slice(ptr) {
                    return Some(slice.to_vec());
                }
                return memoryview_collect_bytes(ptr);
            }
        }
    }
    let iter_bits = molt_iter(bits);
    if obj_from_bits(iter_bits).is_none() {
        if exception_pending(_py) {
            return None;
        }
        return raise_exception::<_>(
            _py,
            "TypeError",
            "can assign only bytes, buffers, or iterables of ints in range(0, 256)",
        );
    }
    bytes_collect_from_iter(_py, iter_bits, BytesCtorKind::Bytearray)
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_extend(bytearray_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let bytearray_obj = obj_from_bits(bytearray_bits);
        let Some(bytearray_ptr) = bytearray_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "bytearray.extend expects bytearray");
        };
        unsafe {
            if object_type_id(bytearray_ptr) != TYPE_ID_BYTEARRAY {
                return raise_exception::<_>(
                    _py,
                    "TypeError",
                    "bytearray.extend expects bytearray",
                );
            }
        }
        let Some(payload) = collect_bytearray_assign_bytes(_py, other_bits) else {
            return MoltObject::none().bits();
        };
        unsafe {
            bytearray_vec(bytearray_ptr).extend_from_slice(&payload);
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_append(bytearray_bits: u64, val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let bytearray_obj = obj_from_bits(bytearray_bits);
        let Some(bytearray_ptr) = bytearray_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "bytearray.append expects bytearray");
        };
        unsafe {
            if object_type_id(bytearray_ptr) != TYPE_ID_BYTEARRAY {
                return raise_exception::<_>(
                    _py,
                    "TypeError",
                    "bytearray.append expects bytearray",
                );
            }
        }
        let Some(byte) = bytes_item_to_u8(_py, val_bits, BytesCtorKind::Bytearray) else {
            return MoltObject::none().bits();
        };
        unsafe {
            bytearray_vec(bytearray_ptr).push(byte);
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_clear(bytearray_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let bytearray_obj = obj_from_bits(bytearray_bits);
        let Some(bytearray_ptr) = bytearray_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "bytearray.clear expects bytearray");
        };
        unsafe {
            if object_type_id(bytearray_ptr) != TYPE_ID_BYTEARRAY {
                return raise_exception::<_>(_py, "TypeError", "bytearray.clear expects bytearray");
            }
            bytearray_vec(bytearray_ptr).clear();
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_len(val: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(val);
        if let Some(ptr) = obj.as_ptr() {
            unsafe {
                let type_id = object_type_id(ptr);
                if type_id == TYPE_ID_STRING {
                    let bytes = std::slice::from_raw_parts(string_bytes(ptr), string_len(ptr));
                    let count = utf8_codepoint_count_cached(_py, bytes, Some(ptr as usize));
                    return MoltObject::from_int(count).bits();
                }
                if type_id == TYPE_ID_BYTES {
                    return MoltObject::from_int(bytes_len(ptr) as i64).bits();
                }
                if type_id == TYPE_ID_BYTEARRAY {
                    return MoltObject::from_int(bytes_len(ptr) as i64).bits();
                }
                if type_id == TYPE_ID_MEMORYVIEW {
                    if memoryview_ndim(ptr) == 0 {
                        return raise_exception::<_>(
                            _py,
                            "TypeError",
                            "0-dim memory has no length",
                        );
                    }
                    return MoltObject::from_int(memoryview_len(ptr) as i64).bits();
                }
                if type_id == TYPE_ID_LIST {
                    return MoltObject::from_int(list_len(ptr) as i64).bits();
                }
                if type_id == TYPE_ID_TUPLE {
                    return MoltObject::from_int(tuple_len(ptr) as i64).bits();
                }
                if type_id == TYPE_ID_INTARRAY {
                    return MoltObject::from_int(intarray_len(ptr) as i64).bits();
                }
                if let Some(dict_bits) = dict_like_bits_from_ptr(_py, ptr) {
                    let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() else {
                        return MoltObject::none().bits();
                    };
                    return MoltObject::from_int(dict_len(dict_ptr) as i64).bits();
                }
                if type_id == TYPE_ID_SET {
                    return MoltObject::from_int(set_len(ptr) as i64).bits();
                }
                if type_id == TYPE_ID_FROZENSET {
                    return MoltObject::from_int(set_len(ptr) as i64).bits();
                }
                if type_id == TYPE_ID_DICT_KEYS_VIEW
                    || type_id == TYPE_ID_DICT_VALUES_VIEW
                    || type_id == TYPE_ID_DICT_ITEMS_VIEW
                {
                    return MoltObject::from_int(dict_view_len(ptr) as i64).bits();
                }
                if type_id == TYPE_ID_RANGE {
                    let Some((start, stop, step)) = range_components_bigint(ptr) else {
                        return MoltObject::none().bits();
                    };
                    let len = range_len_bigint(&start, &stop, &step);
                    return int_bits_from_bigint(_py, len);
                }
                if let Some(name_bits) = attr_name_bits_from_bytes(_py, b"__len__") {
                    let call_bits = attr_lookup_ptr(_py, ptr, name_bits);
                    dec_ref_bits(_py, name_bits);
                    if let Some(call_bits) = call_bits {
                        let res_bits = call_callable0(_py, call_bits);
                        dec_ref_bits(_py, call_bits);
                        if exception_pending(_py) {
                            return MoltObject::none().bits();
                        }
                        let res_obj = obj_from_bits(res_bits);
                        if let Some(i) = to_i64(res_obj) {
                            if i < 0 {
                                return raise_exception::<_>(
                                    _py,
                                    "ValueError",
                                    "__len__() should return >= 0",
                                );
                            }
                            return MoltObject::from_int(i).bits();
                        }
                        if let Some(big_ptr) = bigint_ptr_from_bits(res_bits) {
                            let big = bigint_ref(big_ptr);
                            if big.is_negative() {
                                return raise_exception::<_>(
                                    _py,
                                    "ValueError",
                                    "__len__() should return >= 0",
                                );
                            }
                            let Some(len) = big.to_usize() else {
                                return raise_exception::<_>(
                                    _py,
                                    "OverflowError",
                                    "cannot fit 'int' into an index-sized integer",
                                );
                            };
                            if len > i64::MAX as usize {
                                return raise_exception::<_>(
                                    _py,
                                    "OverflowError",
                                    "cannot fit 'int' into an index-sized integer",
                                );
                            }
                            return MoltObject::from_int(len as i64).bits();
                        }
                        let res_type = class_name_for_error(type_of_bits(_py, res_bits));
                        let msg =
                            format!("'{}' object cannot be interpreted as an integer", res_type);
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                }
            }
        }
        let type_name = class_name_for_error(type_of_bits(_py, val));
        let msg = format!("object of type '{type_name}' has no len()");
        raise_exception::<_>(_py, "TypeError", &msg)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_hash_builtin(val: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hash = hash_bits_signed(_py, val);
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        int_bits_from_i64(_py, hash)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_id(val: u64) -> u64 {
    crate::with_gil_entry!(_py, { int_bits_from_i64(_py, val as i64) })
}

fn ord_length_error(_py: &PyToken<'_>, len: usize) -> u64 {
    let msg = format!("ord() expected a character, but string of length {len} found");
    raise_exception::<_>(_py, "TypeError", &msg)
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_ord(val: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(val);
        if let Some(ptr) = obj.as_ptr() {
            unsafe {
                let type_id = object_type_id(ptr);
                if type_id == TYPE_ID_STRING {
                    let bytes = std::slice::from_raw_parts(string_bytes(ptr), string_len(ptr));
                    let char_count = utf8_codepoint_count_cached(_py, bytes, Some(ptr as usize));
                    if char_count != 1 {
                        return ord_length_error(_py, char_count as usize);
                    }
                    let Some(code) = wtf8_codepoint_at(bytes, 0) else {
                        return MoltObject::none().bits();
                    };
                    return MoltObject::from_int(code.to_u32() as i64).bits();
                }
                if type_id == TYPE_ID_BYTES || type_id == TYPE_ID_BYTEARRAY {
                    let len = bytes_len(ptr);
                    if len != 1 {
                        return ord_length_error(_py, len);
                    }
                    let bytes = std::slice::from_raw_parts(bytes_data(ptr), len);
                    return MoltObject::from_int(bytes[0] as i64).bits();
                }
            }
        }
        let type_name = class_name_for_error(type_of_bits(_py, val));
        let msg = format!("ord() expected string of length 1, but {type_name} found");
        raise_exception::<_>(_py, "TypeError", &msg)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_chr(val: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let type_name = class_name_for_error(type_of_bits(_py, val));
        let msg = format!("'{type_name}' object cannot be interpreted as an integer");
        let Some(value) = index_bigint_from_obj(_py, val, &msg) else {
            return MoltObject::none().bits();
        };
        if value.is_negative() || value > BigInt::from(0x10FFFF) {
            return raise_exception::<_>(_py, "ValueError", "chr() arg not in range(0x110000)");
        }
        let Some(code) = value.to_u32() else {
            return raise_exception::<_>(_py, "ValueError", "chr() arg not in range(0x110000)");
        };
        let mut out_bytes = Vec::with_capacity(4);
        push_wtf8_codepoint(&mut out_bytes, code);
        let out = alloc_string(_py, &out_bytes);
        if out.is_null() {
            return MoltObject::none().bits();
        }
        MoltObject::from_ptr(out).bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_missing() -> u64 {
    crate::with_gil_entry!(_py, {
        let bits = missing_bits(_py);
        inc_ref_bits(_py, bits);
        bits
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_not_implemented() -> u64 {
    crate::with_gil_entry!(_py, { not_implemented_bits(_py) })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_ellipsis() -> u64 {
    crate::with_gil_entry!(_py, { ellipsis_bits(_py) })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_pending() -> u64 {
    crate::with_gil_entry!(_py, { MoltObject::pending().bits() })
}

#[derive(Clone, Copy)]
struct GcState {
    enabled: bool,
    thresholds: (i64, i64, i64),
    debug_flags: i64,
    count: (i64, i64, i64),
}

fn gc_state() -> &'static Mutex<GcState> {
    static GC_STATE: OnceLock<Mutex<GcState>> = OnceLock::new();
    GC_STATE.get_or_init(|| {
        Mutex::new(GcState {
            enabled: true,
            thresholds: (0, 0, 0),
            debug_flags: 0,
            count: (0, 0, 0),
        })
    })
}

fn gc_int_arg(_py: &PyToken<'_>, bits: u64, label: &str) -> Result<i64, u64> {
    if let Some(value) = to_i64(obj_from_bits(bits)) {
        return Ok(value);
    }
    if let Some(big_ptr) = bigint_ptr_from_bits(bits) {
        let big = unsafe { bigint_ref(big_ptr) };
        let Some(value) = big.to_i64() else {
            let msg = format!("{label} value out of range");
            return Err(raise_exception::<_>(_py, "OverflowError", &msg));
        };
        return Ok(value);
    }
    let type_name = class_name_for_error(type_of_bits(_py, bits));
    let msg = format!("'{type_name}' object cannot be interpreted as an integer");
    Err(raise_exception::<_>(_py, "TypeError", &msg))
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_gc_collect(generation_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let generation = match gc_int_arg(_py, generation_bits, "generation") {
            Ok(value) => value,
            Err(bits) => return bits,
        };
        if generation < 0 {
            return raise_exception::<_>(_py, "ValueError", "generation must be non-negative");
        }
        let collected = crate::object::weakref::weakref_collect_for_gc(_py) as i64;
        let mut state = gc_state().lock().unwrap();
        state.count = (0, 0, 0);
        MoltObject::from_int(collected).bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_gc_enable() -> u64 {
    crate::with_gil_entry!(_py, {
        let mut state = gc_state().lock().unwrap();
        state.enabled = true;
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_gc_disable() -> u64 {
    crate::with_gil_entry!(_py, {
        let mut state = gc_state().lock().unwrap();
        state.enabled = false;
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_gc_isenabled() -> u64 {
    crate::with_gil_entry!(_py, {
        let state = gc_state().lock().unwrap();
        MoltObject::from_bool(state.enabled).bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_gc_set_threshold(th0_bits: u64, th1_bits: u64, th2_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let th0 = match gc_int_arg(_py, th0_bits, "threshold0") {
            Ok(value) => value,
            Err(bits) => return bits,
        };
        let th1 = match gc_int_arg(_py, th1_bits, "threshold1") {
            Ok(value) => value,
            Err(bits) => return bits,
        };
        let th2 = match gc_int_arg(_py, th2_bits, "threshold2") {
            Ok(value) => value,
            Err(bits) => return bits,
        };
        let mut state = gc_state().lock().unwrap();
        state.thresholds = (th0, th1, th2);
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_gc_get_threshold() -> u64 {
    crate::with_gil_entry!(_py, {
        let state = gc_state().lock().unwrap();
        let (th0, th1, th2) = state.thresholds;
        let th0_bits = MoltObject::from_int(th0).bits();
        let th1_bits = MoltObject::from_int(th1).bits();
        let th2_bits = MoltObject::from_int(th2).bits();
        let tuple_ptr = alloc_tuple(_py, &[th0_bits, th1_bits, th2_bits]);
        dec_ref_bits(_py, th0_bits);
        dec_ref_bits(_py, th1_bits);
        dec_ref_bits(_py, th2_bits);
        if tuple_ptr.is_null() {
            MoltObject::none().bits()
        } else {
            MoltObject::from_ptr(tuple_ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_gc_set_debug(flags_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let flags = match gc_int_arg(_py, flags_bits, "flags") {
            Ok(value) => value,
            Err(bits) => return bits,
        };
        let mut state = gc_state().lock().unwrap();
        state.debug_flags = flags;
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_gc_get_debug() -> u64 {
    crate::with_gil_entry!(_py, {
        let state = gc_state().lock().unwrap();
        MoltObject::from_int(state.debug_flags).bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_gc_get_count() -> u64 {
    crate::with_gil_entry!(_py, {
        let state = gc_state().lock().unwrap();
        let (c0, c1, c2) = state.count;
        let c0_bits = MoltObject::from_int(c0).bits();
        let c1_bits = MoltObject::from_int(c1).bits();
        let c2_bits = MoltObject::from_int(c2).bits();
        let tuple_ptr = alloc_tuple(_py, &[c0_bits, c1_bits, c2_bits]);
        dec_ref_bits(_py, c0_bits);
        dec_ref_bits(_py, c1_bits);
        dec_ref_bits(_py, c2_bits);
        if tuple_ptr.is_null() {
            MoltObject::none().bits()
        } else {
            MoltObject::from_ptr(tuple_ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_getrecursionlimit() -> u64 {
    crate::with_gil_entry!(_py, {
        MoltObject::from_int(recursion_limit_get() as i64).bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_setrecursionlimit(limit_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(limit_bits);
        let limit = if let Some(value) = to_i64(obj) {
            if value < 1 {
                return raise_exception::<_>(
                    _py,
                    "ValueError",
                    "recursion limit must be greater or equal than 1",
                );
            }
            value as usize
        } else if let Some(big_ptr) = bigint_ptr_from_bits(limit_bits) {
            let big = unsafe { bigint_ref(big_ptr) };
            if big.is_negative() {
                return raise_exception::<_>(
                    _py,
                    "ValueError",
                    "recursion limit must be greater or equal than 1",
                );
            }
            let Some(value) = big.to_usize() else {
                return raise_exception::<_>(
                    _py,
                    "OverflowError",
                    "cannot fit 'int' into an index-sized integer",
                );
            };
            value
        } else {
            let type_name = class_name_for_error(type_of_bits(_py, limit_bits));
            let msg = format!("'{type_name}' object cannot be interpreted as an integer");
            return raise_exception::<_>(_py, "TypeError", &msg);
        };
        let depth = RECURSION_DEPTH.with(|depth| depth.get());
        if limit <= depth {
            let msg = format!(
                "cannot set the recursion limit to {limit} at the recursion depth {depth}: the limit is too low"
            );
            return raise_exception::<_>(_py, "RecursionError", &msg);
        }
        recursion_limit_set(limit);
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_getargv() -> u64 {
    crate::with_gil_entry!(_py, {
        let args = runtime_state(_py).argv.lock().unwrap();
        let mut elems = Vec::with_capacity(args.len());
        for arg in args.iter() {
            let ptr = alloc_string(_py, arg);
            if ptr.is_null() {
                for bits in elems {
                    dec_ref_bits(_py, bits);
                }
                return MoltObject::none().bits();
            }
            elems.push(MoltObject::from_ptr(ptr).bits());
        }
        let list_ptr = alloc_list(_py, &elems);
        if list_ptr.is_null() {
            for bits in elems {
                dec_ref_bits(_py, bits);
            }
            return MoltObject::none().bits();
        }
        for bits in elems {
            dec_ref_bits(_py, bits);
        }
        MoltObject::from_ptr(list_ptr).bits()
    })
}

fn trace_sys_version() -> bool {
    static TRACE: OnceLock<bool> = OnceLock::new();
    *TRACE.get_or_init(|| std::env::var("MOLT_TRACE_SYS_VERSION").as_deref() == Ok("1"))
}

fn env_sys_version_info() -> Option<PythonVersionInfo> {
    let raw = std::env::var("MOLT_SYS_VERSION_INFO").ok()?;
    if trace_sys_version() {
        eprintln!("molt sys version: env raw={raw}");
    }
    let mut parts = raw.split(',');
    let major = parts.next()?.trim().parse::<i64>().ok()?;
    let minor = parts.next()?.trim().parse::<i64>().ok()?;
    let micro = parts.next()?.trim().parse::<i64>().ok()?;
    let releaselevel = parts.next()?.trim().to_string();
    let serial = parts.next()?.trim().parse::<i64>().ok()?;
    if major < 0 || minor < 0 || micro < 0 || serial < 0 {
        return None;
    }
    if releaselevel.is_empty() {
        return None;
    }
    let info = PythonVersionInfo {
        major,
        minor,
        micro,
        releaselevel,
        serial,
    };
    if trace_sys_version() {
        eprintln!(
            "molt sys version: parsed {}.{}.{} {} {}",
            info.major, info.minor, info.micro, info.releaselevel, info.serial
        );
    }
    Some(info)
}

fn default_sys_version_info() -> PythonVersionInfo {
    env_sys_version_info().unwrap_or_else(|| PythonVersionInfo {
        major: 3,
        minor: 12,
        micro: 0,
        releaselevel: "final".to_string(),
        serial: 0,
    })
}

fn format_sys_version(info: &PythonVersionInfo) -> String {
    let base = format!("{}.{}.{}", info.major, info.minor, info.micro);
    let suffix = match info.releaselevel.as_str() {
        "alpha" => format!("a{}", info.serial),
        "beta" => format!("b{}", info.serial),
        "candidate" => format!("rc{}", info.serial),
        "final" => String::new(),
        other => format!("{other}{}", info.serial),
    };
    if suffix.is_empty() {
        format!("{base} (molt)")
    } else {
        format!("{base}{suffix} (molt)")
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_sys_set_version_info(
    major_bits: u64,
    minor_bits: u64,
    micro_bits: u64,
    releaselevel_bits: u64,
    serial_bits: u64,
    version_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let major = index_i64_from_obj(_py, major_bits, "major must be int");
        let minor = index_i64_from_obj(_py, minor_bits, "minor must be int");
        let micro = index_i64_from_obj(_py, micro_bits, "micro must be int");
        let serial = index_i64_from_obj(_py, serial_bits, "serial must be int");
        if major < 0 || minor < 0 || micro < 0 || serial < 0 {
            return raise_exception::<_>(
                _py,
                "ValueError",
                "sys.version_info must be non-negative integers",
            );
        }

        let Some(release_ptr) = obj_from_bits(releaselevel_bits).as_ptr() else {
            return raise_exception::<_>(
                _py,
                "TypeError",
                "sys.version_info releaselevel must be str",
            );
        };
        unsafe {
            if object_type_id(release_ptr) != TYPE_ID_STRING {
                return raise_exception::<_>(
                    _py,
                    "TypeError",
                    "sys.version_info releaselevel must be str",
                );
            }
        }
        let release_bytes = unsafe {
            std::slice::from_raw_parts(string_bytes(release_ptr), string_len(release_ptr))
        };
        let releaselevel = String::from_utf8_lossy(release_bytes).into_owned();

        let Some(version_ptr) = obj_from_bits(version_bits).as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "sys.version must be str");
        };
        unsafe {
            if object_type_id(version_ptr) != TYPE_ID_STRING {
                return raise_exception::<_>(_py, "TypeError", "sys.version must be str");
            }
        }
        let version_bytes = unsafe {
            std::slice::from_raw_parts(string_bytes(version_ptr), string_len(version_ptr))
        };
        let mut version = String::from_utf8_lossy(version_bytes).into_owned();

        let info = PythonVersionInfo {
            major,
            minor,
            micro,
            releaselevel,
            serial,
        };
        if version.is_empty() {
            version = format_sys_version(&info);
        }
        if trace_sys_version() {
            eprintln!(
                "molt sys version: set called {}.{}.{} {} {}",
                info.major, info.minor, info.micro, info.releaselevel, info.serial
            );
        }

        let state = runtime_state(_py);
        let default_info = default_sys_version_info();
        {
            let mut guard = state.sys_version_info.lock().unwrap();
            if let Some(existing) = guard.as_ref() {
                if existing != &info && existing != &default_info {
                    return raise_exception::<_>(
                        _py,
                        "RuntimeError",
                        "sys.version_info already set",
                    );
                }
            }
            *guard = Some(info.clone());
        }
        {
            let mut guard = state.sys_version.lock().unwrap();
            if let Some(existing) = guard.as_ref() {
                if existing != &version {
                    return raise_exception::<_>(_py, "RuntimeError", "sys.version already set");
                }
            }
            *guard = Some(version.clone());
        }
        // If the sys module already exists, keep its version metadata in sync.
        let sys_bits = {
            let cache = crate::builtins::exceptions::internals::module_cache(_py);
            cache.lock().unwrap().get("sys").copied()
        };
        if trace_sys_version() {
            eprintln!("molt sys version: sys module cached={}", sys_bits.is_some());
        }
        if let Some(bits) = sys_bits {
            if let Some(sys_ptr) = obj_from_bits(bits).as_ptr() {
                unsafe {
                    let dict_bits = module_dict_bits(sys_ptr);
                    if let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() {
                        let version_info_bits = molt_sys_version_info();
                        let version_bits = molt_sys_version();
                        let version_info_key = intern_static_name(
                            _py,
                            &runtime_state(_py).interned.sys_version_info,
                            b"version_info",
                        );
                        let version_key = intern_static_name(
                            _py,
                            &runtime_state(_py).interned.sys_version,
                            b"version",
                        );
                        dict_set_in_place(_py, dict_ptr, version_info_key, version_info_bits);
                        dict_set_in_place(_py, dict_ptr, version_key, version_bits);
                        dec_ref_bits(_py, version_info_key);
                        dec_ref_bits(_py, version_key);
                        dec_ref_bits(_py, version_info_bits);
                        dec_ref_bits(_py, version_bits);
                        if trace_sys_version() {
                            eprintln!("molt sys version: sys dict updated");
                        }
                    }
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_sys_version_info() -> u64 {
    crate::with_gil_entry!(_py, {
        let state = runtime_state(_py);
        let (info, initialized) = {
            let mut guard = state.sys_version_info.lock().unwrap();
            if let Some(existing) = guard.as_ref() {
                (existing.clone(), false)
            } else {
                let init = default_sys_version_info();
                *guard = Some(init.clone());
                (init, true)
            }
        };
        if trace_sys_version() {
            eprintln!(
                "molt sys version: get info {}.{}.{} {} {} init={}",
                info.major, info.minor, info.micro, info.releaselevel, info.serial, initialized
            );
        }
        let release_ptr = alloc_string(_py, info.releaselevel.as_bytes());
        if release_ptr.is_null() {
            return MoltObject::none().bits();
        }
        let release_bits = MoltObject::from_ptr(release_ptr).bits();
        let elems = [
            MoltObject::from_int(info.major).bits(),
            MoltObject::from_int(info.minor).bits(),
            MoltObject::from_int(info.micro).bits(),
            release_bits,
            MoltObject::from_int(info.serial).bits(),
        ];
        let tuple_ptr = alloc_tuple(_py, &elems);
        if tuple_ptr.is_null() {
            dec_ref_bits(_py, release_bits);
            return MoltObject::none().bits();
        }
        for bits in elems {
            dec_ref_bits(_py, bits);
        }
        MoltObject::from_ptr(tuple_ptr).bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_sys_version() -> u64 {
    crate::with_gil_entry!(_py, {
        let state = runtime_state(_py);
        let info = {
            let mut guard = state.sys_version_info.lock().unwrap();
            if let Some(existing) = guard.as_ref() {
                existing.clone()
            } else {
                let init = default_sys_version_info();
                *guard = Some(init.clone());
                init
            }
        };
        let version = {
            let mut guard = state.sys_version.lock().unwrap();
            if let Some(existing) = guard.as_ref() {
                existing.clone()
            } else {
                let computed = format_sys_version(&info);
                *guard = Some(computed.clone());
                computed
            }
        };
        let ptr = alloc_string(_py, version.as_bytes());
        if ptr.is_null() {
            return MoltObject::none().bits();
        }
        MoltObject::from_ptr(ptr).bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_sys_executable() -> u64 {
    crate::with_gil_entry!(_py, {
        let executable = match std::env::var("MOLT_SYS_EXECUTABLE") {
            Ok(val) if !val.is_empty() => val.into_bytes(),
            _ => runtime_state(_py)
                .argv
                .lock()
                .unwrap()
                .first()
                .cloned()
                .unwrap_or_default(),
        };
        let ptr = alloc_string(_py, &executable);
        if ptr.is_null() {
            return MoltObject::none().bits();
        }
        MoltObject::from_ptr(ptr).bits()
    })
}

#[unsafe(no_mangle)]
/// # Safety
/// Caller must ensure `argv` points to `argc` null-terminated strings.
pub unsafe extern "C" fn molt_set_argv(argc: i32, argv: *const *const u8) {
    unsafe {
        crate::with_gil_entry!(_py, {
            let mut args = Vec::new();
            if argc > 0 && !argv.is_null() {
                for idx in 0..argc {
                    let ptr = *argv.add(idx as usize);
                    if ptr.is_null() {
                        args.push(Vec::new());
                        continue;
                    }
                    let bytes = CStr::from_ptr(ptr as *const i8).to_bytes();
                    let (decoded, _) = decode_bytes_text("utf-8", "surrogateescape", bytes)
                        .expect("argv decode must succeed for utf-8+surrogateescape");
                    args.push(decoded);
                }
            }
            let trace_argv = matches!(std::env::var("MOLT_TRACE_ARGV").ok().as_deref(), Some("1"));
            if trace_argv {
                eprintln!("molt_set_argv argc={argc} argv0={:?}", args.first());
            }
            *runtime_state(_py).argv.lock().unwrap() = args;
        })
    }
}

#[cfg(target_os = "windows")]
#[unsafe(no_mangle)]
/// # Safety
/// Caller must ensure `argv` points to `argc` null-terminated UTF-16 strings.
pub unsafe extern "C" fn molt_set_argv_utf16(argc: i32, argv: *const *const u16) {
    crate::with_gil_entry!(_py, {
        let mut args = Vec::new();
        if argc > 0 && !argv.is_null() {
            for idx in 0..argc {
                let ptr = *argv.add(idx as usize);
                if ptr.is_null() {
                    args.push(Vec::new());
                    continue;
                }
                let mut len = 0usize;
                while *ptr.add(len) != 0 {
                    len += 1;
                }
                let slice = std::slice::from_raw_parts(ptr, len);
                let mut raw = Vec::with_capacity(slice.len() * 2);
                for &unit in slice {
                    raw.push((unit & 0x00FF) as u8);
                    raw.push((unit >> 8) as u8);
                }
                let (decoded, _) = decode_bytes_text("utf-16-le", "surrogatepass", &raw)
                    .expect("argv decode must succeed for utf-16-le+surrogatepass");
                args.push(decoded);
            }
        }
        *runtime_state(_py).argv.lock().unwrap() = args;
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_getpid() -> u64 {
    crate::with_gil_entry!(_py, {
        #[cfg(target_arch = "wasm32")]
        {
            let pid = unsafe { crate::molt_getpid_host() };
            let pid = if pid < 0 { 0 } else { pid };
            MoltObject::from_int(pid).bits()
        }
        #[cfg(not(target_arch = "wasm32"))]
        {
            MoltObject::from_int(std::process::id() as i64).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_signal_raise(sig_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let Some(sig) = to_i64(obj_from_bits(sig_bits)) else {
            return raise_exception::<_>(_py, "TypeError", "signal number must be int");
        };
        if sig < i32::MIN as i64 || sig > i32::MAX as i64 {
            return raise_exception::<_>(_py, "ValueError", "signal number out of range");
        }
        let sig_i32 = sig as i32;
        #[cfg(all(unix, not(target_arch = "wasm32")))]
        {
            let rc = unsafe { libc::raise(sig_i32) };
            if rc != 0 {
                return raise_exception::<_>(
                    _py,
                    "OSError",
                    &std::io::Error::last_os_error().to_string(),
                );
            }
            return MoltObject::none().bits();
        }
        #[cfg(any(not(unix), target_arch = "wasm32"))]
        {
            if sig_i32 == 2 {
                return raise_exception::<_>(_py, "KeyboardInterrupt", "signal interrupt");
            }
            MoltObject::none().bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_time_monotonic() -> u64 {
    crate::with_gil_entry!(_py, {
        MoltObject::from_float(monotonic_now_secs(_py)).bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_time_perf_counter() -> u64 {
    crate::with_gil_entry!(_py, {
        MoltObject::from_float(monotonic_now_secs(_py)).bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_time_monotonic_ns() -> u64 {
    crate::with_gil_entry!(_py, {
        int_bits_from_bigint(_py, BigInt::from(monotonic_now_nanos(_py)))
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_time_perf_counter_ns() -> u64 {
    crate::with_gil_entry!(_py, {
        int_bits_from_bigint(_py, BigInt::from(monotonic_now_nanos(_py)))
    })
}

#[cfg(all(not(target_arch = "wasm32"), unix))]
fn process_time_duration() -> Result<std::time::Duration, String> {
    let mut ts = libc::timespec {
        tv_sec: 0,
        tv_nsec: 0,
    };
    let rc = unsafe { libc::clock_gettime(libc::CLOCK_PROCESS_CPUTIME_ID, &mut ts) };
    if rc != 0 {
        return Err(std::io::Error::last_os_error().to_string());
    }
    if ts.tv_sec < 0 || ts.tv_nsec < 0 {
        return Err("process time before epoch".to_string());
    }
    Ok(std::time::Duration::new(
        ts.tv_sec as u64,
        ts.tv_nsec as u32,
    ))
}

#[cfg(all(not(target_arch = "wasm32"), windows))]
fn process_time_duration() -> Result<std::time::Duration, String> {
    use windows_sys::Win32::Foundation::FILETIME;
    use windows_sys::Win32::System::Threading::{GetCurrentProcess, GetProcessTimes};

    let mut creation = FILETIME {
        dwLowDateTime: 0,
        dwHighDateTime: 0,
    };
    let mut exit = FILETIME {
        dwLowDateTime: 0,
        dwHighDateTime: 0,
    };
    let mut kernel = FILETIME {
        dwLowDateTime: 0,
        dwHighDateTime: 0,
    };
    let mut user = FILETIME {
        dwLowDateTime: 0,
        dwHighDateTime: 0,
    };
    let handle = unsafe { GetCurrentProcess() };
    let ok = unsafe { GetProcessTimes(handle, &mut creation, &mut exit, &mut kernel, &mut user) };
    if ok == 0 {
        return Err(std::io::Error::last_os_error().to_string());
    }
    let kernel_100ns = ((kernel.dwHighDateTime as u64) << 32) | kernel.dwLowDateTime as u64;
    let user_100ns = ((user.dwHighDateTime as u64) << 32) | user.dwLowDateTime as u64;
    let total_100ns = kernel_100ns.saturating_add(user_100ns);
    let secs = total_100ns / 10_000_000;
    let nanos = (total_100ns % 10_000_000) * 100;
    Ok(std::time::Duration::new(secs, nanos as u32))
}

#[cfg(any(target_arch = "wasm32", not(any(unix, windows))))]
fn process_time_duration() -> Result<std::time::Duration, String> {
    Err("process_time unavailable".to_string())
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_time_process_time() -> u64 {
    crate::with_gil_entry!(_py, {
        match process_time_duration() {
            Ok(duration) => MoltObject::from_float(duration.as_secs_f64()).bits(),
            Err(msg) => raise_exception::<_>(_py, "OSError", &msg),
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_time_process_time_ns() -> u64 {
    crate::with_gil_entry!(_py, {
        match process_time_duration() {
            Ok(duration) => int_bits_from_bigint(_py, BigInt::from(duration.as_nanos())),
            Err(msg) => raise_exception::<_>(_py, "OSError", &msg),
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_time_time() -> u64 {
    crate::with_gil_entry!(_py, {
        #[cfg(not(target_arch = "wasm32"))]
        {
            if require_time_wall_capability::<u64>(_py).is_err() {
                return MoltObject::none().bits();
            }
        }
        let now = match std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH) {
            Ok(now) => now,
            Err(_) => {
                return raise_exception::<_>(_py, "OSError", "system time before epoch");
            }
        };
        MoltObject::from_float(now.as_secs_f64()).bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_time_time_ns() -> u64 {
    crate::with_gil_entry!(_py, {
        #[cfg(not(target_arch = "wasm32"))]
        {
            if require_time_wall_capability::<u64>(_py).is_err() {
                return MoltObject::none().bits();
            }
        }
        let now = match std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH) {
            Ok(now) => now,
            Err(_) => {
                return raise_exception::<_>(_py, "OSError", "system time before epoch");
            }
        };
        int_bits_from_bigint(_py, BigInt::from(now.as_nanos()))
    })
}

#[derive(Clone, Copy, Debug)]
struct TimeParts {
    year: i32,
    month: i32,
    day: i32,
    hour: i32,
    minute: i32,
    second: i32,
    wday: i32,
    yday: i32,
    isdst: i32,
}

fn time_parts_to_tuple(_py: &PyToken<'_>, parts: TimeParts) -> u64 {
    let elems = [
        MoltObject::from_int(parts.year as i64).bits(),
        MoltObject::from_int(parts.month as i64).bits(),
        MoltObject::from_int(parts.day as i64).bits(),
        MoltObject::from_int(parts.hour as i64).bits(),
        MoltObject::from_int(parts.minute as i64).bits(),
        MoltObject::from_int(parts.second as i64).bits(),
        MoltObject::from_int(parts.wday as i64).bits(),
        MoltObject::from_int(parts.yday as i64).bits(),
        MoltObject::from_int(parts.isdst as i64).bits(),
    ];
    let tuple_ptr = alloc_tuple(_py, &elems);
    if tuple_ptr.is_null() {
        MoltObject::none().bits()
    } else {
        MoltObject::from_ptr(tuple_ptr).bits()
    }
}

#[cfg(not(target_arch = "wasm32"))]
fn time_parts_from_tm(tm: &libc::tm) -> TimeParts {
    let wday = (tm.tm_wday + 6).rem_euclid(7);
    TimeParts {
        year: tm.tm_year + 1900,
        month: tm.tm_mon + 1,
        day: tm.tm_mday,
        hour: tm.tm_hour,
        minute: tm.tm_min,
        second: tm.tm_sec,
        wday,
        yday: tm.tm_yday + 1,
        isdst: tm.tm_isdst,
    }
}

#[cfg(not(target_arch = "wasm32"))]
fn tm_from_time_parts(_py: &PyToken<'_>, parts: TimeParts) -> Result<libc::tm, u64> {
    let mut tm = unsafe { std::mem::zeroed::<libc::tm>() };
    tm.tm_sec = parts.second;
    tm.tm_min = parts.minute;
    tm.tm_hour = parts.hour;
    tm.tm_mday = parts.day;
    tm.tm_mon = parts.month - 1;
    tm.tm_year = parts.year - 1900;
    tm.tm_wday = (parts.wday + 1).rem_euclid(7);
    tm.tm_yday = parts.yday - 1;
    tm.tm_isdst = parts.isdst;
    if tm.tm_mon < 0 || tm.tm_mon > 11 {
        return Err(raise_exception::<_>(
            _py,
            "ValueError",
            "strftime() argument 2 out of range",
        ));
    }
    Ok(tm)
}

#[cfg(target_arch = "wasm32")]
fn is_leap_year(year: i32) -> bool {
    (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)
}

#[cfg(target_arch = "wasm32")]
fn day_of_year(year: i32, month: i32, day: i32) -> i32 {
    const DAYS_BEFORE_MONTH: [[i32; 13]; 2] = [
        [0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
        [0, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335],
    ];
    let leap = if is_leap_year(year) { 1 } else { 0 };
    let m = month.clamp(1, 12) as usize;
    DAYS_BEFORE_MONTH[leap][m] + day
}

#[cfg(target_arch = "wasm32")]
fn civil_from_days(days: i64) -> (i32, i32, i32) {
    let z = days + 719_468;
    let era = if z >= 0 { z } else { z - 146_096 } / 146_097;
    let doe = z - era * 146_097;
    let yoe = (doe - doe / 1460 + doe / 36524 - doe / 146096) / 365;
    let mut y = (yoe + era * 400) as i32;
    let doy = (doe - (365 * yoe + yoe / 4 - yoe / 100)) as i32;
    let mp = (5 * doy + 2) / 153;
    let d = (doy - (153 * mp + 2) / 5 + 1) as i32;
    let m = (mp + if mp < 10 { 3 } else { -9 }) as i32;
    if m <= 2 {
        y += 1;
    }
    (y, m, d)
}

#[cfg(target_arch = "wasm32")]
fn time_parts_from_epoch_utc(secs: i64) -> TimeParts {
    let days = secs.div_euclid(86_400);
    let rem = secs.rem_euclid(86_400);
    let hour = (rem / 3600) as i32;
    let minute = ((rem % 3600) / 60) as i32;
    let second = (rem % 60) as i32;
    let (year, month, day) = civil_from_days(days);
    let yday = day_of_year(year, month, day);
    let wday = ((days + 3).rem_euclid(7)) as i32;
    TimeParts {
        year,
        month,
        day,
        hour,
        minute,
        second,
        wday,
        yday,
        isdst: 0,
    }
}

#[cfg(target_arch = "wasm32")]
fn timezone_west_wasm() -> Result<i64, String> {
    let offset = unsafe { crate::molt_time_timezone_host() };
    if offset == i64::MIN {
        return Err("timezone unavailable".to_string());
    }
    Ok(offset)
}

#[cfg(target_arch = "wasm32")]
fn local_offset_west_wasm(secs: i64) -> Result<i64, String> {
    let offset = unsafe { crate::molt_time_local_offset_host(secs) };
    if offset == i64::MIN {
        return Err("localtime failed".to_string());
    }
    Ok(offset)
}

#[cfg(target_arch = "wasm32")]
fn tzname_label_wasm(which: i32) -> Result<String, String> {
    let mut buf = vec![0u8; 256];
    let mut out_len: u32 = 0;
    let status = unsafe {
        crate::molt_time_tzname_host(
            which,
            buf.as_mut_ptr() as u32,
            buf.len() as u32,
            (&mut out_len as *mut u32) as u32,
        )
    };
    if status != 0 {
        return Err("tzname unavailable".to_string());
    }
    let out_len = usize::try_from(out_len).map_err(|_| "tzname unavailable".to_string())?;
    if out_len > buf.len() {
        return Err("tzname unavailable".to_string());
    }
    buf.truncate(out_len);
    String::from_utf8(buf).map_err(|_| "tzname unavailable".to_string())
}

#[cfg(target_arch = "wasm32")]
fn tzname_wasm() -> Result<(String, String), String> {
    let std_name = tzname_label_wasm(0)?;
    let dst_name = tzname_label_wasm(1)?;
    Ok((std_name, dst_name))
}

fn current_epoch_secs_i64() -> Result<i64, String> {
    let now = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .map_err(|_| "system time before epoch".to_string())?;
    Ok(i64::try_from(now.as_secs()).unwrap_or(i64::MAX))
}

fn parse_time_seconds(_py: &PyToken<'_>, secs_bits: u64) -> Result<i64, u64> {
    let obj = obj_from_bits(secs_bits);
    if obj.is_none() {
        let now = match std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH) {
            Ok(now) => now,
            Err(_) => {
                return Err(raise_exception::<_>(
                    _py,
                    "OSError",
                    "system time before epoch",
                ));
            }
        };
        let secs = now.as_secs();
        let secs = i64::try_from(secs).unwrap_or(i64::MAX);
        return Ok(secs);
    }
    let Some(val) = to_f64(obj) else {
        let type_name = class_name_for_error(type_of_bits(_py, secs_bits));
        let msg = format!("an integer is required (got type {type_name})");
        return Err(raise_exception::<_>(_py, "TypeError", &msg));
    };
    if !val.is_finite() {
        return Err(raise_exception::<_>(
            _py,
            "OverflowError",
            "timestamp out of range for platform time_t",
        ));
    }
    let secs = val.trunc();
    let (min, max) = time_t_bounds();
    if secs < min as f64 || secs > max as f64 {
        return Err(raise_exception::<_>(
            _py,
            "OverflowError",
            "timestamp out of range for platform time_t",
        ));
    }
    Ok(secs as i64)
}

#[cfg(not(target_arch = "wasm32"))]
fn time_t_bounds() -> (i128, i128) {
    let size = std::mem::size_of::<libc::time_t>();
    if size == 4 {
        (i32::MIN as i128, i32::MAX as i128)
    } else {
        (i64::MIN as i128, i64::MAX as i128)
    }
}

#[cfg(target_arch = "wasm32")]
fn time_t_bounds() -> (i128, i128) {
    (i64::MIN as i128, i64::MAX as i128)
}

fn days_from_civil(year: i32, month: i32, day: i32) -> i64 {
    let mut y = year as i64;
    let m = month as i64;
    let d = day as i64;
    y -= if m <= 2 { 1 } else { 0 };
    let era = if y >= 0 { y } else { y - 399 } / 400;
    let yoe = y - era * 400;
    let mp = m + if m > 2 { -3 } else { 9 };
    let doy = (153 * mp + 2) / 5 + d - 1;
    let doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;
    era * 146_097 + doe - 719_468
}

#[cfg(not(target_arch = "wasm32"))]
fn tm_to_epoch_seconds(tm: &libc::tm) -> i64 {
    let year = tm.tm_year + 1900;
    let month = tm.tm_mon + 1;
    let day = tm.tm_mday;
    let days = days_from_civil(year, month, day);
    let seconds = (tm.tm_hour as i64) * 3600 + (tm.tm_min as i64) * 60 + (tm.tm_sec as i64);
    days.saturating_mul(86_400).saturating_add(seconds)
}

#[cfg(not(target_arch = "wasm32"))]
fn offset_west_from_secs(secs: i64) -> Result<i64, String> {
    let secs = secs as libc::time_t;
    let local_tm = localtime_tm(secs)?;
    let utc_tm = gmtime_tm(secs)?;
    let local_secs = tm_to_epoch_seconds(&local_tm);
    let utc_secs = tm_to_epoch_seconds(&utc_tm);
    Ok(utc_secs.saturating_sub(local_secs))
}

fn parse_time_tuple(_py: &PyToken<'_>, tuple_bits: u64) -> Result<TimeParts, u64> {
    let obj = obj_from_bits(tuple_bits);
    let Some(ptr) = obj.as_ptr() else {
        return Err(raise_exception::<_>(
            _py,
            "TypeError",
            "strftime() argument 2 must be tuple",
        ));
    };
    unsafe {
        if object_type_id(ptr) != TYPE_ID_TUPLE {
            let type_name = class_name_for_error(type_of_bits(_py, tuple_bits));
            let msg = format!("strftime() argument 2 must be tuple, not {type_name}");
            return Err(raise_exception::<_>(_py, "TypeError", &msg));
        }
        let elems = seq_vec_ref(ptr);
        if elems.len() != 9 {
            return Err(raise_exception::<_>(
                _py,
                "TypeError",
                "time tuple must have exactly 9 elements",
            ));
        }
        let mut vals = [0i64; 9];
        for (idx, slot) in vals.iter_mut().enumerate() {
            let bits = elems[idx];
            let Some(val) = to_i64(obj_from_bits(bits)) else {
                let type_name = class_name_for_error(type_of_bits(_py, bits));
                let msg = format!("an integer is required (got type {type_name})");
                return Err(raise_exception::<_>(_py, "TypeError", &msg));
            };
            if val < i32::MIN as i64 || val > i32::MAX as i64 {
                return Err(raise_exception::<_>(
                    _py,
                    "ValueError",
                    "strftime() argument 2 out of range",
                ));
            }
            *slot = val;
        }
        let year = vals[0] as i32;
        let month = vals[1] as i32;
        let day = vals[2] as i32;
        let hour = vals[3] as i32;
        let minute = vals[4] as i32;
        let second = vals[5] as i32;
        let wday = vals[6] as i32;
        let yday = vals[7] as i32;
        let isdst = vals[8] as i32;
        if !(1..=12).contains(&month)
            || !(1..=31).contains(&day)
            || !(0..=23).contains(&hour)
            || !(0..=59).contains(&minute)
            || !(0..=60).contains(&second)
            || !(0..=6).contains(&wday)
            || !(1..=366).contains(&yday)
        {
            return Err(raise_exception::<_>(
                _py,
                "ValueError",
                "strftime() argument 2 out of range",
            ));
        }
        if ![-1, 0, 1].contains(&isdst) {
            return Err(raise_exception::<_>(
                _py,
                "ValueError",
                "strftime() argument 2 out of range",
            ));
        }
        Ok(TimeParts {
            year,
            month,
            day,
            hour,
            minute,
            second,
            wday,
            yday,
            isdst,
        })
    }
}

fn asctime_from_parts(parts: TimeParts) -> Result<String, String> {
    const WEEKDAY_ABBR: [&str; 7] = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    const MONTH_ABBR: [&str; 12] = [
        "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
    ];
    if !(0..=6).contains(&parts.wday)
        || !(1..=12).contains(&parts.month)
        || !(1..=31).contains(&parts.day)
    {
        return Err("time tuple elements out of range".to_string());
    }
    let wday = WEEKDAY_ABBR[parts.wday as usize];
    let month = MONTH_ABBR[(parts.month - 1) as usize];
    Ok(format!(
        "{wday} {month} {:2} {:02}:{:02}:{:02} {:04}",
        parts.day, parts.hour, parts.minute, parts.second, parts.year
    ))
}

fn parse_mktime_tuple(_py: &PyToken<'_>, tuple_bits: u64) -> Result<TimeParts, u64> {
    let obj = obj_from_bits(tuple_bits);
    let Some(ptr) = obj.as_ptr() else {
        return Err(raise_exception::<_>(
            _py,
            "TypeError",
            "Tuple or struct_time argument required",
        ));
    };
    unsafe {
        if object_type_id(ptr) != TYPE_ID_TUPLE {
            return Err(raise_exception::<_>(
                _py,
                "TypeError",
                "Tuple or struct_time argument required",
            ));
        }
        let elems = seq_vec_ref(ptr);
        if elems.len() != 9 {
            return Err(raise_exception::<_>(
                _py,
                "TypeError",
                "mktime(): illegal time tuple argument",
            ));
        }
        let mut vals = [0i64; 9];
        for (idx, slot) in vals.iter_mut().enumerate() {
            let bits = elems[idx];
            let Some(val) = to_i64(obj_from_bits(bits)) else {
                let type_name = class_name_for_error(type_of_bits(_py, bits));
                let msg = format!("an integer is required (got type {type_name})");
                return Err(raise_exception::<_>(_py, "TypeError", &msg));
            };
            if val < i32::MIN as i64 || val > i32::MAX as i64 {
                return Err(raise_exception::<_>(
                    _py,
                    "OverflowError",
                    "mktime(): argument out of range",
                ));
            }
            *slot = val;
        }
        Ok(TimeParts {
            year: vals[0] as i32,
            month: vals[1] as i32,
            day: vals[2] as i32,
            hour: vals[3] as i32,
            minute: vals[4] as i32,
            second: vals[5] as i32,
            wday: vals[6] as i32,
            yday: vals[7] as i32,
            isdst: vals[8] as i32,
        })
    }
}

fn parse_timegm_tuple(
    _py: &PyToken<'_>,
    tuple_bits: u64,
) -> Result<(i32, i32, i32, i32, i32, i32), u64> {
    let obj = obj_from_bits(tuple_bits);
    let Some(ptr) = obj.as_ptr() else {
        return Err(raise_exception::<_>(
            _py,
            "TypeError",
            "Tuple or struct_time argument required",
        ));
    };
    unsafe {
        if object_type_id(ptr) != TYPE_ID_TUPLE {
            return Err(raise_exception::<_>(
                _py,
                "TypeError",
                "Tuple or struct_time argument required",
            ));
        }
        let elems = seq_vec_ref(ptr);
        if elems.len() < 6 {
            let msg = format!(
                "not enough values to unpack (expected 6, got {})",
                elems.len()
            );
            return Err(raise_exception::<_>(_py, "ValueError", &msg));
        }
        let mut vals = [0i64; 6];
        for (idx, slot) in vals.iter_mut().enumerate() {
            let bits = elems[idx];
            let Some(val) = to_i64(obj_from_bits(bits)) else {
                let type_name = class_name_for_error(type_of_bits(_py, bits));
                let msg = format!("an integer is required (got type {type_name})");
                return Err(raise_exception::<_>(_py, "TypeError", &msg));
            };
            if val < i32::MIN as i64 || val > i32::MAX as i64 {
                return Err(raise_exception::<_>(
                    _py,
                    "OverflowError",
                    "timegm(): argument out of range",
                ));
            }
            *slot = val;
        }
        Ok((
            vals[0] as i32,
            vals[1] as i32,
            vals[2] as i32,
            vals[3] as i32,
            vals[4] as i32,
            vals[5] as i32,
        ))
    }
}

#[cfg(not(target_arch = "wasm32"))]
fn localtime_tm(secs: libc::time_t) -> Result<libc::tm, String> {
    #[cfg(unix)]
    unsafe {
        let mut out = std::mem::zeroed::<libc::tm>();
        if libc::localtime_r(&secs as *const libc::time_t, &mut out).is_null() {
            return Err("localtime failed".to_string());
        }
        Ok(out)
    }
    #[cfg(windows)]
    unsafe {
        let mut out = std::mem::zeroed::<libc::tm>();
        let rc = libc::localtime_s(&mut out as *mut libc::tm, &secs as *const libc::time_t);
        if rc != 0 {
            return Err("localtime failed".to_string());
        }
        Ok(out)
    }
}

#[cfg(not(target_arch = "wasm32"))]
fn gmtime_tm(secs: libc::time_t) -> Result<libc::tm, String> {
    #[cfg(unix)]
    unsafe {
        let mut out = std::mem::zeroed::<libc::tm>();
        if libc::gmtime_r(&secs as *const libc::time_t, &mut out).is_null() {
            return Err("gmtime failed".to_string());
        }
        Ok(out)
    }
    #[cfg(windows)]
    unsafe {
        let mut out = std::mem::zeroed::<libc::tm>();
        let rc = libc::gmtime_s(&mut out as *mut libc::tm, &secs as *const libc::time_t);
        if rc != 0 {
            return Err("gmtime failed".to_string());
        }
        Ok(out)
    }
}

#[cfg(target_arch = "wasm32")]
fn strftime_wasm(format: &str, parts: TimeParts) -> Result<String, String> {
    const WEEKDAY_SHORT: [&str; 7] = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    const WEEKDAY_LONG: [&str; 7] = [
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
        "Sunday",
    ];
    const MONTH_SHORT: [&str; 12] = [
        "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
    ];
    const MONTH_LONG: [&str; 12] = [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
    ];

    fn push_num(out: &mut String, val: i32, width: usize, pad: char) {
        let mut buf = [pad as u8; 12];
        let mut idx = buf.len();
        let mut n = val.abs() as u32;
        if n == 0 {
            idx -= 1;
            buf[idx] = b'0';
        } else {
            while n > 0 {
                let digit = (n % 10) as u8;
                idx -= 1;
                buf[idx] = b'0' + digit;
                n /= 10;
            }
        }
        let len = buf.len() - idx;
        let needed = width.saturating_sub(len + if val < 0 { 1 } else { 0 });
        for _ in 0..needed {
            out.push(pad);
        }
        if val < 0 {
            out.push('-');
        }
        out.push_str(std::str::from_utf8(&buf[idx..]).unwrap_or("0"));
    }

    fn jan1_wday_mon0(yday: i32, wday_mon0: i32) -> i32 {
        let offset = (yday - 1).rem_euclid(7);
        (wday_mon0 - offset).rem_euclid(7)
    }

    fn week_number_sun(yday: i32, jan1_wday_mon0: i32) -> i32 {
        let jan1_sun0 = (jan1_wday_mon0 + 1).rem_euclid(7);
        let first_sunday = 1 + (7 - jan1_sun0).rem_euclid(7);
        if yday < first_sunday {
            0
        } else {
            1 + (yday - first_sunday) / 7
        }
    }

    fn week_number_mon(yday: i32, jan1_wday_mon0: i32) -> i32 {
        let first_monday = 1 + (7 - jan1_wday_mon0).rem_euclid(7);
        if yday < first_monday {
            0
        } else {
            1 + (yday - first_monday) / 7
        }
    }

    fn weeks_in_year(year: i32, jan1_wday_mon0: i32) -> i32 {
        let jan1_mon1 = jan1_wday_mon0 + 1;
        if jan1_mon1 == 4 || (is_leap_year(year) && jan1_mon1 == 3) {
            53
        } else {
            52
        }
    }

    fn iso_week_date(year: i32, yday: i32, wday_mon0: i32) -> (i32, i32, i32) {
        let weekday = wday_mon0 + 1;
        let mut week = (yday - weekday + 10) / 7;
        let jan1_wday = jan1_wday_mon0(yday, wday_mon0);
        let mut iso_year = year;
        let max_week = weeks_in_year(year, jan1_wday);
        if week < 1 {
            iso_year -= 1;
            let prev_days = if is_leap_year(iso_year) { 366 } else { 365 };
            let prev_jan1 = (jan1_wday - (prev_days % 7)).rem_euclid(7);
            week = weeks_in_year(iso_year, prev_jan1);
        } else if week > max_week {
            iso_year += 1;
            week = 1;
        }
        (iso_year, week, weekday)
    }

    let mut out = String::with_capacity(format.len() + 16);
    let mut iter = format.chars();
    while let Some(ch) = iter.next() {
        if ch != '%' {
            out.push(ch);
            continue;
        }
        let Some(spec) = iter.next() else {
            out.push('%');
            break;
        };
        match spec {
            '%' => out.push('%'),
            'a' => out.push_str(WEEKDAY_SHORT[parts.wday as usize]),
            'A' => out.push_str(WEEKDAY_LONG[parts.wday as usize]),
            'b' | 'h' => out.push_str(MONTH_SHORT[(parts.month - 1) as usize]),
            'B' => out.push_str(MONTH_LONG[(parts.month - 1) as usize]),
            'C' => {
                let century = parts.year.div_euclid(100);
                push_num(&mut out, century, 2, '0');
            }
            'd' => push_num(&mut out, parts.day, 2, '0'),
            'e' => push_num(&mut out, parts.day, 2, ' '),
            'H' => push_num(&mut out, parts.hour, 2, '0'),
            'I' => {
                let mut hour = parts.hour % 12;
                if hour == 0 {
                    hour = 12;
                }
                push_num(&mut out, hour, 2, '0');
            }
            'k' => push_num(&mut out, parts.hour, 2, ' '),
            'l' => {
                let mut hour = parts.hour % 12;
                if hour == 0 {
                    hour = 12;
                }
                push_num(&mut out, hour, 2, ' ');
            }
            'j' => push_num(&mut out, parts.yday, 3, '0'),
            'm' => push_num(&mut out, parts.month, 2, '0'),
            'M' => push_num(&mut out, parts.minute, 2, '0'),
            'p' => out.push_str(if parts.hour < 12 { "AM" } else { "PM" }),
            'S' => push_num(&mut out, parts.second, 2, '0'),
            'U' => {
                let jan1 = jan1_wday_mon0(parts.yday, parts.wday);
                let week = week_number_sun(parts.yday, jan1);
                push_num(&mut out, week, 2, '0');
            }
            'W' => {
                let jan1 = jan1_wday_mon0(parts.yday, parts.wday);
                let week = week_number_mon(parts.yday, jan1);
                push_num(&mut out, week, 2, '0');
            }
            'w' => {
                let wday_sun0 = (parts.wday + 1).rem_euclid(7);
                push_num(&mut out, wday_sun0, 1, '0');
            }
            'u' => {
                let wday_mon1 = parts.wday + 1;
                push_num(&mut out, wday_mon1, 1, '0');
            }
            'x' => {
                push_num(&mut out, parts.month, 2, '0');
                out.push('/');
                push_num(&mut out, parts.day, 2, '0');
                out.push('/');
                let yy = parts.year.rem_euclid(100);
                push_num(&mut out, yy, 2, '0');
            }
            'X' => {
                push_num(&mut out, parts.hour, 2, '0');
                out.push(':');
                push_num(&mut out, parts.minute, 2, '0');
                out.push(':');
                push_num(&mut out, parts.second, 2, '0');
            }
            'y' => {
                let yy = parts.year.rem_euclid(100);
                push_num(&mut out, yy, 2, '0');
            }
            'Y' => push_num(&mut out, parts.year, 4, '0'),
            'Z' => out.push_str("UTC"),
            'z' => out.push_str("+0000"),
            'c' => {
                out.push_str(WEEKDAY_SHORT[parts.wday as usize]);
                out.push(' ');
                out.push_str(MONTH_SHORT[(parts.month - 1) as usize]);
                out.push(' ');
                push_num(&mut out, parts.day, 2, ' ');
                out.push(' ');
                push_num(&mut out, parts.hour, 2, '0');
                out.push(':');
                push_num(&mut out, parts.minute, 2, '0');
                out.push(':');
                push_num(&mut out, parts.second, 2, '0');
                out.push(' ');
                push_num(&mut out, parts.year, 4, '0');
            }
            'D' => {
                push_num(&mut out, parts.month, 2, '0');
                out.push('/');
                push_num(&mut out, parts.day, 2, '0');
                out.push('/');
                let yy = parts.year.rem_euclid(100);
                push_num(&mut out, yy, 2, '0');
            }
            'F' => {
                push_num(&mut out, parts.year, 4, '0');
                out.push('-');
                push_num(&mut out, parts.month, 2, '0');
                out.push('-');
                push_num(&mut out, parts.day, 2, '0');
            }
            'R' => {
                push_num(&mut out, parts.hour, 2, '0');
                out.push(':');
                push_num(&mut out, parts.minute, 2, '0');
            }
            'r' => {
                let mut hour = parts.hour % 12;
                if hour == 0 {
                    hour = 12;
                }
                push_num(&mut out, hour, 2, '0');
                out.push(':');
                push_num(&mut out, parts.minute, 2, '0');
                out.push(':');
                push_num(&mut out, parts.second, 2, '0');
                out.push(' ');
                out.push_str(if parts.hour < 12 { "AM" } else { "PM" });
            }
            'T' => {
                push_num(&mut out, parts.hour, 2, '0');
                out.push(':');
                push_num(&mut out, parts.minute, 2, '0');
                out.push(':');
                push_num(&mut out, parts.second, 2, '0');
            }
            'n' => out.push('\n'),
            't' => out.push('\t'),
            'G' | 'g' | 'V' => {
                let (iso_year, iso_week, _) = iso_week_date(parts.year, parts.yday, parts.wday);
                match spec {
                    'G' => push_num(&mut out, iso_year, 4, '0'),
                    'g' => {
                        let yy = iso_year.rem_euclid(100);
                        push_num(&mut out, yy, 2, '0');
                    }
                    _ => push_num(&mut out, iso_week, 2, '0'),
                }
            }
            _ => {
                return Err(format!("unsupported strftime directive %{spec}"));
            }
        }
    }
    Ok(out)
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_time_localtime(secs_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(secs_bits);
        #[cfg(not(target_arch = "wasm32"))]
        {
            if obj.is_none() && require_time_wall_capability::<u64>(_py).is_err() {
                return MoltObject::none().bits();
            }
        }
        let secs = match parse_time_seconds(_py, secs_bits) {
            Ok(val) => val,
            Err(bits) => return bits,
        };
        #[cfg(not(target_arch = "wasm32"))]
        {
            let secs = secs as libc::time_t;
            let tm = match localtime_tm(secs) {
                Ok(tm) => tm,
                Err(msg) => return raise_exception::<_>(_py, "OSError", &msg),
            };
            let parts = time_parts_from_tm(&tm);
            time_parts_to_tuple(_py, parts)
        }
        #[cfg(target_arch = "wasm32")]
        {
            let offset_west = match local_offset_west_wasm(secs) {
                Ok(value) => value,
                Err(msg) => return raise_exception::<_>(_py, "OSError", &msg),
            };
            let mut parts = time_parts_from_epoch_utc(secs.saturating_sub(offset_west));
            let std_offset_west = timezone_west_wasm().unwrap_or(offset_west);
            parts.isdst = if offset_west != std_offset_west { 1 } else { 0 };
            return time_parts_to_tuple(_py, parts);
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_time_gmtime(secs_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(secs_bits);
        #[cfg(not(target_arch = "wasm32"))]
        {
            if obj.is_none() && require_time_wall_capability::<u64>(_py).is_err() {
                return MoltObject::none().bits();
            }
        }
        let secs = match parse_time_seconds(_py, secs_bits) {
            Ok(val) => val,
            Err(bits) => return bits,
        };
        #[cfg(not(target_arch = "wasm32"))]
        {
            let secs = secs as libc::time_t;
            let tm = match gmtime_tm(secs) {
                Ok(tm) => tm,
                Err(msg) => return raise_exception::<_>(_py, "OSError", &msg),
            };
            let parts = time_parts_from_tm(&tm);
            time_parts_to_tuple(_py, parts)
        }
        #[cfg(target_arch = "wasm32")]
        {
            let parts = time_parts_from_epoch_utc(secs);
            return time_parts_to_tuple(_py, parts);
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_time_strftime(fmt_bits: u64, time_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let fmt_obj = obj_from_bits(fmt_bits);
        if fmt_obj.is_none() {
            return raise_exception::<_>(_py, "TypeError", "strftime() format must be str");
        }
        let Some(fmt) = string_obj_to_owned(fmt_obj) else {
            let type_name = class_name_for_error(type_of_bits(_py, fmt_bits));
            let msg = format!("strftime() format must be str, not {type_name}");
            return raise_exception::<_>(_py, "TypeError", &msg);
        };
        if fmt.as_bytes().contains(&0) {
            return raise_exception::<_>(_py, "ValueError", "embedded null character");
        }
        let parts = match parse_time_tuple(_py, time_bits) {
            Ok(parts) => parts,
            Err(bits) => return bits,
        };
        #[cfg(not(target_arch = "wasm32"))]
        {
            let tm = match tm_from_time_parts(_py, parts) {
                Ok(tm) => tm,
                Err(bits) => return bits,
            };
            let c_fmt = match CString::new(fmt) {
                Ok(c) => c,
                Err(_) => {
                    return raise_exception::<_>(_py, "ValueError", "embedded null character");
                }
            };
            let mut buf = vec![0u8; 128];
            loop {
                let len = unsafe {
                    libc::strftime(
                        buf.as_mut_ptr() as *mut libc::c_char,
                        buf.len(),
                        c_fmt.as_ptr(),
                        &tm as *const libc::tm,
                    )
                };
                if len == 0 {
                    if buf.len() >= 1_048_576 {
                        return raise_exception::<_>(
                            _py,
                            "ValueError",
                            "strftime() result too large",
                        );
                    }
                    buf.resize(buf.len() * 2, 0);
                    continue;
                }
                let slice = &buf[..len];
                let Ok(text) = std::str::from_utf8(slice) else {
                    return raise_exception::<_>(
                        _py,
                        "UnicodeError",
                        "strftime() produced non-UTF-8 output",
                    );
                };
                let ptr = alloc_string(_py, text.as_bytes());
                if ptr.is_null() {
                    return MoltObject::none().bits();
                }
                return MoltObject::from_ptr(ptr).bits();
            }
        }
        #[cfg(target_arch = "wasm32")]
        {
            let out = match strftime_wasm(&fmt, parts) {
                Ok(out) => out,
                Err(msg) => return raise_exception::<_>(_py, "ValueError", &msg),
            };
            let ptr = alloc_string(_py, out.as_bytes());
            if ptr.is_null() {
                return MoltObject::none().bits();
            }
            return MoltObject::from_ptr(ptr).bits();
        }
    })
}

#[cfg(not(target_arch = "wasm32"))]
fn tzname_native() -> Result<(String, String), String> {
    #[cfg(unix)]
    unsafe {
        unsafe extern "C" {
            fn tzset();
            static mut tzname: [*mut libc::c_char; 2];
        }
        tzset();
        let std_ptr = tzname[0];
        let dst_ptr = tzname[1];
        if std_ptr.is_null() || dst_ptr.is_null() {
            return Err("tzname unavailable".to_string());
        }
        let std_name = CStr::from_ptr(std_ptr).to_string_lossy().into_owned();
        let dst_name = CStr::from_ptr(dst_ptr).to_string_lossy().into_owned();
        Ok((std_name, dst_name))
    }
    #[cfg(windows)]
    unsafe {
        use windows_sys::Win32::System::Time::{
            GetTimeZoneInformation, TIME_ZONE_ID_INVALID, TIME_ZONE_INFORMATION,
        };
        let mut info = TIME_ZONE_INFORMATION {
            Bias: 0,
            StandardName: [0u16; 32],
            StandardDate: std::mem::zeroed(),
            StandardBias: 0,
            DaylightName: [0u16; 32],
            DaylightDate: std::mem::zeroed(),
            DaylightBias: 0,
        };
        let status = GetTimeZoneInformation(&mut info as *mut TIME_ZONE_INFORMATION);
        if status == TIME_ZONE_ID_INVALID {
            return Err("tzname unavailable".to_string());
        }
        let std_len = info
            .StandardName
            .iter()
            .position(|&c| c == 0)
            .unwrap_or(info.StandardName.len());
        let dst_len = info
            .DaylightName
            .iter()
            .position(|&c| c == 0)
            .unwrap_or(info.DaylightName.len());
        let std_name = String::from_utf16_lossy(&info.StandardName[..std_len]);
        let dst_name = String::from_utf16_lossy(&info.DaylightName[..dst_len]);
        return Ok((std_name, dst_name));
    }
}

#[cfg(not(target_arch = "wasm32"))]
fn timezone_native() -> Result<i64, String> {
    #[cfg(unix)]
    unsafe {
        unsafe extern "C" {
            fn tzset();
            static mut timezone: libc::c_long;
        }
        tzset();
        Ok(timezone)
    }
    #[cfg(windows)]
    unsafe {
        use windows_sys::Win32::System::Time::{
            GetTimeZoneInformation, TIME_ZONE_ID_INVALID, TIME_ZONE_INFORMATION,
        };
        let mut info = TIME_ZONE_INFORMATION {
            Bias: 0,
            StandardName: [0u16; 32],
            StandardDate: std::mem::zeroed(),
            StandardBias: 0,
            DaylightName: [0u16; 32],
            DaylightDate: std::mem::zeroed(),
            DaylightBias: 0,
        };
        let status = GetTimeZoneInformation(&mut info as *mut TIME_ZONE_INFORMATION);
        if status == TIME_ZONE_ID_INVALID {
            return Err("timezone unavailable".to_string());
        }
        let bias = info.Bias + info.StandardBias;
        return Ok((bias as i64) * 60);
    }
}

#[cfg(not(target_arch = "wasm32"))]
fn daylight_native() -> Result<i64, String> {
    #[cfg(unix)]
    unsafe {
        unsafe extern "C" {
            fn tzset();
            static mut daylight: libc::c_int;
        }
        tzset();
        Ok(if daylight != 0 { 1 } else { 0 })
    }
    #[cfg(windows)]
    unsafe {
        use windows_sys::Win32::System::Time::{
            GetTimeZoneInformation, TIME_ZONE_ID_INVALID, TIME_ZONE_INFORMATION,
        };
        let mut info = TIME_ZONE_INFORMATION {
            Bias: 0,
            StandardName: [0u16; 32],
            StandardDate: std::mem::zeroed(),
            StandardBias: 0,
            DaylightName: [0u16; 32],
            DaylightDate: std::mem::zeroed(),
            DaylightBias: 0,
        };
        let status = GetTimeZoneInformation(&mut info as *mut TIME_ZONE_INFORMATION);
        if status == TIME_ZONE_ID_INVALID {
            return Err("daylight unavailable".to_string());
        }
        return Ok(if info.DaylightDate.wMonth != 0 { 1 } else { 0 });
    }
}

#[cfg(not(target_arch = "wasm32"))]
fn sample_offset_west_native(year: i32, month: i32, day: i32) -> Result<i64, String> {
    let days = days_from_civil(year, month, day);
    let secs = days.saturating_mul(86_400).saturating_add(12 * 3600);
    offset_west_from_secs(secs)
}

#[cfg(not(target_arch = "wasm32"))]
fn altzone_native() -> Result<i64, String> {
    let std_offset = timezone_native()?;
    if daylight_native()? == 0 {
        return Ok(std_offset);
    }
    #[cfg(windows)]
    unsafe {
        use windows_sys::Win32::System::Time::{
            GetTimeZoneInformation, TIME_ZONE_ID_INVALID, TIME_ZONE_INFORMATION,
        };
        let mut info = TIME_ZONE_INFORMATION {
            Bias: 0,
            StandardName: [0u16; 32],
            StandardDate: std::mem::zeroed(),
            StandardBias: 0,
            DaylightName: [0u16; 32],
            DaylightDate: std::mem::zeroed(),
            DaylightBias: 0,
        };
        let status = GetTimeZoneInformation(&mut info as *mut TIME_ZONE_INFORMATION);
        if status == TIME_ZONE_ID_INVALID {
            return Err("altzone unavailable".to_string());
        }
        let bias = info.Bias + info.DaylightBias;
        return Ok((bias as i64) * 60);
    }
    #[cfg(unix)]
    {
        let now = current_epoch_secs_i64()?;
        let local_tm = localtime_tm(now as libc::time_t)?;
        let year = local_tm.tm_year + 1900;
        let jan = sample_offset_west_native(year, 1, 1).unwrap_or(std_offset);
        let jul = sample_offset_west_native(year, 7, 1).unwrap_or(std_offset);
        if jan != std_offset && jul == std_offset {
            return Ok(jan);
        }
        if jul != std_offset && jan == std_offset {
            return Ok(jul);
        }
        if jan != jul {
            return Ok(std::cmp::min(jan, jul));
        }
        Ok(jan)
    }
}

#[cfg(target_arch = "wasm32")]
fn sample_offset_west_wasm(year: i32, month: i32, day: i32) -> Result<i64, String> {
    let days = days_from_civil(year, month, day);
    let secs = days.saturating_mul(86_400).saturating_add(12 * 3600);
    local_offset_west_wasm(secs)
}

#[cfg(target_arch = "wasm32")]
fn daylight_wasm() -> Result<i64, String> {
    let year = time_parts_from_epoch_utc(current_epoch_secs_i64()?).year;
    let jan = sample_offset_west_wasm(year, 1, 1)?;
    let jul = sample_offset_west_wasm(year, 7, 1)?;
    Ok(if jan != jul { 1 } else { 0 })
}

#[cfg(target_arch = "wasm32")]
fn altzone_wasm() -> Result<i64, String> {
    let std_offset = timezone_west_wasm()?;
    if daylight_wasm()? == 0 {
        return Ok(std_offset);
    }
    let year = time_parts_from_epoch_utc(current_epoch_secs_i64()?).year;
    let jan = sample_offset_west_wasm(year, 1, 1).unwrap_or(std_offset);
    let jul = sample_offset_west_wasm(year, 7, 1).unwrap_or(std_offset);
    if jan != std_offset && jul == std_offset {
        return Ok(jan);
    }
    if jul != std_offset && jan == std_offset {
        return Ok(jul);
    }
    if jan != jul {
        return Ok(std::cmp::min(jan, jul));
    }
    Ok(jan)
}

#[cfg(not(target_arch = "wasm32"))]
fn mktime_native(parts: TimeParts) -> f64 {
    let mut tm = unsafe { std::mem::zeroed::<libc::tm>() };
    tm.tm_sec = parts.second;
    tm.tm_min = parts.minute;
    tm.tm_hour = parts.hour;
    tm.tm_mday = parts.day;
    tm.tm_mon = parts.month - 1;
    tm.tm_year = parts.year - 1900;
    tm.tm_wday = (parts.wday + 1).rem_euclid(7);
    tm.tm_yday = parts.yday - 1;
    tm.tm_isdst = parts.isdst;
    let out = unsafe { libc::mktime(&mut tm as *mut libc::tm) };
    out as f64
}

#[cfg(target_arch = "wasm32")]
fn mktime_wasm(parts: TimeParts) -> Result<f64, String> {
    let days = days_from_civil(parts.year, parts.month, parts.day);
    let local_secs = days
        .saturating_mul(86_400)
        .saturating_add((parts.hour as i64).saturating_mul(3600))
        .saturating_add((parts.minute as i64).saturating_mul(60))
        .saturating_add(parts.second as i64);
    let std_offset = timezone_west_wasm()?;
    let utc_secs = if parts.isdst > 0 {
        let dst_offset = altzone_wasm().unwrap_or(std_offset);
        local_secs.saturating_add(dst_offset)
    } else if parts.isdst == 0 {
        local_secs.saturating_add(std_offset)
    } else {
        let mut guess = local_secs.saturating_add(std_offset);
        for _ in 0..3 {
            let offset = local_offset_west_wasm(guess).unwrap_or(std_offset);
            let next = local_secs.saturating_add(offset);
            if next == guess {
                break;
            }
            guess = next;
        }
        guess
    };
    Ok(utc_secs as f64)
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_time_timezone() -> u64 {
    crate::with_gil_entry!(_py, {
        #[cfg(not(target_arch = "wasm32"))]
        {
            match timezone_native() {
                Ok(val) => MoltObject::from_int(val).bits(),
                Err(msg) => raise_exception::<_>(_py, "OSError", &msg),
            }
        }
        #[cfg(target_arch = "wasm32")]
        {
            match timezone_west_wasm() {
                Ok(val) => MoltObject::from_int(val).bits(),
                Err(msg) => raise_exception::<_>(_py, "OSError", &msg),
            }
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_time_daylight() -> u64 {
    crate::with_gil_entry!(_py, {
        #[cfg(not(target_arch = "wasm32"))]
        {
            match daylight_native() {
                Ok(val) => MoltObject::from_int(val).bits(),
                Err(msg) => raise_exception::<_>(_py, "OSError", &msg),
            }
        }
        #[cfg(target_arch = "wasm32")]
        {
            match daylight_wasm() {
                Ok(val) => MoltObject::from_int(val).bits(),
                Err(msg) => raise_exception::<_>(_py, "OSError", &msg),
            }
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_time_altzone() -> u64 {
    crate::with_gil_entry!(_py, {
        #[cfg(not(target_arch = "wasm32"))]
        {
            match altzone_native() {
                Ok(val) => MoltObject::from_int(val).bits(),
                Err(msg) => raise_exception::<_>(_py, "OSError", &msg),
            }
        }
        #[cfg(target_arch = "wasm32")]
        {
            match altzone_wasm() {
                Ok(val) => MoltObject::from_int(val).bits(),
                Err(msg) => raise_exception::<_>(_py, "OSError", &msg),
            }
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_time_tzname() -> u64 {
    crate::with_gil_entry!(_py, {
        #[cfg(not(target_arch = "wasm32"))]
        {
            let (std_name, dst_name) = match tzname_native() {
                Ok(res) => res,
                Err(msg) => return raise_exception::<_>(_py, "OSError", &msg),
            };
            let std_ptr = alloc_string(_py, std_name.as_bytes());
            if std_ptr.is_null() {
                return MoltObject::none().bits();
            }
            let dst_ptr = alloc_string(_py, dst_name.as_bytes());
            if dst_ptr.is_null() {
                dec_ref_bits(_py, MoltObject::from_ptr(std_ptr).bits());
                return MoltObject::none().bits();
            }
            let std_bits = MoltObject::from_ptr(std_ptr).bits();
            let dst_bits = MoltObject::from_ptr(dst_ptr).bits();
            let tuple_ptr = alloc_tuple(_py, &[std_bits, dst_bits]);
            dec_ref_bits(_py, std_bits);
            dec_ref_bits(_py, dst_bits);
            if tuple_ptr.is_null() {
                MoltObject::none().bits()
            } else {
                MoltObject::from_ptr(tuple_ptr).bits()
            }
        }
        #[cfg(target_arch = "wasm32")]
        {
            let (std_name, dst_name) = match tzname_wasm() {
                Ok(res) => res,
                Err(msg) => return raise_exception::<_>(_py, "OSError", &msg),
            };
            let std_ptr = alloc_string(_py, std_name.as_bytes());
            if std_ptr.is_null() {
                return MoltObject::none().bits();
            }
            let dst_ptr = alloc_string(_py, dst_name.as_bytes());
            if dst_ptr.is_null() {
                dec_ref_bits(_py, MoltObject::from_ptr(std_ptr).bits());
                return MoltObject::none().bits();
            }
            let std_bits = MoltObject::from_ptr(std_ptr).bits();
            let dst_bits = MoltObject::from_ptr(dst_ptr).bits();
            let tuple_ptr = alloc_tuple(_py, &[std_bits, dst_bits]);
            dec_ref_bits(_py, std_bits);
            dec_ref_bits(_py, dst_bits);
            if tuple_ptr.is_null() {
                MoltObject::none().bits()
            } else {
                MoltObject::from_ptr(tuple_ptr).bits()
            }
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_time_asctime(time_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let parts = match parse_time_tuple(_py, time_bits) {
            Ok(parts) => parts,
            Err(bits) => return bits,
        };
        let text = match asctime_from_parts(parts) {
            Ok(text) => text,
            Err(msg) => return raise_exception::<_>(_py, "ValueError", &msg),
        };
        let ptr = alloc_string(_py, text.as_bytes());
        if ptr.is_null() {
            MoltObject::none().bits()
        } else {
            MoltObject::from_ptr(ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_time_mktime(time_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let parts = match parse_mktime_tuple(_py, time_bits) {
            Ok(parts) => parts,
            Err(bits) => return bits,
        };
        #[cfg(not(target_arch = "wasm32"))]
        {
            MoltObject::from_float(mktime_native(parts)).bits()
        }
        #[cfg(target_arch = "wasm32")]
        {
            match mktime_wasm(parts) {
                Ok(out) => MoltObject::from_float(out).bits(),
                Err(msg) => raise_exception::<_>(_py, "OSError", &msg),
            }
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_time_timegm(time_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let (year, month, day, hour, minute, second) = match parse_timegm_tuple(_py, time_bits) {
            Ok(parts) => parts,
            Err(bits) => return bits,
        };
        let days = days_from_civil(year, month, day);
        let seconds = days
            .saturating_mul(86_400)
            .saturating_add((hour as i64).saturating_mul(3600))
            .saturating_add((minute as i64).saturating_mul(60))
            .saturating_add(second as i64);
        MoltObject::from_int(seconds).bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_time_get_clock_info(name_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let Some(name) = string_obj_to_owned(obj_from_bits(name_bits)) else {
            return raise_exception::<_>(_py, "TypeError", "unknown clock");
        };
        let (name_value, implementation, resolution, monotonic, adjustable) = match name.as_str() {
            "monotonic" | "perf_counter" => (name.as_str(), "molt", 1e-9f64, true, false),
            "process_time" => ("process_time", "molt", 1e-9f64, true, false),
            "time" => {
                #[cfg(not(target_arch = "wasm32"))]
                if require_time_wall_capability::<u64>(_py).is_err() {
                    return MoltObject::none().bits();
                }
                ("time", "molt", 1e-6f64, false, true)
            }
            _ => return raise_exception::<_>(_py, "ValueError", "unknown clock"),
        };
        let name_ptr = alloc_string(_py, name_value.as_bytes());
        if name_ptr.is_null() {
            return MoltObject::none().bits();
        }
        let impl_ptr = alloc_string(_py, implementation.as_bytes());
        if impl_ptr.is_null() {
            dec_ref_bits(_py, MoltObject::from_ptr(name_ptr).bits());
            return MoltObject::none().bits();
        }
        let name_bits = MoltObject::from_ptr(name_ptr).bits();
        let impl_bits = MoltObject::from_ptr(impl_ptr).bits();
        let resolution_bits = MoltObject::from_float(resolution).bits();
        let monotonic_bits = MoltObject::from_bool(monotonic).bits();
        let adjustable_bits = MoltObject::from_bool(adjustable).bits();
        let tuple_ptr = alloc_tuple(
            _py,
            &[
                name_bits,
                impl_bits,
                resolution_bits,
                monotonic_bits,
                adjustable_bits,
            ],
        );
        dec_ref_bits(_py, name_bits);
        dec_ref_bits(_py, impl_bits);
        if tuple_ptr.is_null() {
            MoltObject::none().bits()
        } else {
            MoltObject::from_ptr(tuple_ptr).bits()
        }
    })
}

fn traceback_limit_from_bits(_py: &PyToken<'_>, limit_bits: u64) -> Result<Option<usize>, u64> {
    let obj = obj_from_bits(limit_bits);
    if obj.is_none() {
        return Ok(None);
    }
    let Some(limit) = to_i64(obj) else {
        return Err(raise_exception::<_>(
            _py,
            "TypeError",
            "limit must be an integer",
        ));
    };
    if limit < 0 {
        return Ok(Some(0));
    }
    Ok(Some(limit as usize))
}

fn traceback_frames(
    _py: &PyToken<'_>,
    tb_bits: u64,
    limit: Option<usize>,
) -> Vec<(String, i64, String)> {
    if obj_from_bits(tb_bits).is_none() {
        return Vec::new();
    }
    let tb_frame_bits =
        intern_static_name(_py, &runtime_state(_py).interned.tb_frame_name, b"tb_frame");
    let tb_lineno_bits = intern_static_name(
        _py,
        &runtime_state(_py).interned.tb_lineno_name,
        b"tb_lineno",
    );
    let tb_next_bits =
        intern_static_name(_py, &runtime_state(_py).interned.tb_next_name, b"tb_next");
    let f_code_bits = intern_static_name(_py, &runtime_state(_py).interned.f_code_name, b"f_code");
    let f_lineno_bits =
        intern_static_name(_py, &runtime_state(_py).interned.f_lineno_name, b"f_lineno");
    let mut out: Vec<(String, i64, String)> = Vec::new();
    let mut current_bits = tb_bits;
    let mut depth = 0usize;
    while !obj_from_bits(current_bits).is_none() {
        if let Some(max) = limit {
            if out.len() >= max {
                break;
            }
        }
        if depth > 512 {
            break;
        }
        let tb_obj = obj_from_bits(current_bits);
        let Some(tb_ptr) = tb_obj.as_ptr() else {
            break;
        };
        let (frame_bits, line, next_bits, had_tb_fields) = unsafe {
            let dict_bits = instance_dict_bits(tb_ptr);
            let mut frame_bits = MoltObject::none().bits();
            let mut line = 0i64;
            let mut next_bits = MoltObject::none().bits();
            let mut had_tb_fields = false;
            if let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() {
                if object_type_id(dict_ptr) == TYPE_ID_DICT {
                    if let Some(bits) = dict_get_in_place(_py, dict_ptr, tb_frame_bits) {
                        frame_bits = bits;
                        had_tb_fields = true;
                    }
                    if let Some(bits) = dict_get_in_place(_py, dict_ptr, tb_lineno_bits) {
                        if let Some(val) = to_i64(obj_from_bits(bits)) {
                            line = val;
                        }
                        had_tb_fields = true;
                    }
                    if let Some(bits) = dict_get_in_place(_py, dict_ptr, tb_next_bits) {
                        next_bits = bits;
                        had_tb_fields = true;
                    }
                }
            }
            (frame_bits, line, next_bits, had_tb_fields)
        };
        if !had_tb_fields {
            break;
        }
        let (filename, func_name, frame_line) = unsafe {
            let mut filename = "<unknown>".to_string();
            let mut func_name = "<module>".to_string();
            let mut frame_line = line;
            if let Some(frame_ptr) = obj_from_bits(frame_bits).as_ptr() {
                let dict_bits = instance_dict_bits(frame_ptr);
                if let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() {
                    if object_type_id(dict_ptr) == TYPE_ID_DICT {
                        if let Some(bits) = dict_get_in_place(_py, dict_ptr, f_lineno_bits) {
                            if let Some(val) = to_i64(obj_from_bits(bits)) {
                                frame_line = val;
                            }
                        }
                        if let Some(bits) = dict_get_in_place(_py, dict_ptr, f_code_bits) {
                            if let Some(code_ptr) = obj_from_bits(bits).as_ptr() {
                                if object_type_id(code_ptr) == TYPE_ID_CODE {
                                    let filename_bits = code_filename_bits(code_ptr);
                                    if let Some(name) =
                                        string_obj_to_owned(obj_from_bits(filename_bits))
                                    {
                                        filename = name;
                                    }
                                    let name_bits = code_name_bits(code_ptr);
                                    if let Some(name) =
                                        string_obj_to_owned(obj_from_bits(name_bits))
                                    {
                                        if !name.is_empty() {
                                            func_name = name;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            (filename, func_name, frame_line)
        };
        let final_line = if line > 0 { line } else { frame_line };
        out.push((filename, final_line, func_name));
        current_bits = next_bits;
        depth += 1;
    }
    out
}

fn traceback_source_line_native(_py: &PyToken<'_>, filename: &str, lineno: i64) -> String {
    if lineno <= 0 {
        return String::new();
    }
    if !has_capability(_py, "fs.read") {
        return String::new();
    }
    let Ok(file) = std::fs::File::open(filename) else {
        return String::new();
    };
    let reader = BufReader::new(file);
    let target = lineno as usize;
    for (idx, line_result) in reader.lines().enumerate() {
        if idx + 1 == target {
            if let Ok(line) = line_result {
                return line;
            }
            return String::new();
        }
    }
    String::new()
}

fn traceback_line_trim_bounds(line: &str) -> Option<(i64, i64)> {
    if line.is_empty() {
        return None;
    }
    let chars: Vec<char> = line.chars().collect();
    if chars.is_empty() {
        return None;
    }
    let mut start = 0usize;
    while start < chars.len() && chars[start].is_whitespace() {
        start += 1;
    }
    let mut end = chars.len();
    while end > start && chars[end - 1].is_whitespace() {
        end -= 1;
    }
    if end <= start {
        return None;
    }
    Some((start as i64, end as i64))
}

fn traceback_infer_column_offsets(line: &str) -> (i64, i64) {
    if line.is_empty() {
        return (0, 0);
    }
    let chars: Vec<char> = line.chars().collect();
    if chars.is_empty() {
        return (0, 0);
    }
    let mut start = 0usize;
    while start < chars.len() && chars[start].is_whitespace() {
        start += 1;
    }
    if start >= chars.len() {
        return (0, 0);
    }
    let mut end = chars.len();
    while end > start && chars[end - 1].is_whitespace() {
        end -= 1;
    }
    let trimmed: String = chars[start..end].iter().collect();
    let mut highlighted_start = start;
    if let Some(rest) = trimmed
        .strip_prefix("return ")
        .or_else(|| trimmed.strip_prefix("raise "))
        .or_else(|| trimmed.strip_prefix("yield "))
        .or_else(|| trimmed.strip_prefix("await "))
        .or_else(|| trimmed.strip_prefix("assert "))
    {
        highlighted_start = end.saturating_sub(rest.chars().count());
        while highlighted_start < end && chars[highlighted_start].is_whitespace() {
            highlighted_start += 1;
        }
    } else {
        let trimmed_chars: Vec<char> = trimmed.chars().collect();
        for idx in 0..trimmed_chars.len() {
            if trimmed_chars[idx] != '=' {
                continue;
            }
            let prev = if idx > 0 {
                Some(trimmed_chars[idx - 1])
            } else {
                None
            };
            let next = if idx + 1 < trimmed_chars.len() {
                Some(trimmed_chars[idx + 1])
            } else {
                None
            };
            if matches!(prev, Some('=' | '!' | '<' | '>' | ':')) || matches!(next, Some('=')) {
                continue;
            }
            let mut rhs_start = start + idx + 1;
            while rhs_start < end && chars[rhs_start].is_whitespace() {
                rhs_start += 1;
            }
            if rhs_start < end {
                highlighted_start = rhs_start;
            }
            break;
        }
    }
    let col = highlighted_start as i64;
    let end_col = end.max(highlighted_start) as i64;
    if end_col <= col {
        (col, col + 1)
    } else {
        (col, end_col)
    }
}

fn traceback_format_caret_line_native(line: &str, mut colno: i64, mut end_colno: i64) -> String {
    if line.is_empty() || colno < 0 {
        return String::new();
    }
    let text_len = line.chars().count() as i64;
    if text_len <= 0 {
        return String::new();
    }
    if end_colno < colno {
        end_colno = colno;
    }
    if colno > text_len {
        colno = text_len;
    }
    if end_colno > text_len {
        end_colno = text_len;
    }
    let Some((trim_start, trim_end)) = traceback_line_trim_bounds(line) else {
        return String::new();
    };
    if colno < trim_start {
        colno = trim_start;
    }
    if end_colno > trim_end {
        end_colno = trim_end;
    }
    if end_colno <= colno {
        return String::new();
    }
    let width = end_colno - colno;
    let col_usize = colno as usize;
    let mut out = String::with_capacity((4 + colno + width + 1) as usize);
    out.push_str("    ");
    for ch in line.chars().take(col_usize) {
        if ch == '\t' {
            out.push('\t');
        } else {
            out.push(' ');
        }
    }
    for _ in 0..width {
        out.push('^');
    }
    out.push('\n');
    out
}

#[cfg(test)]
mod traceback_format_tests {
    use super::{traceback_format_caret_line_native, traceback_infer_column_offsets};

    #[test]
    fn infer_column_offsets_prefers_rhs_for_assignment() {
        let (col, end_col) = traceback_infer_column_offsets("total = left + right   ");
        assert_eq!(col, 8);
        assert!(end_col > col);
    }

    #[test]
    fn infer_column_offsets_skips_return_keyword() {
        let (col, end_col) = traceback_infer_column_offsets("    return value");
        assert_eq!(col, 11);
        assert_eq!(end_col, 16);
    }

    #[test]
    fn caret_line_preserves_tabs_for_alignment() {
        let line = "\titem = source";
        let caret = traceback_format_caret_line_native(line, 1, 5);
        assert!(caret.starts_with("    \t"));
        assert!(caret.contains("^^^^"));
    }

    #[test]
    fn caret_line_omits_invalid_ranges() {
        let line = "value = source";
        assert!(traceback_format_caret_line_native(line, 0, 0).is_empty());
        assert!(traceback_format_caret_line_native(line, 10, 5).is_empty());
    }
}

fn traceback_format_exception_only_line(
    _py: &PyToken<'_>,
    exc_type_bits: u64,
    value_bits: u64,
) -> String {
    let value_obj = obj_from_bits(value_bits);
    if let Some(exc_ptr) = value_obj.as_ptr() {
        unsafe {
            if object_type_id(exc_ptr) == TYPE_ID_EXCEPTION {
                let mut kind = "Exception".to_string();
                let class_bits = exception_class_bits(exc_ptr);
                if let Some(class_ptr) = obj_from_bits(class_bits).as_ptr() {
                    if object_type_id(class_ptr) == TYPE_ID_TYPE {
                        let name_bits = class_name_bits(class_ptr);
                        if let Some(name) = string_obj_to_owned(obj_from_bits(name_bits)) {
                            kind = name;
                        }
                    }
                }
                let message = format_exception_message(_py, exc_ptr);
                if message.is_empty() {
                    return format!("{kind}\n");
                }
                return format!("{kind}: {message}\n");
            }
        }
    }
    let type_name = if !obj_from_bits(exc_type_bits).is_none() {
        if let Some(tp_ptr) = obj_from_bits(exc_type_bits).as_ptr() {
            unsafe {
                if object_type_id(tp_ptr) == TYPE_ID_TYPE {
                    let name_bits = class_name_bits(tp_ptr);
                    if let Some(name) = string_obj_to_owned(obj_from_bits(name_bits)) {
                        name
                    } else {
                        "Exception".to_string()
                    }
                } else {
                    class_name_for_error(type_of_bits(_py, exc_type_bits))
                }
            }
        } else {
            "Exception".to_string()
        }
    } else if !value_obj.is_none() {
        class_name_for_error(type_of_bits(_py, value_bits))
    } else {
        "Exception".to_string()
    };
    if value_obj.is_none() {
        return format!("{type_name}\n");
    }
    let text = format_obj_str(_py, value_obj);
    if text.is_empty() {
        format!("{type_name}\n")
    } else {
        format!("{type_name}: {text}\n")
    }
}

fn traceback_exception_type_bits(_py: &PyToken<'_>, value_bits: u64) -> u64 {
    if let Some(ptr) = obj_from_bits(value_bits).as_ptr() {
        unsafe {
            if object_type_id(ptr) == TYPE_ID_EXCEPTION {
                return exception_class_bits(ptr);
            }
        }
    }
    if obj_from_bits(value_bits).is_none() {
        MoltObject::none().bits()
    } else {
        type_of_bits(_py, value_bits)
    }
}

fn traceback_exception_trace_bits(value_bits: u64) -> u64 {
    if let Some(ptr) = obj_from_bits(value_bits).as_ptr() {
        unsafe {
            if object_type_id(ptr) == TYPE_ID_EXCEPTION {
                return exception_trace_bits(ptr);
            }
        }
    }
    MoltObject::none().bits()
}

fn traceback_append_exception_single_lines(
    _py: &PyToken<'_>,
    exc_type_bits: u64,
    value_bits: u64,
    tb_bits: u64,
    limit: Option<usize>,
    out: &mut Vec<String>,
) {
    if !obj_from_bits(tb_bits).is_none() {
        out.push("Traceback (most recent call last):\n".to_string());
        let payload = traceback_payload_from_source(_py, tb_bits, limit);
        out.extend(traceback_payload_to_formatted_lines(_py, &payload));
    }
    out.push(traceback_format_exception_only_line(
        _py,
        exc_type_bits,
        value_bits,
    ));
}

#[allow(clippy::too_many_arguments)]
fn traceback_append_exception_chain_lines(
    _py: &PyToken<'_>,
    exc_type_bits: u64,
    value_bits: u64,
    tb_bits: u64,
    limit: Option<usize>,
    chain: bool,
    seen: &mut HashSet<u64>,
    out: &mut Vec<String>,
) {
    if obj_from_bits(value_bits).is_none() || !chain {
        traceback_append_exception_single_lines(
            _py,
            exc_type_bits,
            value_bits,
            tb_bits,
            limit,
            out,
        );
        return;
    }
    if seen.contains(&value_bits) {
        traceback_append_exception_single_lines(
            _py,
            exc_type_bits,
            value_bits,
            tb_bits,
            limit,
            out,
        );
        return;
    }
    seen.insert(value_bits);
    if let Some(ptr) = obj_from_bits(value_bits).as_ptr() {
        unsafe {
            if object_type_id(ptr) == TYPE_ID_EXCEPTION {
                let cause_bits = exception_cause_bits(ptr);
                if !obj_from_bits(cause_bits).is_none() {
                    let cause_type_bits = traceback_exception_type_bits(_py, cause_bits);
                    let cause_tb_bits = traceback_exception_trace_bits(cause_bits);
                    traceback_append_exception_chain_lines(
                        _py,
                        cause_type_bits,
                        cause_bits,
                        cause_tb_bits,
                        limit,
                        chain,
                        seen,
                        out,
                    );
                    out.push(
                        "The above exception was the direct cause of the following exception:\n\n"
                            .to_string(),
                    );
                    traceback_append_exception_single_lines(
                        _py,
                        exc_type_bits,
                        value_bits,
                        tb_bits,
                        limit,
                        out,
                    );
                    return;
                }
                let context_bits = exception_context_bits(ptr);
                let suppress_context = is_truthy(_py, obj_from_bits(exception_suppress_bits(ptr)));
                if !suppress_context && !obj_from_bits(context_bits).is_none() {
                    let context_type_bits = traceback_exception_type_bits(_py, context_bits);
                    let context_tb_bits = traceback_exception_trace_bits(context_bits);
                    traceback_append_exception_chain_lines(
                        _py,
                        context_type_bits,
                        context_bits,
                        context_tb_bits,
                        limit,
                        chain,
                        seen,
                        out,
                    );
                    out.push(
                        "During handling of the above exception, another exception occurred:\n\n"
                            .to_string(),
                    );
                    traceback_append_exception_single_lines(
                        _py,
                        exc_type_bits,
                        value_bits,
                        tb_bits,
                        limit,
                        out,
                    );
                    return;
                }
            }
        }
    }
    traceback_append_exception_single_lines(_py, exc_type_bits, value_bits, tb_bits, limit, out);
}

fn traceback_lines_to_list(_py: &PyToken<'_>, lines: &[String]) -> u64 {
    let mut bits_vec: Vec<u64> = Vec::with_capacity(lines.len());
    for line in lines {
        let ptr = alloc_string(_py, line.as_bytes());
        if ptr.is_null() {
            for bits in bits_vec {
                dec_ref_bits(_py, bits);
            }
            return MoltObject::none().bits();
        }
        bits_vec.push(MoltObject::from_ptr(ptr).bits());
    }
    let list_ptr = alloc_list(_py, bits_vec.as_slice());
    for bits in bits_vec {
        dec_ref_bits(_py, bits);
    }
    if list_ptr.is_null() {
        MoltObject::none().bits()
    } else {
        MoltObject::from_ptr(list_ptr).bits()
    }
}

#[derive(Clone)]
struct TracebackPayloadFrame {
    filename: String,
    lineno: i64,
    end_lineno: i64,
    colno: i64,
    end_colno: i64,
    name: String,
    line: String,
}

#[derive(Clone)]
struct TracebackExceptionChainNode {
    value_bits: u64,
    frames: Vec<TracebackPayloadFrame>,
    suppress_context: bool,
    cause_index: Option<usize>,
    context_index: Option<usize>,
}

fn traceback_split_molt_symbol(name: &str) -> (String, String) {
    if let Some((module_hint, func)) = name.split_once("__") {
        if !module_hint.is_empty() {
            let func_name = if func.is_empty() { name } else { func };
            return (format!("<molt:{module_hint}>"), func_name.to_string());
        }
    }
    ("<molt>".to_string(), name.to_string())
}

fn traceback_payload_from_traceback(
    _py: &PyToken<'_>,
    source_bits: u64,
    limit: Option<usize>,
) -> Vec<TracebackPayloadFrame> {
    let mut out: Vec<TracebackPayloadFrame> = Vec::new();
    for (filename, lineno, name) in traceback_frames(_py, source_bits, limit) {
        let line = traceback_source_line_native(_py, &filename, lineno);
        let (colno, end_colno) = traceback_infer_column_offsets(&line);
        out.push(TracebackPayloadFrame {
            filename,
            lineno,
            end_lineno: lineno,
            colno,
            end_colno,
            name,
            line,
        });
    }
    out
}

fn traceback_payload_from_frame_chain(
    _py: &PyToken<'_>,
    source_bits: u64,
    limit: Option<usize>,
) -> Vec<TracebackPayloadFrame> {
    if obj_from_bits(source_bits).is_none() {
        return Vec::new();
    }
    static F_BACK_NAME: AtomicU64 = AtomicU64::new(0);
    let f_back_name = intern_static_name(_py, &F_BACK_NAME, b"f_back");
    let f_code_name = intern_static_name(_py, &runtime_state(_py).interned.f_code_name, b"f_code");
    let f_lineno_name =
        intern_static_name(_py, &runtime_state(_py).interned.f_lineno_name, b"f_lineno");
    let mut out: Vec<TracebackPayloadFrame> = Vec::new();
    let mut current_bits = source_bits;
    let mut depth = 0usize;
    while !obj_from_bits(current_bits).is_none() {
        if depth > 1024 {
            break;
        }
        let Some(frame_ptr) = obj_from_bits(current_bits).as_ptr() else {
            break;
        };
        let (code_bits, lineno, back_bits, had_frame_fields) = unsafe {
            let dict_bits = instance_dict_bits(frame_ptr);
            let mut code_bits = MoltObject::none().bits();
            let mut lineno = 0i64;
            let mut back_bits = MoltObject::none().bits();
            let mut had_frame_fields = false;
            if let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() {
                if object_type_id(dict_ptr) == TYPE_ID_DICT {
                    if let Some(bits) = dict_get_in_place(_py, dict_ptr, f_code_name) {
                        code_bits = bits;
                        had_frame_fields = true;
                    }
                    if let Some(bits) = dict_get_in_place(_py, dict_ptr, f_lineno_name) {
                        if let Some(value) = to_i64(obj_from_bits(bits)) {
                            lineno = value;
                        }
                        had_frame_fields = true;
                    }
                    if let Some(bits) = dict_get_in_place(_py, dict_ptr, f_back_name) {
                        back_bits = bits;
                        had_frame_fields = true;
                    }
                }
            }
            (code_bits, lineno, back_bits, had_frame_fields)
        };
        if !had_frame_fields {
            break;
        }

        let mut filename = "<unknown>".to_string();
        let mut name = "<module>".to_string();
        if let Some(code_ptr) = obj_from_bits(code_bits).as_ptr() {
            unsafe {
                if object_type_id(code_ptr) == TYPE_ID_CODE {
                    let filename_bits = code_filename_bits(code_ptr);
                    if let Some(value) = string_obj_to_owned(obj_from_bits(filename_bits)) {
                        filename = value;
                    }
                    let name_bits = code_name_bits(code_ptr);
                    if let Some(value) = string_obj_to_owned(obj_from_bits(name_bits)) {
                        if !value.is_empty() {
                            name = value;
                        }
                    }
                }
            }
        }
        let line = traceback_source_line_native(_py, &filename, lineno);
        let (colno, end_colno) = traceback_infer_column_offsets(&line);
        out.push(TracebackPayloadFrame {
            filename,
            lineno,
            end_lineno: lineno,
            colno,
            end_colno,
            name,
            line,
        });
        current_bits = back_bits;
        depth += 1;
    }
    out.reverse();
    if let Some(max) = limit {
        if out.len() > max {
            return out[out.len() - max..].to_vec();
        }
    }
    out
}

fn traceback_payload_from_entry(
    _py: &PyToken<'_>,
    entry_bits: u64,
) -> Option<TracebackPayloadFrame> {
    if obj_from_bits(entry_bits).is_none() {
        return None;
    }
    let entry_obj = obj_from_bits(entry_bits);
    if let Some(entry_ptr) = entry_obj.as_ptr() {
        unsafe {
            let type_id = object_type_id(entry_ptr);
            if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                let elems = seq_vec_ref(entry_ptr);
                if elems.is_empty() {
                    return None;
                }
                if elems.len() == 1 {
                    return traceback_payload_from_entry(_py, elems[0]);
                }
                if elems.len() >= 7 {
                    let filename = format_obj_str(_py, obj_from_bits(elems[0]));
                    let lineno = to_i64(obj_from_bits(elems[1])).unwrap_or(0);
                    let end_lineno = to_i64(obj_from_bits(elems[2])).unwrap_or(lineno);
                    let mut colno = to_i64(obj_from_bits(elems[3])).unwrap_or(0);
                    let mut end_colno = to_i64(obj_from_bits(elems[4])).unwrap_or(colno.max(0));
                    let name = format_obj_str(_py, obj_from_bits(elems[5]));
                    let line = if obj_from_bits(elems[6]).is_none() {
                        String::new()
                    } else {
                        format_obj_str(_py, obj_from_bits(elems[6]))
                    };
                    if !line.is_empty() && (colno < 0 || end_colno <= colno) {
                        let inferred = traceback_infer_column_offsets(&line);
                        colno = inferred.0;
                        end_colno = inferred.1;
                    }
                    return Some(TracebackPayloadFrame {
                        filename,
                        lineno,
                        end_lineno,
                        colno,
                        end_colno,
                        name,
                        line,
                    });
                }
                if elems.len() >= 4 {
                    let filename = format_obj_str(_py, obj_from_bits(elems[0]));
                    let lineno = to_i64(obj_from_bits(elems[1])).unwrap_or(0);
                    let name = format_obj_str(_py, obj_from_bits(elems[2]));
                    let line = if obj_from_bits(elems[3]).is_none() {
                        String::new()
                    } else {
                        format_obj_str(_py, obj_from_bits(elems[3]))
                    };
                    let (colno, end_colno) = traceback_infer_column_offsets(&line);
                    return Some(TracebackPayloadFrame {
                        filename,
                        lineno,
                        end_lineno: lineno,
                        colno,
                        end_colno,
                        name,
                        line,
                    });
                }
                if elems.len() >= 3 {
                    let filename = format_obj_str(_py, obj_from_bits(elems[0]));
                    let lineno = to_i64(obj_from_bits(elems[1])).unwrap_or(0);
                    let name = format_obj_str(_py, obj_from_bits(elems[2]));
                    let line = traceback_source_line_native(_py, &filename, lineno);
                    let (colno, end_colno) = traceback_infer_column_offsets(&line);
                    return Some(TracebackPayloadFrame {
                        filename,
                        lineno,
                        end_lineno: lineno,
                        colno,
                        end_colno,
                        name,
                        line,
                    });
                }
                if elems.len() == 2 {
                    let first_obj = obj_from_bits(elems[0]);
                    let second_obj = obj_from_bits(elems[1]);
                    if let (Some(filename), Some(lineno)) =
                        (string_obj_to_owned(first_obj), to_i64(second_obj))
                    {
                        return Some(TracebackPayloadFrame {
                            filename,
                            lineno,
                            end_lineno: lineno,
                            colno: 0,
                            end_colno: 0,
                            name: "<module>".to_string(),
                            line: String::new(),
                        });
                    }
                    if let (Some(lineno), Some(filename)) =
                        (to_i64(first_obj), string_obj_to_owned(second_obj))
                    {
                        return Some(TracebackPayloadFrame {
                            filename,
                            lineno,
                            end_lineno: lineno,
                            colno: 0,
                            end_colno: 0,
                            name: "<module>".to_string(),
                            line: String::new(),
                        });
                    }
                    if let (Some(symbol), Some(_name)) = (
                        string_obj_to_owned(first_obj),
                        string_obj_to_owned(second_obj),
                    ) {
                        let (filename, name) = traceback_split_molt_symbol(&symbol);
                        return Some(TracebackPayloadFrame {
                            filename,
                            lineno: 0,
                            end_lineno: 0,
                            colno: 0,
                            end_colno: 0,
                            name,
                            line: String::new(),
                        });
                    }
                }
                return None;
            }
            if type_id == TYPE_ID_DICT {
                static FILENAME_NAME: AtomicU64 = AtomicU64::new(0);
                static LINENO_NAME: AtomicU64 = AtomicU64::new(0);
                static NAME_NAME: AtomicU64 = AtomicU64::new(0);
                static LINE_NAME: AtomicU64 = AtomicU64::new(0);
                static END_LINENO_NAME: AtomicU64 = AtomicU64::new(0);
                static COLNO_NAME: AtomicU64 = AtomicU64::new(0);
                static END_COLNO_NAME: AtomicU64 = AtomicU64::new(0);
                let filename_key = intern_static_name(_py, &FILENAME_NAME, b"filename");
                let lineno_key = intern_static_name(_py, &LINENO_NAME, b"lineno");
                let name_key = intern_static_name(_py, &NAME_NAME, b"name");
                let line_key = intern_static_name(_py, &LINE_NAME, b"line");
                let end_lineno_key = intern_static_name(_py, &END_LINENO_NAME, b"end_lineno");
                let colno_key = intern_static_name(_py, &COLNO_NAME, b"colno");
                let end_colno_key = intern_static_name(_py, &END_COLNO_NAME, b"end_colno");
                let filename_bits = dict_get_in_place(_py, entry_ptr, filename_key)?;
                let lineno_bits = dict_get_in_place(_py, entry_ptr, lineno_key)?;
                let filename = format_obj_str(_py, obj_from_bits(filename_bits));
                let lineno = to_i64(obj_from_bits(lineno_bits)).unwrap_or(0);
                let name = dict_get_in_place(_py, entry_ptr, name_key)
                    .map(|bits| format_obj_str(_py, obj_from_bits(bits)))
                    .unwrap_or_else(|| "<module>".to_string());
                let line = dict_get_in_place(_py, entry_ptr, line_key)
                    .map(|bits| format_obj_str(_py, obj_from_bits(bits)))
                    .unwrap_or_else(|| traceback_source_line_native(_py, &filename, lineno));
                let (mut colno, mut end_colno) = traceback_infer_column_offsets(&line);
                if let Some(value) = dict_get_in_place(_py, entry_ptr, colno_key)
                    .and_then(|bits| to_i64(obj_from_bits(bits)))
                {
                    colno = value;
                }
                if let Some(value) = dict_get_in_place(_py, entry_ptr, end_colno_key)
                    .and_then(|bits| to_i64(obj_from_bits(bits)))
                {
                    end_colno = value;
                }
                if !line.is_empty() && (colno < 0 || end_colno <= colno) {
                    let inferred = traceback_infer_column_offsets(&line);
                    colno = inferred.0;
                    end_colno = inferred.1;
                }
                let end_lineno = dict_get_in_place(_py, entry_ptr, end_lineno_key)
                    .and_then(|bits| to_i64(obj_from_bits(bits)))
                    .unwrap_or(lineno);
                return Some(TracebackPayloadFrame {
                    filename,
                    lineno,
                    end_lineno,
                    colno,
                    end_colno,
                    name,
                    line,
                });
            }
        }
    }

    if let Some(value) = string_obj_to_owned(entry_obj) {
        let (filename, name) = traceback_split_molt_symbol(&value);
        return Some(TracebackPayloadFrame {
            filename,
            lineno: 0,
            end_lineno: 0,
            colno: 0,
            end_colno: 0,
            name,
            line: String::new(),
        });
    }

    let mut from_tb = traceback_payload_from_traceback(_py, entry_bits, Some(1));
    if let Some(frame) = from_tb.pop() {
        return Some(frame);
    }
    let mut from_frame = traceback_payload_from_frame_chain(_py, entry_bits, Some(1));
    from_frame.pop()
}

fn traceback_payload_from_entries(
    _py: &PyToken<'_>,
    source_bits: u64,
    limit: Option<usize>,
) -> Vec<TracebackPayloadFrame> {
    let Some(source_ptr) = obj_from_bits(source_bits).as_ptr() else {
        return Vec::new();
    };
    let type_id = unsafe { object_type_id(source_ptr) };
    if type_id != TYPE_ID_LIST && type_id != TYPE_ID_TUPLE {
        return Vec::new();
    }
    let elems: Vec<u64> = unsafe { seq_vec_ref(source_ptr).to_vec() };
    let mut out: Vec<TracebackPayloadFrame> = Vec::new();
    for bits in elems {
        if let Some(frame) = traceback_payload_from_entry(_py, bits) {
            out.push(frame);
            if let Some(max) = limit {
                if out.len() >= max {
                    break;
                }
            }
        }
    }
    out
}

fn traceback_payload_from_source(
    _py: &PyToken<'_>,
    source_bits: u64,
    limit: Option<usize>,
) -> Vec<TracebackPayloadFrame> {
    if obj_from_bits(source_bits).is_none() {
        return Vec::new();
    }
    let from_entries = traceback_payload_from_entries(_py, source_bits, limit);
    if !from_entries.is_empty() {
        return from_entries;
    }
    let from_tb = traceback_payload_from_traceback(_py, source_bits, limit);
    if !from_tb.is_empty() {
        return from_tb;
    }
    let from_frame = traceback_payload_from_frame_chain(_py, source_bits, limit);
    if !from_frame.is_empty() {
        return from_frame;
    }
    if let Some(frame) = traceback_payload_from_entry(_py, source_bits) {
        return vec![frame];
    }
    Vec::new()
}

fn traceback_payload_to_list(_py: &PyToken<'_>, payload: &[TracebackPayloadFrame]) -> u64 {
    let mut tuples: Vec<u64> = Vec::new();
    for frame in payload {
        let filename_ptr = alloc_string(_py, frame.filename.as_bytes());
        if filename_ptr.is_null() {
            for bits in tuples {
                dec_ref_bits(_py, bits);
            }
            return MoltObject::none().bits();
        }
        let name_ptr = alloc_string(_py, frame.name.as_bytes());
        if name_ptr.is_null() {
            dec_ref_bits(_py, MoltObject::from_ptr(filename_ptr).bits());
            for bits in tuples {
                dec_ref_bits(_py, bits);
            }
            return MoltObject::none().bits();
        }
        let line_ptr = alloc_string(_py, frame.line.as_bytes());
        if line_ptr.is_null() {
            dec_ref_bits(_py, MoltObject::from_ptr(filename_ptr).bits());
            dec_ref_bits(_py, MoltObject::from_ptr(name_ptr).bits());
            for bits in tuples {
                dec_ref_bits(_py, bits);
            }
            return MoltObject::none().bits();
        }
        let filename_bits = MoltObject::from_ptr(filename_ptr).bits();
        let lineno_bits = MoltObject::from_int(frame.lineno).bits();
        let end_lineno_bits = MoltObject::from_int(frame.end_lineno).bits();
        let colno_bits = MoltObject::from_int(frame.colno).bits();
        let end_colno_bits = MoltObject::from_int(frame.end_colno).bits();
        let name_bits = MoltObject::from_ptr(name_ptr).bits();
        let line_bits = MoltObject::from_ptr(line_ptr).bits();
        let tuple_ptr = alloc_tuple(
            _py,
            &[
                filename_bits,
                lineno_bits,
                end_lineno_bits,
                colno_bits,
                end_colno_bits,
                name_bits,
                line_bits,
            ],
        );
        dec_ref_bits(_py, filename_bits);
        dec_ref_bits(_py, end_lineno_bits);
        dec_ref_bits(_py, colno_bits);
        dec_ref_bits(_py, end_colno_bits);
        dec_ref_bits(_py, name_bits);
        dec_ref_bits(_py, line_bits);
        if tuple_ptr.is_null() {
            for bits in tuples {
                dec_ref_bits(_py, bits);
            }
            return MoltObject::none().bits();
        }
        tuples.push(MoltObject::from_ptr(tuple_ptr).bits());
    }
    let list_ptr = alloc_list(_py, tuples.as_slice());
    for bits in tuples {
        dec_ref_bits(_py, bits);
    }
    if list_ptr.is_null() {
        MoltObject::none().bits()
    } else {
        MoltObject::from_ptr(list_ptr).bits()
    }
}

fn traceback_payload_frame_source_lines(
    _py: &PyToken<'_>,
    frame: &TracebackPayloadFrame,
) -> Vec<String> {
    let mut lines: Vec<String> = Vec::new();
    let mut first_line = frame.line.clone();
    let mut first_colno = frame.colno;
    let mut first_end_colno = frame.end_colno;
    if first_line.is_empty() {
        first_line = traceback_source_line_native(_py, &frame.filename, frame.lineno);
        if first_line.is_empty() {
            return lines;
        }
        if first_colno < 0 || first_end_colno <= first_colno {
            let (col, end_col) = traceback_infer_column_offsets(&first_line);
            first_colno = col;
            first_end_colno = end_col;
        }
    }

    let span_end = frame.end_lineno.max(frame.lineno);
    if span_end <= frame.lineno || frame.lineno <= 0 || (span_end - frame.lineno) > 64 {
        lines.push(format!("    {}\n", first_line));
        let caret = traceback_format_caret_line_native(&first_line, first_colno, first_end_colno);
        if !caret.is_empty() {
            lines.push(caret);
        }
        return lines;
    }

    for lineno in frame.lineno..=span_end {
        let text = if lineno == frame.lineno {
            first_line.clone()
        } else {
            traceback_source_line_native(_py, &frame.filename, lineno)
        };
        if text.is_empty() {
            continue;
        }
        lines.push(format!("    {}\n", text));

        let text_len = text.chars().count() as i64;
        if text_len <= 0 {
            continue;
        }
        let (trim_start, trim_end) = traceback_line_trim_bounds(&text).unwrap_or((0, text_len));
        let (start, end) = if lineno == frame.lineno {
            let start = if first_colno >= 0 {
                first_colno
            } else {
                trim_start
            };
            let end = if lineno == span_end {
                if first_end_colno > start {
                    first_end_colno
                } else {
                    trim_end
                }
            } else {
                trim_end
            };
            (start, end)
        } else if lineno == span_end {
            let end = if frame.end_colno > trim_start {
                frame.end_colno
            } else {
                trim_end
            };
            (trim_start, end)
        } else {
            (trim_start, trim_end)
        };
        let caret = traceback_format_caret_line_native(&text, start, end);
        if !caret.is_empty() {
            lines.push(caret);
        }
    }

    lines
}

fn traceback_payload_to_formatted_lines(
    _py: &PyToken<'_>,
    payload: &[TracebackPayloadFrame],
) -> Vec<String> {
    let mut lines: Vec<String> = Vec::new();
    for frame in payload {
        lines.push(format!(
            "  File \"{}\", line {}, in {}\n",
            frame.filename, frame.lineno, frame.name
        ));
        lines.extend(traceback_payload_frame_source_lines(_py, frame));
    }
    lines
}

fn traceback_exception_components_payload(
    _py: &PyToken<'_>,
    value_bits: u64,
    limit: Option<usize>,
) -> Result<u64, u64> {
    let Some(value_ptr) = obj_from_bits(value_bits).as_ptr() else {
        return Err(raise_exception::<_>(
            _py,
            "TypeError",
            "value must be an exception instance",
        ));
    };
    unsafe {
        if object_type_id(value_ptr) != TYPE_ID_EXCEPTION {
            return Err(raise_exception::<_>(
                _py,
                "TypeError",
                "value must be an exception instance",
            ));
        }
    }
    let tb_bits = traceback_exception_trace_bits(value_bits);
    let payload = traceback_payload_from_source(_py, tb_bits, limit);
    let frames_bits = traceback_payload_to_list(_py, &payload);
    if obj_from_bits(frames_bits).is_none() {
        return Err(raise_exception::<_>(_py, "MemoryError", "out of memory"));
    }
    let (cause_bits, context_bits, suppress_context) = unsafe {
        let cause = exception_cause_bits(value_ptr);
        let context = exception_context_bits(value_ptr);
        let suppress = is_truthy(_py, obj_from_bits(exception_suppress_bits(value_ptr)));
        (cause, context, suppress)
    };
    if !obj_from_bits(cause_bits).is_none() {
        inc_ref_bits(_py, cause_bits);
    }
    if !obj_from_bits(context_bits).is_none() {
        inc_ref_bits(_py, context_bits);
    }
    let suppress_bits = MoltObject::from_bool(suppress_context).bits();
    let tuple_ptr = alloc_tuple(_py, &[frames_bits, cause_bits, context_bits, suppress_bits]);
    dec_ref_bits(_py, frames_bits);
    if !obj_from_bits(cause_bits).is_none() {
        dec_ref_bits(_py, cause_bits);
    }
    if !obj_from_bits(context_bits).is_none() {
        dec_ref_bits(_py, context_bits);
    }
    if tuple_ptr.is_null() {
        Err(raise_exception::<_>(_py, "MemoryError", "out of memory"))
    } else {
        Ok(MoltObject::from_ptr(tuple_ptr).bits())
    }
}

fn traceback_exception_chain_collect(
    _py: &PyToken<'_>,
    value_bits: u64,
    limit: Option<usize>,
    nodes: &mut Vec<TracebackExceptionChainNode>,
    seen: &mut HashMap<u64, usize>,
    depth: usize,
) -> Result<usize, u64> {
    if depth > 1024 {
        return Err(raise_exception::<_>(
            _py,
            "RuntimeError",
            "traceback exception chain recursion too deep",
        ));
    }
    if let Some(index) = seen.get(&value_bits) {
        return Ok(*index);
    }
    let Some(value_ptr) = obj_from_bits(value_bits).as_ptr() else {
        return Err(raise_exception::<_>(
            _py,
            "TypeError",
            "value must be an exception instance",
        ));
    };
    unsafe {
        if object_type_id(value_ptr) != TYPE_ID_EXCEPTION {
            return Err(raise_exception::<_>(
                _py,
                "TypeError",
                "value must be an exception instance",
            ));
        }
    }
    let tb_bits = traceback_exception_trace_bits(value_bits);
    let frames = traceback_payload_from_source(_py, tb_bits, limit);
    let (cause_bits, context_bits, suppress_context) = unsafe {
        let cause = exception_cause_bits(value_ptr);
        let context = exception_context_bits(value_ptr);
        let suppress = is_truthy(_py, obj_from_bits(exception_suppress_bits(value_ptr)));
        (cause, context, suppress)
    };
    let index = nodes.len();
    seen.insert(value_bits, index);
    nodes.push(TracebackExceptionChainNode {
        value_bits,
        frames,
        suppress_context,
        cause_index: None,
        context_index: None,
    });

    if !obj_from_bits(cause_bits).is_none() {
        let Some(cause_ptr) = obj_from_bits(cause_bits).as_ptr() else {
            return Err(raise_exception::<_>(
                _py,
                "TypeError",
                "exception __cause__ must be an exception instance or None",
            ));
        };
        unsafe {
            if object_type_id(cause_ptr) != TYPE_ID_EXCEPTION {
                return Err(raise_exception::<_>(
                    _py,
                    "TypeError",
                    "exception __cause__ must be an exception instance or None",
                ));
            }
        }
        let cause_index =
            traceback_exception_chain_collect(_py, cause_bits, limit, nodes, seen, depth + 1)?;
        nodes[index].cause_index = Some(cause_index);
    }

    if !suppress_context && !obj_from_bits(context_bits).is_none() {
        let Some(context_ptr) = obj_from_bits(context_bits).as_ptr() else {
            return Err(raise_exception::<_>(
                _py,
                "TypeError",
                "exception __context__ must be an exception instance or None",
            ));
        };
        unsafe {
            if object_type_id(context_ptr) != TYPE_ID_EXCEPTION {
                return Err(raise_exception::<_>(
                    _py,
                    "TypeError",
                    "exception __context__ must be an exception instance or None",
                ));
            }
        }
        let context_index =
            traceback_exception_chain_collect(_py, context_bits, limit, nodes, seen, depth + 1)?;
        nodes[index].context_index = Some(context_index);
    }

    Ok(index)
}

fn traceback_exception_chain_payload_bits(
    _py: &PyToken<'_>,
    value_bits: u64,
    limit: Option<usize>,
) -> Result<u64, u64> {
    let mut nodes: Vec<TracebackExceptionChainNode> = Vec::new();
    let mut seen: HashMap<u64, usize> = HashMap::new();
    traceback_exception_chain_collect(_py, value_bits, limit, &mut nodes, &mut seen, 0)?;

    let mut tuple_bits: Vec<u64> = Vec::with_capacity(nodes.len());
    for node in nodes {
        let frames_bits = traceback_payload_to_list(_py, &node.frames);
        if obj_from_bits(frames_bits).is_none() {
            for bits in tuple_bits {
                dec_ref_bits(_py, bits);
            }
            return Err(raise_exception::<_>(_py, "MemoryError", "out of memory"));
        }
        inc_ref_bits(_py, node.value_bits);
        let suppress_bits = MoltObject::from_bool(node.suppress_context).bits();
        let cause_bits = match node.cause_index {
            Some(index) => int_bits_from_i64(_py, index as i64),
            None => MoltObject::none().bits(),
        };
        let context_bits = match node.context_index {
            Some(index) => int_bits_from_i64(_py, index as i64),
            None => MoltObject::none().bits(),
        };
        let tuple_ptr = alloc_tuple(
            _py,
            &[
                node.value_bits,
                frames_bits,
                suppress_bits,
                cause_bits,
                context_bits,
            ],
        );
        dec_ref_bits(_py, node.value_bits);
        dec_ref_bits(_py, frames_bits);
        if node.cause_index.is_some() {
            dec_ref_bits(_py, cause_bits);
        }
        if node.context_index.is_some() {
            dec_ref_bits(_py, context_bits);
        }
        if tuple_ptr.is_null() {
            for bits in tuple_bits {
                dec_ref_bits(_py, bits);
            }
            return Err(raise_exception::<_>(_py, "MemoryError", "out of memory"));
        }
        tuple_bits.push(MoltObject::from_ptr(tuple_ptr).bits());
    }

    let list_ptr = alloc_list(_py, tuple_bits.as_slice());
    for bits in tuple_bits {
        dec_ref_bits(_py, bits);
    }
    if list_ptr.is_null() {
        Err(raise_exception::<_>(_py, "MemoryError", "out of memory"))
    } else {
        Ok(MoltObject::from_ptr(list_ptr).bits())
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_traceback_payload(source_bits: u64, limit_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let limit = match traceback_limit_from_bits(_py, limit_bits) {
            Ok(limit) => limit,
            Err(bits) => return bits,
        };
        let payload = traceback_payload_from_source(_py, source_bits, limit);
        traceback_payload_to_list(_py, &payload)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_traceback_exception_components(value_bits: u64, limit_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let limit = match traceback_limit_from_bits(_py, limit_bits) {
            Ok(limit) => limit,
            Err(bits) => return bits,
        };
        match traceback_exception_components_payload(_py, value_bits, limit) {
            Ok(bits) => bits,
            Err(err) => err,
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_traceback_exception_chain_payload(value_bits: u64, limit_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let limit = match traceback_limit_from_bits(_py, limit_bits) {
            Ok(limit) => limit,
            Err(bits) => return bits,
        };
        match traceback_exception_chain_payload_bits(_py, value_bits, limit) {
            Ok(bits) => bits,
            Err(err) => err,
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_traceback_source_line(filename_bits: u64, lineno_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let Some(filename) = string_obj_to_owned(obj_from_bits(filename_bits)) else {
            return raise_exception::<_>(_py, "TypeError", "filename must be str");
        };
        let Some(lineno) = to_i64(obj_from_bits(lineno_bits)) else {
            return raise_exception::<_>(_py, "TypeError", "lineno must be int");
        };
        let text = traceback_source_line_native(_py, &filename, lineno);
        let ptr = alloc_string(_py, text.as_bytes());
        if ptr.is_null() {
            MoltObject::none().bits()
        } else {
            MoltObject::from_ptr(ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_traceback_infer_col_offsets(line_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let Some(line) = string_obj_to_owned(obj_from_bits(line_bits)) else {
            return raise_exception::<_>(_py, "TypeError", "line must be str");
        };
        let (colno, end_colno) = traceback_infer_column_offsets(&line);
        let colno_bits = MoltObject::from_int(colno).bits();
        let end_colno_bits = MoltObject::from_int(end_colno).bits();
        let tuple_ptr = alloc_tuple(_py, &[colno_bits, end_colno_bits]);
        dec_ref_bits(_py, colno_bits);
        dec_ref_bits(_py, end_colno_bits);
        if tuple_ptr.is_null() {
            MoltObject::none().bits()
        } else {
            MoltObject::from_ptr(tuple_ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_traceback_format_caret_line(
    line_bits: u64,
    colno_bits: u64,
    end_colno_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let Some(line) = string_obj_to_owned(obj_from_bits(line_bits)) else {
            return raise_exception::<_>(_py, "TypeError", "line must be str");
        };
        let Some(colno) = to_i64(obj_from_bits(colno_bits)) else {
            return raise_exception::<_>(_py, "TypeError", "colno must be int");
        };
        let Some(end_colno) = to_i64(obj_from_bits(end_colno_bits)) else {
            return raise_exception::<_>(_py, "TypeError", "end_colno must be int");
        };
        let out = traceback_format_caret_line_native(&line, colno, end_colno);
        let ptr = alloc_string(_py, out.as_bytes());
        if ptr.is_null() {
            MoltObject::none().bits()
        } else {
            MoltObject::from_ptr(ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_traceback_format_exception_only(exc_type_bits: u64, value_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let line = traceback_format_exception_only_line(_py, exc_type_bits, value_bits);
        traceback_lines_to_list(_py, &[line])
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_traceback_format_exception(
    exc_type_bits: u64,
    value_bits: u64,
    tb_bits: u64,
    limit_bits: u64,
    chain_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let limit = match traceback_limit_from_bits(_py, limit_bits) {
            Ok(limit) => limit,
            Err(bits) => return bits,
        };
        let chain = is_truthy(_py, obj_from_bits(chain_bits));
        let effective_exc_type_bits = if obj_from_bits(exc_type_bits).is_none() {
            traceback_exception_type_bits(_py, value_bits)
        } else {
            exc_type_bits
        };
        let effective_tb_bits = if obj_from_bits(tb_bits).is_none() {
            traceback_exception_trace_bits(value_bits)
        } else {
            tb_bits
        };
        let mut seen: HashSet<u64> = HashSet::new();
        let mut lines: Vec<String> = Vec::new();
        traceback_append_exception_chain_lines(
            _py,
            effective_exc_type_bits,
            value_bits,
            effective_tb_bits,
            limit,
            chain,
            &mut seen,
            &mut lines,
        );
        traceback_lines_to_list(_py, &lines)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_traceback_format_tb(tb_bits: u64, limit_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let limit = match traceback_limit_from_bits(_py, limit_bits) {
            Ok(limit) => limit,
            Err(bits) => return bits,
        };
        let mut lines: Vec<String> = Vec::new();
        for (filename, line, name) in traceback_frames(_py, tb_bits, limit) {
            lines.push(format!("  File \"{filename}\", line {line}, in {name}\n"));
        }
        traceback_lines_to_list(_py, &lines)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_traceback_format_stack(source_bits: u64, limit_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let limit = match traceback_limit_from_bits(_py, limit_bits) {
            Ok(limit) => limit,
            Err(bits) => return bits,
        };
        let payload = traceback_payload_from_source(_py, source_bits, limit);
        let lines = traceback_payload_to_formatted_lines(_py, &payload);
        traceback_lines_to_list(_py, &lines)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_traceback_extract_tb(tb_bits: u64, limit_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let limit = match traceback_limit_from_bits(_py, limit_bits) {
            Ok(limit) => limit,
            Err(bits) => return bits,
        };
        let mut tuples: Vec<u64> = Vec::new();
        for (filename, lineno, name) in traceback_frames(_py, tb_bits, limit) {
            let line_text = traceback_source_line_native(_py, &filename, lineno);
            let (colno, end_colno) = traceback_infer_column_offsets(&line_text);
            let end_lineno = lineno;
            let filename_ptr = alloc_string(_py, filename.as_bytes());
            if filename_ptr.is_null() {
                for bits in tuples {
                    dec_ref_bits(_py, bits);
                }
                return MoltObject::none().bits();
            }
            let name_ptr = alloc_string(_py, name.as_bytes());
            if name_ptr.is_null() {
                dec_ref_bits(_py, MoltObject::from_ptr(filename_ptr).bits());
                for bits in tuples {
                    dec_ref_bits(_py, bits);
                }
                return MoltObject::none().bits();
            }
            let line_ptr = alloc_string(_py, line_text.as_bytes());
            if line_ptr.is_null() {
                dec_ref_bits(_py, MoltObject::from_ptr(filename_ptr).bits());
                dec_ref_bits(_py, MoltObject::from_ptr(name_ptr).bits());
                for bits in tuples {
                    dec_ref_bits(_py, bits);
                }
                return MoltObject::none().bits();
            }
            let filename_bits = MoltObject::from_ptr(filename_ptr).bits();
            let lineno_bits = MoltObject::from_int(lineno).bits();
            let end_lineno_bits = MoltObject::from_int(end_lineno).bits();
            let colno_bits = MoltObject::from_int(colno).bits();
            let end_colno_bits = MoltObject::from_int(end_colno).bits();
            let name_bits = MoltObject::from_ptr(name_ptr).bits();
            let line_bits = MoltObject::from_ptr(line_ptr).bits();
            let tuple_ptr = alloc_tuple(
                _py,
                &[
                    filename_bits,
                    lineno_bits,
                    end_lineno_bits,
                    colno_bits,
                    end_colno_bits,
                    name_bits,
                    line_bits,
                ],
            );
            dec_ref_bits(_py, filename_bits);
            dec_ref_bits(_py, end_lineno_bits);
            dec_ref_bits(_py, colno_bits);
            dec_ref_bits(_py, end_colno_bits);
            dec_ref_bits(_py, name_bits);
            dec_ref_bits(_py, line_bits);
            if tuple_ptr.is_null() {
                for bits in tuples {
                    dec_ref_bits(_py, bits);
                }
                return MoltObject::none().bits();
            }
            tuples.push(MoltObject::from_ptr(tuple_ptr).bits());
        }
        let list_ptr = alloc_list(_py, tuples.as_slice());
        for bits in tuples {
            dec_ref_bits(_py, bits);
        }
        if list_ptr.is_null() {
            MoltObject::none().bits()
        } else {
            MoltObject::from_ptr(list_ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_recursion_guard_enter() -> i64 {
    crate::with_gil_entry!(_py, {
        if recursion_guard_enter() {
            1
        } else {
            raise_exception::<i64>(_py, "RecursionError", "maximum recursion depth exceeded")
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_recursion_guard_exit() {
    crate::with_gil_entry!(_py, {
        recursion_guard_exit();
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_code_slots_init(count: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        if runtime_state(_py).code_slots.get().is_some() {
            return MoltObject::none().bits();
        }
        let Some(count) = usize::try_from(count).ok() else {
            return raise_exception::<_>(_py, "MemoryError", "code slot count too large");
        };
        let slots = (0..count).map(|_| AtomicU64::new(0)).collect();
        let _ = runtime_state(_py).code_slots.set(slots);
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_code_slot_set(code_id: u64, code_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let Some(slots) = runtime_state(_py).code_slots.get() else {
            return raise_exception::<_>(_py, "RuntimeError", "code slots not initialized");
        };
        let Some(idx) = usize::try_from(code_id).ok() else {
            return raise_exception::<_>(_py, "IndexError", "code slot out of range");
        };
        if idx >= slots.len() {
            return raise_exception::<_>(_py, "IndexError", "code slot out of range");
        }
        if let Some(ptr) = obj_from_bits(code_bits).as_ptr() {
            unsafe {
                if object_type_id(ptr) != TYPE_ID_CODE {
                    return raise_exception::<_>(_py, "TypeError", "code slot expects code object");
                }
            }
        } else {
            return raise_exception::<_>(_py, "TypeError", "code slot expects code object");
        }
        if code_bits != 0 {
            inc_ref_bits(_py, code_bits);
        }
        let old_bits = slots[idx].swap(code_bits, AtomicOrdering::AcqRel);
        if old_bits != 0 {
            dec_ref_bits(_py, old_bits);
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_trace_enter(func_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let mut code_bits = MoltObject::none().bits();
        let func_obj = obj_from_bits(func_bits);
        if let Some(func_ptr) = func_obj.as_ptr() {
            unsafe {
                match object_type_id(func_ptr) {
                    TYPE_ID_FUNCTION => {
                        code_bits = ensure_function_code_bits(_py, func_ptr);
                    }
                    TYPE_ID_BOUND_METHOD => {
                        let bound_func_bits = bound_method_func_bits(func_ptr);
                        if let Some(bound_ptr) = obj_from_bits(bound_func_bits).as_ptr() {
                            if object_type_id(bound_ptr) == TYPE_ID_FUNCTION {
                                code_bits = ensure_function_code_bits(_py, bound_ptr);
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
        frame_stack_push(_py, code_bits);
        code_bits
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_trace_enter_slot(code_id: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let Some(slots) = runtime_state(_py).code_slots.get() else {
            return MoltObject::none().bits();
        };
        let Some(idx) = usize::try_from(code_id).ok() else {
            return MoltObject::none().bits();
        };
        let code_bits = if idx < slots.len() {
            slots[idx].load(AtomicOrdering::Acquire)
        } else {
            MoltObject::none().bits()
        };
        frame_stack_push(_py, code_bits);
        code_bits
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_trace_exit() -> u64 {
    crate::with_gil_entry!(_py, {
        frame_stack_pop(_py);
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_trace_set_line(line_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let line_obj = obj_from_bits(line_bits);
        let line = if line_obj.is_int() || line_obj.is_bool() {
            to_i64(line_obj).unwrap_or(0)
        } else {
            line_bits as i64
        };
        frame_stack_set_line(line);
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_repr_builtin(val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, { molt_repr_from_obj(val_bits) })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_format_builtin(val_bits: u64, spec_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(val_bits);
        let spec_obj = obj_from_bits(spec_bits);
        let Some(spec_ptr) = spec_obj.as_ptr() else {
            let msg = format!(
                "format() argument 2 must be str, not {}",
                type_name(_py, spec_obj)
            );
            return raise_exception::<_>(_py, "TypeError", &msg);
        };
        unsafe {
            if object_type_id(spec_ptr) != TYPE_ID_STRING {
                let msg = format!(
                    "format() argument 2 must be str, not {}",
                    type_name(_py, spec_obj)
                );
                return raise_exception::<_>(_py, "TypeError", &msg);
            }
        }
        let spec_text = string_obj_to_owned(spec_obj).unwrap_or_default();
        if let Some(obj_ptr) = obj.as_ptr() {
            unsafe {
                let type_id = object_type_id(obj_ptr);
                if type_id == TYPE_ID_OBJECT || type_id == TYPE_ID_DATACLASS {
                    let class_bits = object_class_bits(obj_ptr);
                    if class_bits != 0 {
                        if let Some(class_ptr) = obj_from_bits(class_bits).as_ptr() {
                            if object_type_id(class_ptr) == TYPE_ID_TYPE {
                                let format_bits = intern_static_name(
                                    _py,
                                    &runtime_state(_py).interned.format_name,
                                    b"__format__",
                                );
                                if let Some(call_bits) = class_attr_lookup(
                                    _py,
                                    class_ptr,
                                    class_ptr,
                                    Some(obj_ptr),
                                    format_bits,
                                ) {
                                    return call_callable1(_py, call_bits, spec_bits);
                                }
                            }
                        }
                    }
                }
            }
        }
        let supports_format = obj.as_int().is_some()
            || obj.as_bool().is_some()
            || obj.as_float().is_some()
            || bigint_ptr_from_bits(obj.bits()).is_some()
            || obj
                .as_ptr()
                .map(|ptr| unsafe { object_type_id(ptr) == TYPE_ID_STRING })
                .unwrap_or(false)
            || obj
                .as_ptr()
                .map(|ptr| unsafe { object_type_id(ptr) == TYPE_ID_COMPLEX })
                .unwrap_or(false);
        if supports_format {
            return molt_string_format(val_bits, spec_bits);
        }
        if spec_text.is_empty() {
            return molt_str_from_obj(val_bits);
        }
        let type_label = type_name(_py, obj);
        let msg = format!("unsupported format string passed to {type_label}.__format__");
        raise_exception::<_>(_py, "TypeError", &msg)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_callable_builtin(val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, { molt_is_callable(val_bits) })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_round_builtin(val_bits: u64, ndigits_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let missing = missing_bits(_py);
        let has_ndigits = ndigits_bits != missing;
        let has_ndigits_bits = MoltObject::from_bool(has_ndigits).bits();
        let ndigits = if has_ndigits {
            ndigits_bits
        } else {
            MoltObject::none().bits()
        };
        molt_round(val_bits, ndigits, has_ndigits_bits)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_enumerate_builtin(iter_bits: u64, start_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let missing = missing_bits(_py);
        let has_start = start_bits != missing;
        let start = if has_start {
            start_bits
        } else {
            MoltObject::from_int(0).bits()
        };
        let has_start_bits = MoltObject::from_bool(has_start).bits();
        molt_enumerate(iter_bits, start, has_start_bits)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_next_builtin(iter_bits: u64, default_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let missing = missing_bits(_py);
        let pair_bits = molt_iter_next(iter_bits);
        let pair_obj = obj_from_bits(pair_bits);
        let Some(pair_ptr) = pair_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "object is not an iterator");
        };
        unsafe {
            if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                return raise_exception::<_>(_py, "TypeError", "object is not an iterator");
            }
            let elems = seq_vec_ref(pair_ptr);
            if elems.len() < 2 {
                return raise_exception::<_>(_py, "TypeError", "object is not an iterator");
            }
            let val_bits = elems[0];
            let done_bits = elems[1];
            if is_truthy(_py, obj_from_bits(done_bits)) {
                if default_bits != missing {
                    inc_ref_bits(_py, default_bits);
                    return default_bits;
                }
                if obj_from_bits(val_bits).is_none() {
                    return raise_exception::<_>(_py, "StopIteration", "");
                }
                let msg_bits = molt_str_from_obj(val_bits);
                let msg = string_obj_to_owned(obj_from_bits(msg_bits)).unwrap_or_default();
                dec_ref_bits(_py, msg_bits);
                return raise_exception::<_>(_py, "StopIteration", &msg);
            }
            inc_ref_bits(_py, val_bits);
            val_bits
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_any_builtin(iter_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let iter_obj = molt_iter(iter_bits);
        if obj_from_bits(iter_obj).is_none() {
            return raise_not_iterable(_py, iter_bits);
        }
        loop {
            let pair_bits = molt_iter_next(iter_obj);
            let pair_obj = obj_from_bits(pair_bits);
            let Some(pair_ptr) = pair_obj.as_ptr() else {
                if exception_pending(_py) {
                    return MoltObject::none().bits();
                }
                return raise_exception::<_>(_py, "TypeError", "object is not an iterator");
            };
            unsafe {
                if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    return raise_exception::<_>(_py, "TypeError", "object is not an iterator");
                }
                let elems = seq_vec_ref(pair_ptr);
                if elems.len() < 2 {
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    return raise_exception::<_>(_py, "TypeError", "object is not an iterator");
                }
                let val_bits = elems[0];
                let done_bits = elems[1];
                if is_truthy(_py, obj_from_bits(done_bits)) {
                    return MoltObject::from_bool(false).bits();
                }
                if is_truthy(_py, obj_from_bits(val_bits)) {
                    return MoltObject::from_bool(true).bits();
                }
            }
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_all_builtin(iter_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let iter_obj = molt_iter(iter_bits);
        if obj_from_bits(iter_obj).is_none() {
            return raise_not_iterable(_py, iter_bits);
        }
        loop {
            let pair_bits = molt_iter_next(iter_obj);
            let pair_obj = obj_from_bits(pair_bits);
            let Some(pair_ptr) = pair_obj.as_ptr() else {
                if exception_pending(_py) {
                    return MoltObject::none().bits();
                }
                return raise_exception::<_>(_py, "TypeError", "object is not an iterator");
            };
            unsafe {
                if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    return raise_exception::<_>(_py, "TypeError", "object is not an iterator");
                }
                let elems = seq_vec_ref(pair_ptr);
                if elems.len() < 2 {
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    return raise_exception::<_>(_py, "TypeError", "object is not an iterator");
                }
                let val_bits = elems[0];
                let done_bits = elems[1];
                if is_truthy(_py, obj_from_bits(done_bits)) {
                    return MoltObject::from_bool(true).bits();
                }
                if !is_truthy(_py, obj_from_bits(val_bits)) {
                    return MoltObject::from_bool(false).bits();
                }
            }
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_abs_builtin(val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(val_bits);
        if let Some(i) = to_i64(obj) {
            return int_bits_from_i128(_py, (i as i128).abs());
        }
        if let Some(big) = to_bigint(obj) {
            let abs_val = big.abs();
            if let Some(i) = bigint_to_inline(&abs_val) {
                return MoltObject::from_int(i).bits();
            }
            return bigint_bits(_py, abs_val);
        }
        if let Some(f) = to_f64(obj) {
            return MoltObject::from_float(f.abs()).bits();
        }
        if let Some(ptr) = complex_ptr_from_bits(val_bits) {
            let value = unsafe { *complex_ref(ptr) };
            return MoltObject::from_float(value.re.hypot(value.im)).bits();
        }
        if let Some(ptr) = maybe_ptr_from_bits(val_bits) {
            if let Some(name_bits) = attr_name_bits_from_bytes(_py, b"__abs__") {
                unsafe {
                    let call_bits = attr_lookup_ptr(_py, ptr, name_bits);
                    dec_ref_bits(_py, name_bits);
                    if let Some(call_bits) = call_bits {
                        let res_bits = call_callable0(_py, call_bits);
                        dec_ref_bits(_py, call_bits);
                        return res_bits;
                    }
                }
            }
        }
        let type_name = class_name_for_error(type_of_bits(_py, val_bits));
        let msg = format!("bad operand type for abs(): '{type_name}'");
        raise_exception::<_>(_py, "TypeError", &msg)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_divmod_builtin(a_bits: u64, b_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let lhs = obj_from_bits(a_bits);
        let rhs = obj_from_bits(b_bits);
        if let (Some(li), Some(ri)) = (to_i64(lhs), to_i64(rhs)) {
            if ri == 0 {
                return raise_exception::<_>(
                    _py,
                    "ZeroDivisionError",
                    "integer division or modulo by zero",
                );
            }
            let li128 = li as i128;
            let ri128 = ri as i128;
            let mut rem = li128 % ri128;
            if rem != 0 && (rem > 0) != (ri128 > 0) {
                rem += ri128;
            }
            let quot = (li128 - rem) / ri128;
            let q_bits = int_bits_from_i128(_py, quot);
            let r_bits = int_bits_from_i128(_py, rem);
            let tuple_ptr = alloc_tuple(_py, &[q_bits, r_bits]);
            if tuple_ptr.is_null() {
                return MoltObject::none().bits();
            }
            return MoltObject::from_ptr(tuple_ptr).bits();
        }
        if let (Some(l_big), Some(r_big)) = (to_bigint(lhs), to_bigint(rhs)) {
            if r_big.is_zero() {
                return raise_exception::<_>(
                    _py,
                    "ZeroDivisionError",
                    "integer division or modulo by zero",
                );
            }
            let quot = l_big.div_floor(&r_big);
            let rem = l_big.mod_floor(&r_big);
            let q_bits = if let Some(i) = bigint_to_inline(&quot) {
                MoltObject::from_int(i).bits()
            } else {
                bigint_bits(_py, quot)
            };
            let r_bits = if let Some(i) = bigint_to_inline(&rem) {
                MoltObject::from_int(i).bits()
            } else {
                bigint_bits(_py, rem)
            };
            let tuple_ptr = alloc_tuple(_py, &[q_bits, r_bits]);
            if tuple_ptr.is_null() {
                return MoltObject::none().bits();
            }
            return MoltObject::from_ptr(tuple_ptr).bits();
        }
        if let Some((lf, rf)) = float_pair_from_obj(_py, lhs, rhs) {
            if rf == 0.0 {
                return raise_exception::<_>(_py, "ZeroDivisionError", "float divmod()");
            }
            let quot = (lf / rf).floor();
            let mut rem = lf % rf;
            if rem != 0.0 && (rem > 0.0) != (rf > 0.0) {
                rem += rf;
            }
            let q_bits = MoltObject::from_float(quot).bits();
            let r_bits = MoltObject::from_float(rem).bits();
            let tuple_ptr = alloc_tuple(_py, &[q_bits, r_bits]);
            if tuple_ptr.is_null() {
                return MoltObject::none().bits();
            }
            return MoltObject::from_ptr(tuple_ptr).bits();
        }
        let left = class_name_for_error(type_of_bits(_py, a_bits));
        let right = class_name_for_error(type_of_bits(_py, b_bits));
        let msg = format!("unsupported operand type(s) for divmod(): '{left}' and '{right}'");
        raise_exception::<_>(_py, "TypeError", &msg)
    })
}

#[inline]
fn minmax_compare(_py: &PyToken<'_>, best_key_bits: u64, cand_key_bits: u64) -> CompareOutcome {
    compare_objects(
        _py,
        obj_from_bits(cand_key_bits),
        obj_from_bits(best_key_bits),
    )
}

fn molt_minmax_builtin(
    _py: &PyToken<'_>,
    args_bits: u64,
    key_bits: u64,
    default_bits: u64,
    want_max: bool,
    name: &str,
) -> u64 {
    let missing = missing_bits(_py);
    let args_obj = obj_from_bits(args_bits);
    let Some(args_ptr) = args_obj.as_ptr() else {
        let msg = format!("{name} expected at least 1 argument, got 0");
        return raise_exception::<_>(_py, "TypeError", &msg);
    };
    unsafe {
        if object_type_id(args_ptr) != TYPE_ID_TUPLE {
            let msg = format!("{name} expected at least 1 argument, got 0");
            return raise_exception::<_>(_py, "TypeError", &msg);
        }
        let args = seq_vec_ref(args_ptr);
        if args.is_empty() {
            let msg = format!("{name} expected at least 1 argument, got 0");
            return raise_exception::<_>(_py, "TypeError", &msg);
        }
        let has_default = default_bits != missing;
        if args.len() > 1 && has_default {
            let msg =
                format!("Cannot specify a default for {name}() with multiple positional arguments");
            return raise_exception::<_>(_py, "TypeError", &msg);
        }
        let use_key = !obj_from_bits(key_bits).is_none();
        let mut best_bits;
        let mut best_key_bits: u64;
        if args.len() == 1 {
            let iter_bits = molt_iter(args[0]);
            if obj_from_bits(iter_bits).is_none() {
                return raise_not_iterable(_py, args[0]);
            }
            let pair_bits = molt_iter_next(iter_bits);
            let pair_obj = obj_from_bits(pair_bits);
            let Some(pair_ptr) = pair_obj.as_ptr() else {
                return raise_exception::<_>(_py, "TypeError", "object is not an iterator");
            };
            if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                return raise_exception::<_>(_py, "TypeError", "object is not an iterator");
            }
            let elems = seq_vec_ref(pair_ptr);
            if elems.len() < 2 {
                return raise_exception::<_>(_py, "TypeError", "object is not an iterator");
            }
            let val_bits = elems[0];
            let done_bits = elems[1];
            if is_truthy(_py, obj_from_bits(done_bits)) {
                if has_default {
                    inc_ref_bits(_py, default_bits);
                    return default_bits;
                }
                let msg = format!("{name}() iterable argument is empty");
                return raise_exception::<_>(_py, "ValueError", &msg);
            }
            best_bits = val_bits;
            if use_key {
                best_key_bits = call_callable1(_py, key_bits, best_bits);
                if exception_pending(_py) {
                    return MoltObject::none().bits();
                }
            } else {
                best_key_bits = best_bits;
            }
            loop {
                let pair_bits = molt_iter_next(iter_bits);
                let pair_obj = obj_from_bits(pair_bits);
                let Some(pair_ptr) = pair_obj.as_ptr() else {
                    return raise_exception::<_>(_py, "TypeError", "object is not an iterator");
                };
                if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                    return raise_exception::<_>(_py, "TypeError", "object is not an iterator");
                }
                let elems = seq_vec_ref(pair_ptr);
                if elems.len() < 2 {
                    return raise_exception::<_>(_py, "TypeError", "object is not an iterator");
                }
                let val_bits = elems[0];
                let done_bits = elems[1];
                if is_truthy(_py, obj_from_bits(done_bits)) {
                    if use_key {
                        dec_ref_bits(_py, best_key_bits);
                    }
                    inc_ref_bits(_py, best_bits);
                    return best_bits;
                }
                let cand_key_bits = if use_key {
                    let res_bits = call_callable1(_py, key_bits, val_bits);
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    res_bits
                } else {
                    val_bits
                };
                let replace = match minmax_compare(_py, best_key_bits, cand_key_bits) {
                    CompareOutcome::Ordered(ordering) => {
                        if want_max {
                            ordering == Ordering::Greater
                        } else {
                            ordering == Ordering::Less
                        }
                    }
                    CompareOutcome::Unordered => false,
                    CompareOutcome::NotComparable => {
                        if use_key {
                            dec_ref_bits(_py, best_key_bits);
                            dec_ref_bits(_py, cand_key_bits);
                        }
                        return compare_type_error(
                            _py,
                            obj_from_bits(cand_key_bits),
                            obj_from_bits(best_key_bits),
                            if want_max { ">" } else { "<" },
                        );
                    }
                    CompareOutcome::Error => {
                        if use_key {
                            dec_ref_bits(_py, best_key_bits);
                            dec_ref_bits(_py, cand_key_bits);
                        }
                        return MoltObject::none().bits();
                    }
                };
                if replace {
                    if use_key {
                        dec_ref_bits(_py, best_key_bits);
                    }
                    best_bits = val_bits;
                    best_key_bits = cand_key_bits;
                } else if use_key {
                    dec_ref_bits(_py, cand_key_bits);
                }
            }
        }
        best_bits = args[0];
        if use_key {
            best_key_bits = call_callable1(_py, key_bits, best_bits);
            if exception_pending(_py) {
                return MoltObject::none().bits();
            }
        } else {
            best_key_bits = best_bits;
        }
        for &val_bits in args.iter().skip(1) {
            let cand_key_bits = if use_key {
                let res_bits = call_callable1(_py, key_bits, val_bits);
                if exception_pending(_py) {
                    return MoltObject::none().bits();
                }
                res_bits
            } else {
                val_bits
            };
            let replace = match minmax_compare(_py, best_key_bits, cand_key_bits) {
                CompareOutcome::Ordered(ordering) => {
                    if want_max {
                        ordering == Ordering::Greater
                    } else {
                        ordering == Ordering::Less
                    }
                }
                CompareOutcome::Unordered => false,
                CompareOutcome::NotComparable => {
                    if use_key {
                        dec_ref_bits(_py, best_key_bits);
                        dec_ref_bits(_py, cand_key_bits);
                    }
                    return compare_type_error(
                        _py,
                        obj_from_bits(cand_key_bits),
                        obj_from_bits(best_key_bits),
                        if want_max { ">" } else { "<" },
                    );
                }
                CompareOutcome::Error => {
                    if use_key {
                        dec_ref_bits(_py, best_key_bits);
                        dec_ref_bits(_py, cand_key_bits);
                    }
                    return MoltObject::none().bits();
                }
            };
            if replace {
                if use_key {
                    dec_ref_bits(_py, best_key_bits);
                }
                best_bits = val_bits;
                best_key_bits = cand_key_bits;
            } else if use_key {
                dec_ref_bits(_py, cand_key_bits);
            }
        }
        if use_key {
            dec_ref_bits(_py, best_key_bits);
        }
        inc_ref_bits(_py, best_bits);
        best_bits
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_min_builtin(args_bits: u64, key_bits: u64, default_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        molt_minmax_builtin(_py, args_bits, key_bits, default_bits, false, "min")
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_max_builtin(args_bits: u64, key_bits: u64, default_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        molt_minmax_builtin(_py, args_bits, key_bits, default_bits, true, "max")
    })
}

pub(crate) unsafe fn map_new_impl(_py: &PyToken<'_>, func_bits: u64, iterables: &[u64]) -> u64 {
    unsafe {
        if iterables.is_empty() {
            return raise_exception::<_>(
                _py,
                "TypeError",
                "map() must have at least two arguments",
            );
        }
        let mut iters = Vec::with_capacity(iterables.len());
        for &iterable_bits in iterables.iter() {
            let iter_bits = molt_iter(iterable_bits);
            if obj_from_bits(iter_bits).is_none() {
                return raise_not_iterable(_py, iterable_bits);
            }
            iters.push(iter_bits);
        }
        let total = std::mem::size_of::<MoltHeader>()
            + std::mem::size_of::<u64>()
            + std::mem::size_of::<*mut Vec<u64>>();
        let map_ptr = alloc_object(_py, total, TYPE_ID_MAP);
        if map_ptr.is_null() {
            for iter_bits in iters {
                dec_ref_bits(_py, iter_bits);
            }
            return MoltObject::none().bits();
        }
        let iters_ptr = Box::into_raw(Box::new(iters));
        *(map_ptr as *mut u64) = func_bits;
        *(map_ptr.add(std::mem::size_of::<u64>()) as *mut *mut Vec<u64>) = iters_ptr;
        inc_ref_bits(_py, func_bits);
        MoltObject::from_ptr(map_ptr).bits()
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_map_builtin(func_bits: u64, iterables_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let iterables_obj = obj_from_bits(iterables_bits);
        let Some(iterables_ptr) = iterables_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "map expects a tuple");
        };
        unsafe {
            if object_type_id(iterables_ptr) != TYPE_ID_TUPLE {
                return raise_exception::<_>(_py, "TypeError", "map expects a tuple");
            }
            let iterables = seq_vec_ref(iterables_ptr);
            map_new_impl(_py, func_bits, iterables.as_slice())
        }
    })
}

pub(crate) unsafe fn filter_new_impl(_py: &PyToken<'_>, func_bits: u64, iterable_bits: u64) -> u64 {
    unsafe {
        let iter_bits = molt_iter(iterable_bits);
        if obj_from_bits(iter_bits).is_none() {
            return raise_not_iterable(_py, iterable_bits);
        }
        let total = std::mem::size_of::<MoltHeader>() + 2 * std::mem::size_of::<u64>();
        let filter_ptr = alloc_object(_py, total, TYPE_ID_FILTER);
        if filter_ptr.is_null() {
            dec_ref_bits(_py, iter_bits);
            return MoltObject::none().bits();
        }
        *(filter_ptr as *mut u64) = func_bits;
        *(filter_ptr.add(std::mem::size_of::<u64>()) as *mut u64) = iter_bits;
        inc_ref_bits(_py, func_bits);
        MoltObject::from_ptr(filter_ptr).bits()
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_filter_builtin(func_bits: u64, iterable_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        unsafe { filter_new_impl(_py, func_bits, iterable_bits) }
    })
}

pub(crate) unsafe fn zip_new_impl(_py: &PyToken<'_>, iterables: &[u64], strict: bool) -> u64 {
    unsafe {
        let strict_bits = MoltObject::from_bool(strict).bits();
        let mut iters = Vec::with_capacity(iterables.len());
        for &iterable_bits in iterables.iter() {
            let iter_bits = molt_iter(iterable_bits);
            if obj_from_bits(iter_bits).is_none() {
                return raise_not_iterable(_py, iterable_bits);
            }
            iters.push(iter_bits);
        }
        let total = std::mem::size_of::<MoltHeader>()
            + std::mem::size_of::<*mut Vec<u64>>()
            + std::mem::size_of::<u64>();
        let zip_ptr = alloc_object(_py, total, TYPE_ID_ZIP);
        if zip_ptr.is_null() {
            for iter_bits in iters {
                dec_ref_bits(_py, iter_bits);
            }
            return MoltObject::none().bits();
        }
        let iters_ptr = Box::into_raw(Box::new(iters));
        *(zip_ptr as *mut *mut Vec<u64>) = iters_ptr;
        zip_set_strict_bits(zip_ptr, strict_bits);
        inc_ref_bits(_py, strict_bits);
        MoltObject::from_ptr(zip_ptr).bits()
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_zip_builtin(iterables_bits: u64, strict_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let strict = is_truthy(_py, obj_from_bits(strict_bits));
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        let strict_bits = MoltObject::from_bool(strict).bits();
        let iterables_obj = obj_from_bits(iterables_bits);
        let Some(iterables_ptr) = iterables_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "zip expects a tuple");
        };
        unsafe {
            if object_type_id(iterables_ptr) != TYPE_ID_TUPLE {
                return raise_exception::<_>(_py, "TypeError", "zip expects a tuple");
            }
            let iterables = seq_vec_ref(iterables_ptr);
            zip_new_impl(_py, iterables.as_slice(), strict)
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_reversed_builtin(seq_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, { unsafe { reversed_new_impl(_py, seq_bits) } })
}

pub(crate) unsafe fn reversed_new_impl(_py: &PyToken<'_>, seq_bits: u64) -> u64 {
    unsafe {
        let obj = obj_from_bits(seq_bits);
        if let Some(ptr) = obj.as_ptr() {
            let type_id = object_type_id(ptr);
            if type_id == TYPE_ID_RANGE {
                let Some((start, stop, step)) = range_components_bigint(ptr) else {
                    return MoltObject::none().bits();
                };
                if step.is_zero() {
                    return MoltObject::none().bits();
                }
                let len = range_len_bigint(&start, &stop, &step);
                let rev_bits = if len.is_zero() {
                    alloc_range_from_bigints(_py, start.clone(), start.clone(), BigInt::from(1))
                } else {
                    let last = &start + &step * (&len - 1);
                    let rev_start = last;
                    let rev_stop = &start - &step;
                    let rev_step = -step;
                    alloc_range_from_bigints(_py, rev_start, rev_stop, rev_step)
                };
                if obj_from_bits(rev_bits).is_none() {
                    return MoltObject::none().bits();
                }
                let iter_bits = molt_iter(rev_bits);
                dec_ref_bits(_py, rev_bits);
                return iter_bits;
            }
            if let Some(dict_bits) = dict_like_bits_from_ptr(_py, ptr) {
                let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() else {
                    return MoltObject::none().bits();
                };
                let idx = dict_len(dict_ptr);
                let total = std::mem::size_of::<MoltHeader>()
                    + std::mem::size_of::<u64>()
                    + std::mem::size_of::<usize>();
                let rev_ptr = alloc_object(_py, total, TYPE_ID_REVERSED);
                if rev_ptr.is_null() {
                    return MoltObject::none().bits();
                }
                inc_ref_bits(_py, dict_bits);
                *(rev_ptr as *mut u64) = dict_bits;
                reversed_set_index(rev_ptr, idx);
                return MoltObject::from_ptr(rev_ptr).bits();
            }
            if type_id == TYPE_ID_LIST
                || type_id == TYPE_ID_TUPLE
                || type_id == TYPE_ID_STRING
                || type_id == TYPE_ID_BYTES
                || type_id == TYPE_ID_BYTEARRAY
                || type_id == TYPE_ID_DICT
                || type_id == TYPE_ID_DICT_KEYS_VIEW
                || type_id == TYPE_ID_DICT_VALUES_VIEW
                || type_id == TYPE_ID_DICT_ITEMS_VIEW
            {
                let idx = if type_id == TYPE_ID_STRING {
                    string_len(ptr)
                } else if type_id == TYPE_ID_BYTES || type_id == TYPE_ID_BYTEARRAY {
                    bytes_len(ptr)
                } else if type_id == TYPE_ID_DICT {
                    dict_order(ptr).len() / 2
                } else if type_id == TYPE_ID_DICT_KEYS_VIEW
                    || type_id == TYPE_ID_DICT_VALUES_VIEW
                    || type_id == TYPE_ID_DICT_ITEMS_VIEW
                {
                    dict_view_len(ptr)
                } else if type_id == TYPE_ID_LIST {
                    list_len(ptr)
                } else {
                    tuple_len(ptr)
                };
                let total = std::mem::size_of::<MoltHeader>()
                    + std::mem::size_of::<u64>()
                    + std::mem::size_of::<usize>();
                let rev_ptr = alloc_object(_py, total, TYPE_ID_REVERSED);
                if rev_ptr.is_null() {
                    return MoltObject::none().bits();
                }
                inc_ref_bits(_py, seq_bits);
                *(rev_ptr as *mut u64) = seq_bits;
                reversed_set_index(rev_ptr, idx);
                return MoltObject::from_ptr(rev_ptr).bits();
            }
            if let Some(name_bits) = attr_name_bits_from_bytes(_py, b"__reversed__") {
                if let Some(call_bits) = attr_lookup_ptr(_py, ptr, name_bits) {
                    dec_ref_bits(_py, name_bits);
                    let res = call_callable0(_py, call_bits);
                    dec_ref_bits(_py, call_bits);
                    return res;
                }
                dec_ref_bits(_py, name_bits);
            }
        }
        let msg = format!("'{}' object is not reversible", type_name(_py, obj));
        raise_exception::<_>(_py, "TypeError", &msg)
    }
}

struct SortItem {
    key_bits: u64,
    value_bits: u64,
}

enum SortError {
    NotComparable(u64, u64),
    Exception,
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_sorted_builtin(iter_bits: u64, key_bits: u64, reverse_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let iter_obj = molt_iter(iter_bits);
        if obj_from_bits(iter_obj).is_none() {
            return raise_not_iterable(_py, iter_bits);
        }
        let use_key = !obj_from_bits(key_bits).is_none();
        let reverse = is_truthy(_py, obj_from_bits(reverse_bits));
        let mut items: Vec<SortItem> = Vec::new();
        loop {
            let pair_bits = molt_iter_next(iter_obj);
            let pair_obj = obj_from_bits(pair_bits);
            let Some(pair_ptr) = pair_obj.as_ptr() else {
                if use_key {
                    for item in items.drain(..) {
                        dec_ref_bits(_py, item.key_bits);
                    }
                }
                return MoltObject::none().bits();
            };
            unsafe {
                if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                    if use_key {
                        for item in items.drain(..) {
                            dec_ref_bits(_py, item.key_bits);
                        }
                    }
                    return raise_exception::<_>(_py, "TypeError", "object is not an iterator");
                }
                let elems = seq_vec_ref(pair_ptr);
                if elems.len() < 2 {
                    if use_key {
                        for item in items.drain(..) {
                            dec_ref_bits(_py, item.key_bits);
                        }
                    }
                    return raise_exception::<_>(_py, "TypeError", "object is not an iterator");
                }
                let val_bits = elems[0];
                let done_bits = elems[1];
                if is_truthy(_py, obj_from_bits(done_bits)) {
                    break;
                }
                let key_val_bits = if use_key {
                    let res_bits = call_callable1(_py, key_bits, val_bits);
                    if exception_pending(_py) {
                        for item in items.drain(..) {
                            dec_ref_bits(_py, item.key_bits);
                        }
                        return MoltObject::none().bits();
                    }
                    res_bits
                } else {
                    val_bits
                };
                items.push(SortItem {
                    key_bits: key_val_bits,
                    value_bits: val_bits,
                });
            }
        }
        let mut error: Option<SortError> = None;
        items.sort_by(|left, right| {
            if error.is_some() {
                return Ordering::Equal;
            }
            let outcome = compare_objects(
                _py,
                obj_from_bits(left.key_bits),
                obj_from_bits(right.key_bits),
            );
            match outcome {
                CompareOutcome::Ordered(ordering) => {
                    if reverse {
                        ordering.reverse()
                    } else {
                        ordering
                    }
                }
                CompareOutcome::Unordered => Ordering::Equal,
                CompareOutcome::NotComparable => {
                    error = Some(SortError::NotComparable(left.key_bits, right.key_bits));
                    Ordering::Equal
                }
                CompareOutcome::Error => {
                    error = Some(SortError::Exception);
                    Ordering::Equal
                }
            }
        });
        if let Some(error) = error {
            if use_key {
                for item in items.drain(..) {
                    dec_ref_bits(_py, item.key_bits);
                }
            }
            match error {
                SortError::NotComparable(left_bits, right_bits) => {
                    let msg = format!(
                        "'<' not supported between instances of '{}' and '{}'",
                        type_name(_py, obj_from_bits(left_bits)),
                        type_name(_py, obj_from_bits(right_bits)),
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
                SortError::Exception => {
                    return MoltObject::none().bits();
                }
            }
        }
        let mut out: Vec<u64> = Vec::with_capacity(items.len());
        for item in items.iter() {
            out.push(item.value_bits);
        }
        if use_key {
            for item in items.drain(..) {
                dec_ref_bits(_py, item.key_bits);
            }
        }
        let list_ptr = alloc_list(_py, &out);
        if list_ptr.is_null() {
            return MoltObject::none().bits();
        }
        MoltObject::from_ptr(list_ptr).bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_sum_builtin(iter_bits: u64, start_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let start_obj = obj_from_bits(start_bits);
        if let Some(ptr) = start_obj.as_ptr() {
            unsafe {
                let type_id = object_type_id(ptr);
                if type_id == TYPE_ID_STRING {
                    return raise_exception::<_>(
                        _py,
                        "TypeError",
                        "sum() can't sum strings [use ''.join(seq) instead]",
                    );
                }
                if type_id == TYPE_ID_BYTES {
                    return raise_exception::<_>(
                        _py,
                        "TypeError",
                        "sum() can't sum bytes [use b''.join(seq) instead]",
                    );
                }
                if type_id == TYPE_ID_BYTEARRAY {
                    return raise_exception::<_>(
                        _py,
                        "TypeError",
                        "sum() can't sum bytearray [use b''.join(seq) instead]",
                    );
                }
            }
        }
        let iter_obj = molt_iter(iter_bits);
        if obj_from_bits(iter_obj).is_none() {
            return raise_not_iterable(_py, iter_bits);
        }
        let mut total_bits = start_bits;
        let mut total_owned = false;
        loop {
            let pair_bits = molt_iter_next(iter_obj);
            let pair_obj = obj_from_bits(pair_bits);
            let Some(pair_ptr) = pair_obj.as_ptr() else {
                return raise_exception::<_>(_py, "TypeError", "object is not an iterator");
            };
            unsafe {
                if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                    return raise_exception::<_>(_py, "TypeError", "object is not an iterator");
                }
                let elems = seq_vec_ref(pair_ptr);
                if elems.len() < 2 {
                    return raise_exception::<_>(_py, "TypeError", "object is not an iterator");
                }
                let val_bits = elems[0];
                let done_bits = elems[1];
                if is_truthy(_py, obj_from_bits(done_bits)) {
                    if !total_owned {
                        inc_ref_bits(_py, total_bits);
                    }
                    return total_bits;
                }
                let next_bits = molt_add(total_bits, val_bits);
                if obj_from_bits(next_bits).is_none() {
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    return binary_type_error(
                        _py,
                        obj_from_bits(total_bits),
                        obj_from_bits(val_bits),
                        "+",
                    );
                }
                total_bits = next_bits;
                total_owned = true;
            }
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_getattr_builtin(obj_bits: u64, name_bits: u64, default_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let missing = missing_bits(_py);
        if default_bits == missing {
            return molt_get_attr_name(obj_bits, name_bits);
        }
        molt_get_attr_name_default(obj_bits, name_bits, default_bits)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_vars_builtin(obj_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let missing = missing_bits(_py);
        if obj_bits == missing {
            // CPython parity: vars() == locals() when called with no arguments.
            // Note: `molt_locals_builtin` is safe to call here; `with_gil_entry` is
            // re-entrant and uses the existing token.
            return crate::molt_locals_builtin();
        }
        let dict_name_bits =
            intern_static_name(_py, &runtime_state(_py).interned.dict_name, b"__dict__");
        let dict_bits = molt_get_attr_name_default(obj_bits, dict_name_bits, missing);
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        if dict_bits == missing {
            return raise_exception::<_>(
                _py,
                "TypeError",
                "vars() argument must have __dict__ attribute",
            );
        }
        dict_bits
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_object_getstate(_self_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, { MoltObject::none().bits() })
}

unsafe fn dir_default_collect(_py: &PyToken<'_>, obj_bits: u64) -> u64 {
    unsafe {
        crate::gil_assert();

        let mut names: Vec<u64> = Vec::new();
        let mut seen: HashSet<String> = HashSet::new();
        let mut extra_owned: Vec<u64> = Vec::new();

        if let Some(obj_ptr) = maybe_ptr_from_bits(obj_bits) {
            let type_id = object_type_id(obj_ptr);
            if type_id == TYPE_ID_TYPE {
                dir_collect_from_class_bits(obj_bits, &mut seen, &mut names);
            } else {
                dir_collect_from_instance(_py, obj_ptr, &mut seen, &mut names);
                dir_collect_from_class_bits(type_of_bits(_py, obj_bits), &mut seen, &mut names);
            }
        } else {
            dir_collect_from_class_bits(type_of_bits(_py, obj_bits), &mut seen, &mut names);
        }

        // Our runtime keeps many builtin methods in fast method caches rather than in
        // `type.__dict__`. CPython's dir() includes those names, so ensure they're visible.
        let mut add_name = |name: &[u8]| -> bool {
            let Ok(name_str) = std::str::from_utf8(name) else {
                return true;
            };
            if !seen.insert(name_str.to_string()) {
                return true;
            }
            let Some(bits) = attr_name_bits_from_bytes(_py, name) else {
                return false;
            };
            extra_owned.push(bits);
            names.push(bits);
            true
        };

        // Object surface (ordering-critical names appear early in CPython's sorted dir()).
        for name in [
            &b"__class__"[..],
            &b"__delattr__"[..],
            &b"__dir__"[..],
            &b"__doc__"[..],
            &b"__eq__"[..],
            &b"__format__"[..],
            &b"__ge__"[..],
            &b"__getattribute__"[..],
            &b"__getstate__"[..],
            &b"__gt__"[..],
            &b"__hash__"[..],
            &b"__init__"[..],
            &b"__init_subclass__"[..],
            &b"__le__"[..],
            &b"__lt__"[..],
            &b"__ne__"[..],
            &b"__new__"[..],
            &b"__repr__"[..],
            &b"__setattr__"[..],
            &b"__str__"[..],
        ] {
            if !add_name(name) {
                for owned in extra_owned {
                    dec_ref_bits(_py, owned);
                }
                return MoltObject::none().bits();
            }
        }

        let builtins = builtin_classes(_py);
        let target_class_bits = if maybe_ptr_from_bits(obj_bits)
            .is_some_and(|ptr| unsafe { object_type_id(ptr) == TYPE_ID_TYPE })
        {
            obj_bits
        } else {
            type_of_bits(_py, obj_bits)
        };

        if target_class_bits == builtins.int || target_class_bits == builtins.bool {
            for name in [
                &b"__abs__"[..],
                &b"__add__"[..],
                &b"__and__"[..],
                &b"__bool__"[..],
                &b"__ceil__"[..],
                &b"__divmod__"[..],
            ] {
                if !add_name(name) {
                    for owned in extra_owned {
                        dec_ref_bits(_py, owned);
                    }
                    return MoltObject::none().bits();
                }
            }
        } else if target_class_bits == builtins.str {
            for name in [&b"__add__"[..], &b"__contains__"[..], &b"__getitem__"[..]] {
                if !add_name(name) {
                    for owned in extra_owned {
                        dec_ref_bits(_py, owned);
                    }
                    return MoltObject::none().bits();
                }
            }
        } else if target_class_bits == builtins.list {
            for name in [
                &b"__add__"[..],
                &b"__class_getitem__"[..],
                &b"__contains__"[..],
                &b"__delitem__"[..],
            ] {
                if !add_name(name) {
                    for owned in extra_owned {
                        dec_ref_bits(_py, owned);
                    }
                    return MoltObject::none().bits();
                }
            }
        } else if target_class_bits == builtins.dict {
            for name in [
                &b"__class_getitem__"[..],
                &b"__contains__"[..],
                &b"__delitem__"[..],
                &b"__getitem__"[..],
            ] {
                if !add_name(name) {
                    for owned in extra_owned {
                        dec_ref_bits(_py, owned);
                    }
                    return MoltObject::none().bits();
                }
            }
        } else if target_class_bits == builtins.none_type {
            if !add_name(&b"__bool__"[..]) {
                for owned in extra_owned {
                    dec_ref_bits(_py, owned);
                }
                return MoltObject::none().bits();
            }
        }

        // Hide names that CPython deliberately excludes from dir() output (even though the
        // attributes exist).
        let hide_module = is_builtin_class_bits(_py, target_class_bits);
        names.retain(|&bits| {
            let Some(name) = string_obj_to_owned(obj_from_bits(bits)) else {
                return true;
            };
            if name == "__mro__" || name == "__bases__" || name == "__text_signature__" {
                return false;
            }
            if name.starts_with("__molt_") {
                return false;
            }
            if hide_module && name == "__module__" {
                return false;
            }
            true
        });

        let list_ptr = alloc_list(_py, &names);
        for owned in extra_owned {
            dec_ref_bits(_py, owned);
        }
        if list_ptr.is_null() {
            return MoltObject::none().bits();
        }
        let list_bits = MoltObject::from_ptr(list_ptr).bits();
        let none_bits = MoltObject::none().bits();
        let reverse_bits = MoltObject::from_int(0).bits();
        let _ = molt_list_sort(list_bits, none_bits, reverse_bits);
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        list_bits
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_object_dir_method(self_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, { unsafe { dir_default_collect(_py, self_bits) } })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_object_format_method(self_bits: u64, spec_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let spec_obj = obj_from_bits(spec_bits);
        let Some(spec) = string_obj_to_owned(spec_obj) else {
            return raise_exception::<_>(_py, "TypeError", "format_spec must be str");
        };
        if spec.is_empty() {
            return molt_str_from_obj(self_bits);
        }
        let type_label = type_name(_py, obj_from_bits(self_bits));
        let msg = format!("unsupported format string passed to {type_label}.__format__");
        raise_exception::<_>(_py, "TypeError", &msg)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_object_lt_method(_self_bits: u64, _other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, { not_implemented_bits(_py) })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_object_le_method(_self_bits: u64, _other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, { not_implemented_bits(_py) })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_object_gt_method(_self_bits: u64, _other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, { not_implemented_bits(_py) })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_object_ge_method(_self_bits: u64, _other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, { not_implemented_bits(_py) })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_int_bool_method(self_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        MoltObject::from_bool(is_truthy(_py, obj_from_bits(self_bits))).bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_int_ceil_method(self_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        inc_ref_bits(_py, self_bits);
        self_bits
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_int_abs_method(self_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, { molt_abs_builtin(self_bits) })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_int_add_method(self_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let builtins = builtin_classes(_py);
        let other_ty = type_of_bits(_py, other_bits);
        if other_ty != builtins.int && other_ty != builtins.bool {
            return not_implemented_bits(_py);
        }
        molt_add(self_bits, other_bits)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_int_and_method(self_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let builtins = builtin_classes(_py);
        let other_ty = type_of_bits(_py, other_bits);
        if other_ty != builtins.int && other_ty != builtins.bool {
            return not_implemented_bits(_py);
        }
        molt_bit_and(self_bits, other_bits)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_int_divmod_method(self_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let builtins = builtin_classes(_py);
        let other_ty = type_of_bits(_py, other_bits);
        if other_ty != builtins.int && other_ty != builtins.bool {
            return not_implemented_bits(_py);
        }
        molt_divmod_builtin(self_bits, other_bits)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_str_add_method(self_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let builtins = builtin_classes(_py);
        let other_ty = type_of_bits(_py, other_bits);
        if other_ty != builtins.str {
            return not_implemented_bits(_py);
        }
        molt_add(self_bits, other_bits)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_dir_builtin(obj_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let missing = missing_bits(_py);
        if obj_bits == missing {
            // CPython: dir() (no args) lists the caller's local scope.
            unsafe {
                // Note: `molt_locals_builtin` is safe to call here; `with_gil_entry` is
                // re-entrant and many runtime helpers rely on nested calls.
                let locals_bits = crate::molt_locals_builtin();
                if exception_pending(_py) {
                    if !obj_from_bits(locals_bits).is_none() {
                        dec_ref_bits(_py, locals_bits);
                    }
                    return MoltObject::none().bits();
                }
                let list_bits = list_from_iter_bits(_py, locals_bits)
                    .unwrap_or_else(|| MoltObject::none().bits());
                if !obj_from_bits(locals_bits).is_none() {
                    dec_ref_bits(_py, locals_bits);
                }
                if obj_from_bits(list_bits).is_none() || exception_pending(_py) {
                    return MoltObject::none().bits();
                }
                let none_bits = MoltObject::none().bits();
                let reverse_bits = MoltObject::from_int(0).bits();
                let _ = molt_list_sort(list_bits, none_bits, reverse_bits);
                if exception_pending(_py) {
                    return MoltObject::none().bits();
                }
                return list_bits;
            }
        }

        let mut names: Vec<u64> = Vec::new();
        let mut seen: HashSet<String> = HashSet::new();
        let mut extra_owned: Vec<u64> = Vec::new();
        let _obj = obj_from_bits(obj_bits);
        if let Some(obj_ptr) = maybe_ptr_from_bits(obj_bits) {
            unsafe {
                // CPython's dir() respects user-defined `__dir__`, but it must *not* dispatch
                // to our internal fast-path method-cache implementation (which would recurse
                // back into this builtin).
                //
                // So: only consult instance `__dict__` and the class `__dict__` MRO chain,
                // skipping method caches entirely.
                static DIR_NAME: std::sync::atomic::AtomicU64 =
                    std::sync::atomic::AtomicU64::new(0);
                let dir_name_bits = intern_static_name(_py, &DIR_NAME, b"__dir__");
                let mut override_bits: u64 = 0;

                let dict_bits = instance_dict_bits(obj_ptr);
                if dict_bits != 0 && !obj_from_bits(dict_bits).is_none() {
                    if let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() {
                        if object_type_id(dict_ptr) == TYPE_ID_DICT {
                            if let Some(val_bits) = dict_get_in_place(_py, dict_ptr, dir_name_bits)
                            {
                                inc_ref_bits(_py, val_bits);
                                override_bits = val_bits;
                            }
                        }
                    }
                }

                if override_bits == 0 {
                    let class_bits = type_of_bits(_py, obj_bits);
                    if let Some(class_ptr) = obj_from_bits(class_bits).as_ptr() {
                        if let Some(attr_bits) =
                            class_attr_lookup_raw_mro(_py, class_ptr, dir_name_bits)
                        {
                            let bound_opt =
                                descriptor_bind(_py, attr_bits, class_ptr, Some(obj_ptr));
                            dec_ref_bits(_py, attr_bits);

                            if exception_pending(_py) {
                                // `descriptor_bind` can create a temporary bound object; avoid leaks.
                                if let Some(bound_bits) = bound_opt {
                                    if !obj_from_bits(bound_bits).is_none() {
                                        dec_ref_bits(_py, bound_bits);
                                    }
                                }
                                return MoltObject::none().bits();
                            }

                            if let Some(bound_bits) = bound_opt {
                                override_bits = bound_bits;
                            }
                        }
                    }
                }

                if override_bits != 0 && !obj_from_bits(override_bits).is_none() {
                    let res_bits = call_callable0(_py, override_bits);
                    dec_ref_bits(_py, override_bits);
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    return res_bits;
                }
                let type_id = object_type_id(obj_ptr);
                if type_id == TYPE_ID_TYPE {
                    dir_collect_from_class_bits(obj_bits, &mut seen, &mut names);
                } else {
                    dir_collect_from_instance(_py, obj_ptr, &mut seen, &mut names);
                    dir_collect_from_class_bits(type_of_bits(_py, obj_bits), &mut seen, &mut names);
                }
            }
        } else {
            unsafe {
                dir_collect_from_class_bits(type_of_bits(_py, obj_bits), &mut seen, &mut names);
            }
        }

        // Our runtime keeps many builtin methods in fast method caches rather than in
        // `type.__dict__`. CPython's dir() includes those names, so ensure they're visible.
        let mut add_name = |name: &[u8]| -> bool {
            let Ok(name_str) = std::str::from_utf8(name) else {
                return true;
            };
            if !seen.insert(name_str.to_string()) {
                return true;
            }
            unsafe {
                let Some(bits) = attr_name_bits_from_bytes(_py, name) else {
                    return false;
                };
                extra_owned.push(bits);
                names.push(bits);
            }
            true
        };

        // Object surface (ordering-critical names appear early in CPython's sorted dir()).
        for name in [
            &b"__class__"[..],
            &b"__delattr__"[..],
            &b"__dir__"[..],
            &b"__doc__"[..],
            &b"__eq__"[..],
            &b"__format__"[..],
            &b"__ge__"[..],
            &b"__getattribute__"[..],
            &b"__getstate__"[..],
            &b"__gt__"[..],
            &b"__hash__"[..],
            &b"__init__"[..],
            &b"__init_subclass__"[..],
            &b"__le__"[..],
            &b"__lt__"[..],
            &b"__ne__"[..],
            &b"__new__"[..],
            &b"__repr__"[..],
            &b"__setattr__"[..],
            &b"__str__"[..],
        ] {
            if !add_name(name) {
                for owned in extra_owned {
                    dec_ref_bits(_py, owned);
                }
                return MoltObject::none().bits();
            }
        }

        let builtins = builtin_classes(_py);
        let target_class_bits = if maybe_ptr_from_bits(obj_bits)
            .is_some_and(|ptr| unsafe { object_type_id(ptr) == TYPE_ID_TYPE })
        {
            obj_bits
        } else {
            unsafe { type_of_bits(_py, obj_bits) }
        };

        if target_class_bits == builtins.int || target_class_bits == builtins.bool {
            for name in [
                &b"__abs__"[..],
                &b"__add__"[..],
                &b"__and__"[..],
                &b"__bool__"[..],
                &b"__ceil__"[..],
                &b"__divmod__"[..],
            ] {
                if !add_name(name) {
                    for owned in extra_owned {
                        dec_ref_bits(_py, owned);
                    }
                    return MoltObject::none().bits();
                }
            }
        } else if target_class_bits == builtins.str {
            for name in [&b"__add__"[..], &b"__contains__"[..], &b"__getitem__"[..]] {
                if !add_name(name) {
                    for owned in extra_owned {
                        dec_ref_bits(_py, owned);
                    }
                    return MoltObject::none().bits();
                }
            }
        } else if target_class_bits == builtins.list {
            for name in [
                &b"__add__"[..],
                &b"__class_getitem__"[..],
                &b"__contains__"[..],
                &b"__delitem__"[..],
            ] {
                if !add_name(name) {
                    for owned in extra_owned {
                        dec_ref_bits(_py, owned);
                    }
                    return MoltObject::none().bits();
                }
            }
        } else if target_class_bits == builtins.dict {
            for name in [
                &b"__class_getitem__"[..],
                &b"__contains__"[..],
                &b"__delitem__"[..],
                &b"__getitem__"[..],
            ] {
                if !add_name(name) {
                    for owned in extra_owned {
                        dec_ref_bits(_py, owned);
                    }
                    return MoltObject::none().bits();
                }
            }
        } else if target_class_bits == builtins.none_type {
            if !add_name(&b"__bool__"[..]) {
                for owned in extra_owned {
                    dec_ref_bits(_py, owned);
                }
                return MoltObject::none().bits();
            }
        }

        // Hide names that CPython deliberately excludes from dir() output (even though the
        // attributes exist).
        let hide_module = is_builtin_class_bits(_py, target_class_bits);
        names.retain(|&bits| {
            let Some(name) = string_obj_to_owned(obj_from_bits(bits)) else {
                return true;
            };
            if name == "__mro__" || name == "__bases__" || name == "__text_signature__" {
                return false;
            }
            if name.starts_with("__molt_") {
                return false;
            }
            if hide_module && name == "__module__" {
                return false;
            }
            true
        });

        let list_ptr = alloc_list(_py, &names);
        for owned in extra_owned {
            dec_ref_bits(_py, owned);
        }
        if list_ptr.is_null() {
            return MoltObject::none().bits();
        }
        let list_bits = MoltObject::from_ptr(list_ptr).bits();
        let none_bits = MoltObject::none().bits();
        let reverse_bits = MoltObject::from_int(0).bits();
        let _ = molt_list_sort(list_bits, none_bits, reverse_bits);
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        list_bits
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_object_init(_self_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, { MoltObject::none().bits() })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_object_init_subclass(_cls_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, { MoltObject::none().bits() })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_object_getattribute(obj_bits: u64, name_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let name_obj = obj_from_bits(name_bits);
        let Some(name_ptr) = name_obj.as_ptr() else {
            return raise_attr_name_type_error(_py, name_bits);
        };
        unsafe {
            if object_type_id(name_ptr) != TYPE_ID_STRING {
                return raise_attr_name_type_error(_py, name_bits);
            }
            let attr_name = string_obj_to_owned(obj_from_bits(name_bits))
                .unwrap_or_else(|| "<attr>".to_string());
            if let Some(obj_ptr) = maybe_ptr_from_bits(obj_bits) {
                let type_id = object_type_id(obj_ptr);
                let found = match type_id {
                    TYPE_ID_OBJECT => object_attr_lookup_raw(_py, obj_ptr, name_bits),
                    TYPE_ID_DATACLASS => dataclass_attr_lookup_raw(_py, obj_ptr, name_bits),
                    _ => attr_lookup_ptr(_py, obj_ptr, name_bits),
                };
                if let Some(val) = found {
                    return val;
                }
                if exception_pending(_py) {
                    let exc_bits = molt_exception_last();
                    molt_exception_clear();
                    let _ = molt_raise(exc_bits);
                    dec_ref_bits(_py, exc_bits);
                    return MoltObject::none().bits();
                }
                if type_id == TYPE_ID_DATACLASS {
                    let desc_ptr = dataclass_desc_ptr(obj_ptr);
                    if !desc_ptr.is_null() && (*desc_ptr).slots {
                        let name = &(*desc_ptr).name;
                        let type_label = if name.is_empty() {
                            "dataclass"
                        } else {
                            name.as_str()
                        };
                        return attr_error_with_obj(
                            _py,
                            type_label,
                            &attr_name,
                            MoltObject::from_ptr(obj_ptr).bits(),
                        ) as u64;
                    }
                    let type_label = if !desc_ptr.is_null() {
                        let name = &(*desc_ptr).name;
                        if name.is_empty() {
                            "dataclass"
                        } else {
                            name.as_str()
                        }
                    } else {
                        "dataclass"
                    };
                    return attr_error_with_obj(
                        _py,
                        type_label,
                        &attr_name,
                        MoltObject::from_ptr(obj_ptr).bits(),
                    ) as u64;
                }
                if type_id == TYPE_ID_TYPE {
                    let class_name = string_obj_to_owned(obj_from_bits(class_name_bits(obj_ptr)))
                        .unwrap_or_default();
                    let msg = format!("type object '{class_name}' has no attribute '{attr_name}'");
                    return attr_error_with_obj_message(
                        _py,
                        &msg,
                        &attr_name,
                        MoltObject::from_ptr(obj_ptr).bits(),
                    ) as u64;
                }
                return attr_error_with_obj(
                    _py,
                    type_name(_py, MoltObject::from_ptr(obj_ptr)),
                    &attr_name,
                    MoltObject::from_ptr(obj_ptr).bits(),
                ) as u64;
            }
            let obj = obj_from_bits(obj_bits);
            if obj.is_int() || obj.is_bool() {
                if let Some(func_bits) = crate::builtins::methods::int_method_bits(_py, &attr_name)
                {
                    return crate::molt_bound_method_new(func_bits, obj_bits);
                }
            }
            attr_error_with_obj(_py, type_name(_py, obj), &attr_name, obj_bits) as u64
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_type_getattribute(obj_bits: u64, name_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let name_obj = obj_from_bits(name_bits);
        let Some(name_ptr) = name_obj.as_ptr() else {
            return raise_attr_name_type_error(_py, name_bits);
        };
        unsafe {
            if object_type_id(name_ptr) != TYPE_ID_STRING {
                return raise_attr_name_type_error(_py, name_bits);
            }
            let attr_name = string_obj_to_owned(obj_from_bits(name_bits))
                .unwrap_or_else(|| "<attr>".to_string());
            if let Some(obj_ptr) = maybe_ptr_from_bits(obj_bits) {
                let type_id = object_type_id(obj_ptr);
                if type_id != TYPE_ID_TYPE {
                    return molt_object_getattribute(obj_bits, name_bits);
                }
                let found =
                    crate::builtins::attributes::type_attr_lookup_ptr(_py, obj_ptr, name_bits);
                if let Some(val) = found {
                    return val;
                }
                if exception_pending(_py) {
                    let exc_bits = molt_exception_last();
                    molt_exception_clear();
                    let _ = molt_raise(exc_bits);
                    dec_ref_bits(_py, exc_bits);
                    return MoltObject::none().bits();
                }
                let class_name = string_obj_to_owned(obj_from_bits(class_name_bits(obj_ptr)))
                    .unwrap_or_default();
                let msg = format!("type object '{class_name}' has no attribute '{attr_name}'");
                return attr_error_with_message(_py, &msg) as u64;
            }
            let obj = obj_from_bits(obj_bits);
            attr_error_with_obj(_py, type_name(_py, obj), &attr_name, obj_bits) as u64
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_type_call(cls_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let cls_obj = obj_from_bits(cls_bits);
        let Some(cls_ptr) = cls_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "type.__call__ expects type");
        };
        unsafe {
            if object_type_id(cls_ptr) != TYPE_ID_TYPE {
                return raise_exception::<_>(_py, "TypeError", "type.__call__ expects type");
            }
            if matches!(
                std::env::var("MOLT_TRACE_TYPE_CALL").ok().as_deref(),
                Some("1")
            ) {
                let class_name = string_obj_to_owned(obj_from_bits(class_name_bits(cls_ptr)))
                    .unwrap_or_default();
                let builtins = builtin_classes(_py);
                let kind = if cls_bits == builtins.type_obj {
                    "builtins.type"
                } else {
                    "type"
                };
                eprintln!(
                    "molt direct: type.__call__ invoked kind={} name={} cls_bits={} (no builder args forwarded)",
                    kind, class_name, cls_bits
                );
            }
            call_class_init_with_args(_py, cls_ptr, &[])
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_object_setattr(obj_bits: u64, name_bits: u64, val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let name_obj = obj_from_bits(name_bits);
        let Some(name_ptr) = name_obj.as_ptr() else {
            return raise_attr_name_type_error(_py, name_bits);
        };
        unsafe {
            if object_type_id(name_ptr) != TYPE_ID_STRING {
                return raise_attr_name_type_error(_py, name_bits);
            }
            let attr_name = string_obj_to_owned(obj_from_bits(name_bits))
                .unwrap_or_else(|| "<attr>".to_string());
            let Some(attr_bits) = attr_name_bits_from_bytes(_py, attr_name.as_bytes()) else {
                return MoltObject::none().bits();
            };
            if let Some(obj_ptr) = maybe_ptr_from_bits(obj_bits) {
                let type_id = object_type_id(obj_ptr);
                if type_id == TYPE_ID_TYPE {
                    dec_ref_bits(_py, attr_bits);
                    return raise_exception::<_>(
                        _py,
                        "TypeError",
                        "can't apply this __setattr__ to type object",
                    );
                }
                let class_bits = object_class_bits(obj_ptr);
                let builtins = builtin_classes(_py);
                let is_dict_subclass =
                    type_id == TYPE_ID_DICT && class_bits != 0 && class_bits != builtins.dict;
                let res = if type_id == TYPE_ID_OBJECT || is_dict_subclass {
                    object_setattr_raw(_py, obj_ptr, attr_bits, &attr_name, val_bits)
                } else if type_id == TYPE_ID_DATACLASS {
                    dataclass_setattr_raw_unchecked(_py, obj_ptr, attr_bits, &attr_name, val_bits)
                } else {
                    let bytes = string_bytes(name_ptr);
                    let len = string_len(name_ptr);
                    molt_set_attr_generic(obj_ptr, bytes, len as u64, val_bits)
                };
                dec_ref_bits(_py, attr_bits);
                return res as u64;
            }
            let obj = obj_from_bits(obj_bits);
            let res = attr_error_with_obj(_py, type_name(_py, obj), &attr_name, obj_bits) as u64;
            dec_ref_bits(_py, attr_bits);
            res
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_object_delattr(obj_bits: u64, name_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let name_obj = obj_from_bits(name_bits);
        let Some(name_ptr) = name_obj.as_ptr() else {
            return raise_attr_name_type_error(_py, name_bits);
        };
        unsafe {
            if object_type_id(name_ptr) != TYPE_ID_STRING {
                return raise_attr_name_type_error(_py, name_bits);
            }
            let attr_name = string_obj_to_owned(obj_from_bits(name_bits))
                .unwrap_or_else(|| "<attr>".to_string());
            let Some(attr_bits) = attr_name_bits_from_bytes(_py, attr_name.as_bytes()) else {
                return MoltObject::none().bits();
            };
            if let Some(obj_ptr) = maybe_ptr_from_bits(obj_bits) {
                let type_id = object_type_id(obj_ptr);
                if type_id == TYPE_ID_TYPE {
                    dec_ref_bits(_py, attr_bits);
                    return raise_exception::<_>(
                        _py,
                        "TypeError",
                        "can't apply this __delattr__ to type object",
                    );
                }
                let class_bits = object_class_bits(obj_ptr);
                let builtins = builtin_classes(_py);
                let is_dict_subclass =
                    type_id == TYPE_ID_DICT && class_bits != 0 && class_bits != builtins.dict;
                let res = if type_id == TYPE_ID_OBJECT || is_dict_subclass {
                    object_delattr_raw(_py, obj_ptr, attr_bits, &attr_name)
                } else if type_id == TYPE_ID_DATACLASS {
                    dataclass_delattr_raw_unchecked(_py, obj_ptr, attr_bits, &attr_name)
                } else {
                    del_attr_ptr(_py, obj_ptr, attr_bits, &attr_name)
                };
                dec_ref_bits(_py, attr_bits);
                return res as u64;
            }
            let obj = obj_from_bits(obj_bits);
            let res = attr_error(_py, type_name(_py, obj), &attr_name) as u64;
            dec_ref_bits(_py, attr_bits);
            res
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_object_eq(self_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        if self_bits == other_bits {
            return MoltObject::from_bool(true).bits();
        }
        not_implemented_bits(_py)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_object_ne(self_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        if self_bits == other_bits {
            return MoltObject::from_bool(false).bits();
        }
        not_implemented_bits(_py)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_anext_builtin(iter_bits: u64, default_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let missing = missing_bits(_py);
        if default_bits == missing {
            return molt_anext(iter_bits);
        }
        let obj_bits = molt_alloc(3 * std::mem::size_of::<u64>() as u64);
        let Some(obj_ptr) = resolve_obj_ptr(obj_bits) else {
            return MoltObject::none().bits();
        };
        unsafe {
            let header = header_from_obj_ptr(obj_ptr);
            (*header).poll_fn = anext_default_poll_fn_addr();
            (*header).state = 0;
            let payload_ptr = obj_ptr as *mut u64;
            *payload_ptr = iter_bits;
            inc_ref_bits(_py, iter_bits);
            *payload_ptr.add(1) = default_bits;
            inc_ref_bits(_py, default_bits);
            *payload_ptr.add(2) = MoltObject::none().bits();
        }
        obj_bits
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_print_builtin(
    args_bits: u64,
    sep_bits: u64,
    end_bits: u64,
    file_bits: u64,
    flush_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        fn print_string_arg_bits(
            _py: &PyToken<'_>,
            bits: u64,
            default: &[u8],
            label: &str,
        ) -> Option<u64> {
            let obj = obj_from_bits(bits);
            if obj.is_none() {
                let ptr = alloc_string(_py, default);
                if ptr.is_null() {
                    return None;
                }
                return Some(MoltObject::from_ptr(ptr).bits());
            }
            let Some(ptr) = obj.as_ptr() else {
                let msg = format!(
                    "{} must be None or a string, not {}",
                    label,
                    type_name(_py, obj)
                );
                return raise_exception::<_>(_py, "TypeError", &msg);
            };
            unsafe {
                if object_type_id(ptr) != TYPE_ID_STRING {
                    let msg = format!(
                        "{} must be None or a string, not {}",
                        label,
                        type_name(_py, obj)
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            }
            inc_ref_bits(_py, bits);
            Some(bits)
        }

        fn string_bits_is_empty(bits: u64) -> bool {
            let obj = obj_from_bits(bits);
            let Some(ptr) = obj.as_ptr() else {
                return false;
            };
            unsafe { string_len(ptr) == 0 }
        }

        fn string_bits_contains_newline(bits: u64) -> bool {
            let obj = obj_from_bits(bits);
            let Some(ptr) = obj.as_ptr() else {
                return false;
            };
            unsafe {
                let bytes = std::slice::from_raw_parts(string_bytes(ptr), string_len(ptr));
                bytes.contains(&b'\n')
            }
        }

        fn encode_print_bytes(
            _py: &PyToken<'_>,
            bits: u64,
            encoding: &str,
            errors: &str,
        ) -> Result<Vec<u8>, u64> {
            let obj = obj_from_bits(bits);
            let Some(ptr) = obj.as_ptr() else {
                return Err(raise_exception::<_>(
                    _py,
                    "TypeError",
                    "print expects a string",
                ));
            };
            unsafe {
                if object_type_id(ptr) != TYPE_ID_STRING {
                    return Err(raise_exception::<_>(
                        _py,
                        "TypeError",
                        "print expects a string",
                    ));
                }
                let bytes = std::slice::from_raw_parts(string_bytes(ptr), string_len(ptr));
                match encode_string_with_errors(bytes, encoding, Some(errors)) {
                    Ok(out) => Ok(out),
                    Err(EncodeError::UnknownEncoding(name)) => {
                        let msg = format!("unknown encoding: {name}");
                        Err(raise_exception::<_>(_py, "LookupError", &msg))
                    }
                    Err(EncodeError::UnknownErrorHandler(name)) => {
                        let msg = format!("unknown error handler name '{name}'");
                        Err(raise_exception::<_>(_py, "LookupError", &msg))
                    }
                    Err(EncodeError::InvalidChar {
                        encoding,
                        code,
                        pos,
                        limit,
                    }) => {
                        let reason = encode_error_reason(encoding, code, limit);
                        Err(raise_unicode_encode_error::<_>(
                            _py,
                            encoding,
                            bits,
                            pos,
                            pos + 1,
                            &reason,
                        ))
                    }
                }
            }
        }

        let args_obj = obj_from_bits(args_bits);
        let Some(args_ptr) = args_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "print expects a tuple");
        };
        unsafe {
            if object_type_id(args_ptr) != TYPE_ID_TUPLE {
                return raise_exception::<_>(_py, "TypeError", "print expects a tuple");
            }
            let mut sep_bits_opt = match print_string_arg_bits(_py, sep_bits, b" ", "sep") {
                Some(bits) => Some(bits),
                None => return MoltObject::none().bits(),
            };
            let mut end_bits_opt = match print_string_arg_bits(_py, end_bits, b"\n", "end") {
                Some(bits) => Some(bits),
                None => {
                    if let Some(bits) = sep_bits_opt {
                        dec_ref_bits(_py, bits);
                    }
                    return MoltObject::none().bits();
                }
            };
            if let Some(bits) = sep_bits_opt {
                if string_bits_is_empty(bits) {
                    dec_ref_bits(_py, bits);
                    sep_bits_opt = None;
                }
            }
            if let Some(bits) = end_bits_opt {
                if string_bits_is_empty(bits) {
                    dec_ref_bits(_py, bits);
                    end_bits_opt = None;
                }
            }

            let mut resolved_file_bits = file_bits;
            let mut sys_found = false;
            let mut file_from_sys = false;
            if obj_from_bits(resolved_file_bits).is_none() {
                let sys_name_bits =
                    intern_static_name(_py, &runtime_state(_py).interned.sys_name, b"sys");
                if !obj_from_bits(sys_name_bits).is_none() {
                    let sys_bits = molt_module_cache_get(sys_name_bits);
                    if !obj_from_bits(sys_bits).is_none() {
                        sys_found = true;
                        let stdout_name_bits = intern_static_name(
                            _py,
                            &runtime_state(_py).interned.stdout_name,
                            b"stdout",
                        );
                        resolved_file_bits = molt_module_get_attr(sys_bits, stdout_name_bits);
                        dec_ref_bits(_py, sys_bits);
                        if exception_pending(_py) {
                            return MoltObject::none().bits();
                        }
                        file_from_sys = true;
                    }
                }
            }

            let elems = seq_vec_ref(args_ptr);
            let do_flush = is_truthy(_py, obj_from_bits(flush_bits));

            if obj_from_bits(resolved_file_bits).is_none() && !sys_found {
                let encoding = "utf-8";
                let errors = "surrogateescape";
                let mut stdout = std::io::stdout();
                let mut wrote_newline = false;
                let sep_bytes = if let Some(bits) = sep_bits_opt {
                    match encode_print_bytes(_py, bits, encoding, errors) {
                        Ok(bytes) => Some(bytes),
                        Err(bits) => {
                            if let Some(end_bits) = end_bits_opt {
                                dec_ref_bits(_py, end_bits);
                            }
                            dec_ref_bits(_py, bits);
                            return bits;
                        }
                    }
                } else {
                    None
                };
                let end_bytes = if let Some(bits) = end_bits_opt {
                    match encode_print_bytes(_py, bits, encoding, errors) {
                        Ok(bytes) => Some(bytes),
                        Err(bits) => {
                            if let Some(sep_bits) = sep_bits_opt {
                                dec_ref_bits(_py, sep_bits);
                            }
                            dec_ref_bits(_py, bits);
                            return bits;
                        }
                    }
                } else {
                    None
                };
                for (idx, &val_bits) in elems.iter().enumerate() {
                    if idx > 0 {
                        if let Some(bytes) = sep_bytes.as_deref() {
                            if bytes.contains(&b'\n') {
                                wrote_newline = true;
                            }
                            let _ = stdout.write_all(bytes);
                        }
                    }
                    let str_bits = molt_str_from_obj(val_bits);
                    if exception_pending(_py) {
                        if let Some(sep_bits) = sep_bits_opt {
                            dec_ref_bits(_py, sep_bits);
                        }
                        if let Some(end_bits) = end_bits_opt {
                            dec_ref_bits(_py, end_bits);
                        }
                        return MoltObject::none().bits();
                    }
                    let bytes = match encode_print_bytes(_py, str_bits, encoding, errors) {
                        Ok(bytes) => bytes,
                        Err(bits) => {
                            dec_ref_bits(_py, str_bits);
                            if let Some(sep_bits) = sep_bits_opt {
                                dec_ref_bits(_py, sep_bits);
                            }
                            if let Some(end_bits) = end_bits_opt {
                                dec_ref_bits(_py, end_bits);
                            }
                            return bits;
                        }
                    };
                    if bytes.contains(&b'\n') {
                        wrote_newline = true;
                    }
                    let _ = stdout.write_all(&bytes);
                    dec_ref_bits(_py, str_bits);
                }
                if let Some(bytes) = end_bytes.as_deref() {
                    if bytes.contains(&b'\n') {
                        wrote_newline = true;
                    }
                    let _ = stdout.write_all(bytes);
                }
                if do_flush || wrote_newline {
                    let _ = stdout.flush();
                }
                if let Some(bits) = sep_bits_opt {
                    dec_ref_bits(_py, bits);
                }
                if let Some(bits) = end_bits_opt {
                    dec_ref_bits(_py, bits);
                }
                return MoltObject::none().bits();
            }

            let sep_bits = sep_bits_opt;
            let end_bits = end_bits_opt;
            let end_has_newline = end_bits.map(string_bits_contains_newline).unwrap_or(false);

            let mut write_bits = MoltObject::none().bits();
            let mut use_file_handle = false;
            if let Some(ptr) = obj_from_bits(resolved_file_bits).as_ptr() {
                use_file_handle = object_type_id(ptr) == TYPE_ID_FILE_HANDLE;
            }
            if !use_file_handle {
                let write_name_bits =
                    intern_static_name(_py, &runtime_state(_py).interned.write_name, b"write");
                write_bits = molt_get_attr_name(resolved_file_bits, write_name_bits);
                if exception_pending(_py) {
                    if let Some(bits) = sep_bits {
                        dec_ref_bits(_py, bits);
                    }
                    if let Some(bits) = end_bits {
                        dec_ref_bits(_py, bits);
                    }
                    if file_from_sys {
                        dec_ref_bits(_py, resolved_file_bits);
                    }
                    return MoltObject::none().bits();
                }
            }

            for (idx, &val_bits) in elems.iter().enumerate() {
                if idx > 0 {
                    if let Some(bits) = sep_bits {
                        if use_file_handle {
                            let _ = molt_file_write(resolved_file_bits, bits);
                        } else {
                            let res_bits = call_callable1(_py, write_bits, bits);
                            dec_ref_bits(_py, res_bits);
                        }
                        if exception_pending(_py) {
                            if !use_file_handle {
                                dec_ref_bits(_py, write_bits);
                            }
                            if let Some(bits) = sep_bits {
                                dec_ref_bits(_py, bits);
                            }
                            if let Some(bits) = end_bits {
                                dec_ref_bits(_py, bits);
                            }
                            if file_from_sys {
                                dec_ref_bits(_py, resolved_file_bits);
                            }
                            return MoltObject::none().bits();
                        }
                    }
                }
                let str_bits = molt_str_from_obj(val_bits);
                if exception_pending(_py) {
                    if !use_file_handle {
                        dec_ref_bits(_py, write_bits);
                    }
                    if let Some(bits) = sep_bits {
                        dec_ref_bits(_py, bits);
                    }
                    if let Some(bits) = end_bits {
                        dec_ref_bits(_py, bits);
                    }
                    if file_from_sys {
                        dec_ref_bits(_py, resolved_file_bits);
                    }
                    return MoltObject::none().bits();
                }
                if use_file_handle {
                    let _ = molt_file_write(resolved_file_bits, str_bits);
                } else {
                    let res_bits = call_callable1(_py, write_bits, str_bits);
                    dec_ref_bits(_py, res_bits);
                }
                dec_ref_bits(_py, str_bits);
                if exception_pending(_py) {
                    if !use_file_handle {
                        dec_ref_bits(_py, write_bits);
                    }
                    if let Some(bits) = sep_bits {
                        dec_ref_bits(_py, bits);
                    }
                    if let Some(bits) = end_bits {
                        dec_ref_bits(_py, bits);
                    }
                    if file_from_sys {
                        dec_ref_bits(_py, resolved_file_bits);
                    }
                    return MoltObject::none().bits();
                }
            }
            if let Some(bits) = end_bits {
                if use_file_handle {
                    let _ = molt_file_write(resolved_file_bits, bits);
                } else {
                    let res_bits = call_callable1(_py, write_bits, bits);
                    dec_ref_bits(_py, res_bits);
                }
                if exception_pending(_py) {
                    if !use_file_handle {
                        dec_ref_bits(_py, write_bits);
                    }
                    if let Some(bits) = sep_bits {
                        dec_ref_bits(_py, bits);
                    }
                    dec_ref_bits(_py, bits);
                    if file_from_sys {
                        dec_ref_bits(_py, resolved_file_bits);
                    }
                    return MoltObject::none().bits();
                }
            }
            if !use_file_handle {
                dec_ref_bits(_py, write_bits);
            }
            if let Some(bits) = sep_bits {
                dec_ref_bits(_py, bits);
            }
            if let Some(bits) = end_bits {
                dec_ref_bits(_py, bits);
            }

            if do_flush || (file_from_sys && use_file_handle && end_has_newline) {
                if use_file_handle {
                    let _ = molt_file_flush(resolved_file_bits);
                } else {
                    let flush_name_bits =
                        intern_static_name(_py, &runtime_state(_py).interned.flush_name, b"flush");
                    let flush_method_bits = molt_get_attr_name(resolved_file_bits, flush_name_bits);
                    if exception_pending(_py) {
                        if file_from_sys {
                            dec_ref_bits(_py, resolved_file_bits);
                        }
                        return MoltObject::none().bits();
                    }
                    let flush_res_bits = call_callable0(_py, flush_method_bits);
                    dec_ref_bits(_py, flush_method_bits);
                    dec_ref_bits(_py, flush_res_bits);
                    if exception_pending(_py) {
                        if file_from_sys {
                            dec_ref_bits(_py, resolved_file_bits);
                        }
                        return MoltObject::none().bits();
                    }
                }
            }
            if file_from_sys {
                dec_ref_bits(_py, resolved_file_bits);
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_input_builtin(prompt_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let sys_name_bits = intern_static_name(_py, &runtime_state(_py).interned.sys_name, b"sys");
        if obj_from_bits(sys_name_bits).is_none() {
            return raise_exception::<_>(_py, "RuntimeError", "sys module name missing");
        }
        let sys_bits = molt_module_cache_get(sys_name_bits);
        if obj_from_bits(sys_bits).is_none() {
            return raise_exception::<_>(_py, "RuntimeError", "sys module unavailable");
        }

        let stdout_name_bits =
            intern_static_name(_py, &runtime_state(_py).interned.stdout_name, b"stdout");
        let stdout_bits = molt_module_get_attr(sys_bits, stdout_name_bits);
        if exception_pending(_py) {
            dec_ref_bits(_py, sys_bits);
            return MoltObject::none().bits();
        }
        if obj_from_bits(stdout_bits).is_none() {
            dec_ref_bits(_py, sys_bits);
            return raise_exception::<_>(_py, "RuntimeError", "sys.stdout unavailable");
        }

        let prompt_str_bits = molt_str_from_obj(prompt_bits);
        if exception_pending(_py) {
            dec_ref_bits(_py, stdout_bits);
            dec_ref_bits(_py, sys_bits);
            return MoltObject::none().bits();
        }

        let mut stdout_is_handle = false;
        if let Some(ptr) = obj_from_bits(stdout_bits).as_ptr() {
            unsafe {
                stdout_is_handle = object_type_id(ptr) == TYPE_ID_FILE_HANDLE;
            }
        }

        if stdout_is_handle {
            let _ = molt_file_write(stdout_bits, prompt_str_bits);
        } else {
            let write_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.write_name, b"write");
            let write_method_bits = molt_get_attr_name(stdout_bits, write_name_bits);
            if exception_pending(_py) {
                dec_ref_bits(_py, prompt_str_bits);
                dec_ref_bits(_py, stdout_bits);
                dec_ref_bits(_py, sys_bits);
                return MoltObject::none().bits();
            }
            let write_res_bits = unsafe { call_callable1(_py, write_method_bits, prompt_str_bits) };
            dec_ref_bits(_py, write_method_bits);
            dec_ref_bits(_py, write_res_bits);
            if exception_pending(_py) {
                dec_ref_bits(_py, prompt_str_bits);
                dec_ref_bits(_py, stdout_bits);
                dec_ref_bits(_py, sys_bits);
                return MoltObject::none().bits();
            }
        }

        // Match CPython: flush stdout after writing the prompt.
        if stdout_is_handle {
            let _ = molt_file_flush(stdout_bits);
        } else {
            let missing = missing_bits(_py);
            let flush_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.flush_name, b"flush");
            let flush_bits = molt_getattr_builtin(stdout_bits, flush_name_bits, missing);
            if exception_pending(_py) {
                dec_ref_bits(_py, prompt_str_bits);
                dec_ref_bits(_py, stdout_bits);
                dec_ref_bits(_py, sys_bits);
                return MoltObject::none().bits();
            }
            if flush_bits != missing {
                let callable_bits = molt_is_callable(flush_bits);
                let is_callable = is_truthy(_py, obj_from_bits(callable_bits));
                dec_ref_bits(_py, callable_bits);
                if exception_pending(_py) {
                    dec_ref_bits(_py, flush_bits);
                    dec_ref_bits(_py, prompt_str_bits);
                    dec_ref_bits(_py, stdout_bits);
                    dec_ref_bits(_py, sys_bits);
                    return MoltObject::none().bits();
                }
                if is_callable {
                    let flush_res_bits = unsafe { call_callable0(_py, flush_bits) };
                    dec_ref_bits(_py, flush_res_bits);
                    if exception_pending(_py) {
                        dec_ref_bits(_py, flush_bits);
                        dec_ref_bits(_py, prompt_str_bits);
                        dec_ref_bits(_py, stdout_bits);
                        dec_ref_bits(_py, sys_bits);
                        return MoltObject::none().bits();
                    }
                }
                dec_ref_bits(_py, flush_bits);
            }
        }

        dec_ref_bits(_py, prompt_str_bits);
        dec_ref_bits(_py, stdout_bits);

        let stdin_name_bits =
            intern_static_name(_py, &runtime_state(_py).interned.stdin_name, b"stdin");
        let stdin_bits = molt_module_get_attr(sys_bits, stdin_name_bits);
        dec_ref_bits(_py, sys_bits);
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        if obj_from_bits(stdin_bits).is_none() {
            return raise_exception::<_>(_py, "RuntimeError", "sys.stdin unavailable");
        }

        let mut stdin_is_handle = false;
        if let Some(ptr) = obj_from_bits(stdin_bits).as_ptr() {
            unsafe {
                stdin_is_handle = object_type_id(ptr) == TYPE_ID_FILE_HANDLE;
            }
        }
        let line_bits = if stdin_is_handle {
            molt_file_readline(stdin_bits, MoltObject::from_int(-1).bits())
        } else {
            let readline_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.readline_name, b"readline");
            let method_bits = molt_get_attr_name(stdin_bits, readline_name_bits);
            if exception_pending(_py) {
                dec_ref_bits(_py, stdin_bits);
                return MoltObject::none().bits();
            }
            let out_bits = unsafe { call_callable0(_py, method_bits) };
            dec_ref_bits(_py, method_bits);
            out_bits
        };
        dec_ref_bits(_py, stdin_bits);
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }

        let Some(line_ptr) = obj_from_bits(line_bits).as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "input() returned non-string");
        };
        unsafe {
            if object_type_id(line_ptr) != TYPE_ID_STRING {
                return raise_exception::<_>(_py, "TypeError", "input() returned non-string");
            }
            let bytes = std::slice::from_raw_parts(string_bytes(line_ptr), string_len(line_ptr));
            if bytes.is_empty() {
                dec_ref_bits(_py, line_bits);
                return raise_exception::<_>(_py, "EOFError", "");
            }
            let mut end = bytes.len();
            if bytes[end - 1] == b'\n' {
                end -= 1;
                if end > 0 && bytes[end - 1] == b'\r' {
                    end -= 1;
                }
            } else if bytes[end - 1] == b'\r' {
                end -= 1;
            }
            if end == bytes.len() {
                return line_bits;
            }
            let out_ptr = alloc_string(_py, &bytes[..end]);
            dec_ref_bits(_py, line_bits);
            if out_ptr.is_null() {
                return MoltObject::none().bits();
            }
            MoltObject::from_ptr(out_ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_super_builtin(type_bits: u64, obj_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, { molt_super_new(type_bits, obj_bits) })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_slice(obj_bits: u64, start_bits: u64, end_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(obj_bits);
        let start_obj = obj_from_bits(start_bits);
        let end_obj = obj_from_bits(end_bits);
        if let Some(ptr) = obj.as_ptr() {
            unsafe {
                let type_id = object_type_id(ptr);
                if type_id == TYPE_ID_STRING {
                    let bytes = std::slice::from_raw_parts(string_bytes(ptr), string_len(ptr));
                    let total_chars =
                        utf8_codepoint_count_cached(_py, bytes, Some(ptr as usize)) as isize;
                    let start = match decode_slice_bound(_py, start_obj, total_chars, 0) {
                        Ok(v) => v,
                        Err(err) => return slice_error(_py, err),
                    };
                    let end = match decode_slice_bound(_py, end_obj, total_chars, total_chars) {
                        Ok(v) => v,
                        Err(err) => return slice_error(_py, err),
                    };
                    if end < start {
                        let out = alloc_string(_py, &[]);
                        if out.is_null() {
                            return MoltObject::none().bits();
                        }
                        return MoltObject::from_ptr(out).bits();
                    }
                    let start_byte = utf8_char_to_byte_index_cached(
                        _py,
                        bytes,
                        start as i64,
                        Some(ptr as usize),
                    );
                    let end_byte =
                        utf8_char_to_byte_index_cached(_py, bytes, end as i64, Some(ptr as usize));
                    let slice = &bytes[start_byte..end_byte];
                    let out = alloc_string(_py, slice);
                    if out.is_null() {
                        return MoltObject::none().bits();
                    }
                    return MoltObject::from_ptr(out).bits();
                }
                if type_id == TYPE_ID_BYTES {
                    let len = bytes_len(ptr) as isize;
                    let start = match decode_slice_bound(_py, start_obj, len, 0) {
                        Ok(v) => v,
                        Err(err) => return slice_error(_py, err),
                    };
                    let end = match decode_slice_bound(_py, end_obj, len, len) {
                        Ok(v) => v,
                        Err(err) => return slice_error(_py, err),
                    };
                    if end < start {
                        let out = alloc_bytes(_py, &[]);
                        if out.is_null() {
                            return MoltObject::none().bits();
                        }
                        return MoltObject::from_ptr(out).bits();
                    }
                    let bytes = std::slice::from_raw_parts(bytes_data(ptr), len as usize);
                    let slice = &bytes[start as usize..end as usize];
                    let out = alloc_bytes(_py, slice);
                    if out.is_null() {
                        return MoltObject::none().bits();
                    }
                    return MoltObject::from_ptr(out).bits();
                }
                if type_id == TYPE_ID_BYTEARRAY {
                    let len = bytes_len(ptr) as isize;
                    let start = match decode_slice_bound(_py, start_obj, len, 0) {
                        Ok(v) => v,
                        Err(err) => return slice_error(_py, err),
                    };
                    let end = match decode_slice_bound(_py, end_obj, len, len) {
                        Ok(v) => v,
                        Err(err) => return slice_error(_py, err),
                    };
                    if end < start {
                        let out = alloc_bytearray(_py, &[]);
                        if out.is_null() {
                            return MoltObject::none().bits();
                        }
                        return MoltObject::from_ptr(out).bits();
                    }
                    let bytes = std::slice::from_raw_parts(bytes_data(ptr), len as usize);
                    let slice = &bytes[start as usize..end as usize];
                    let out = alloc_bytearray(_py, slice);
                    if out.is_null() {
                        return MoltObject::none().bits();
                    }
                    return MoltObject::from_ptr(out).bits();
                }
                if type_id == TYPE_ID_MEMORYVIEW {
                    let len = memoryview_len(ptr) as isize;
                    let start = match decode_slice_bound(_py, start_obj, len, 0) {
                        Ok(v) => v,
                        Err(err) => return slice_error(_py, err),
                    };
                    let end = match decode_slice_bound(_py, end_obj, len, len) {
                        Ok(v) => v,
                        Err(err) => return slice_error(_py, err),
                    };
                    if end < start {
                        let base_offset = memoryview_offset(ptr);
                        let stride = memoryview_stride(ptr);
                        let out_ptr = alloc_memoryview(
                            _py,
                            memoryview_owner_bits(ptr),
                            base_offset + start * stride,
                            0,
                            memoryview_itemsize(ptr),
                            stride,
                            memoryview_readonly(ptr),
                            memoryview_format_bits(ptr),
                        );
                        if out_ptr.is_null() {
                            return MoltObject::none().bits();
                        }
                        return MoltObject::from_ptr(out_ptr).bits();
                    }
                    let base_offset = memoryview_offset(ptr);
                    let new_offset = base_offset + start * memoryview_stride(ptr);
                    let new_len = (end - start) as usize;
                    let out_ptr = alloc_memoryview(
                        _py,
                        memoryview_owner_bits(ptr),
                        new_offset,
                        new_len,
                        memoryview_itemsize(ptr),
                        memoryview_stride(ptr),
                        memoryview_readonly(ptr),
                        memoryview_format_bits(ptr),
                    );
                    if out_ptr.is_null() {
                        return MoltObject::none().bits();
                    }
                    return MoltObject::from_ptr(out_ptr).bits();
                }
                if type_id == TYPE_ID_LIST {
                    let len = list_len(ptr) as isize;
                    let start = match decode_slice_bound(_py, start_obj, len, 0) {
                        Ok(v) => v,
                        Err(err) => return slice_error(_py, err),
                    };
                    let end = match decode_slice_bound(_py, end_obj, len, len) {
                        Ok(v) => v,
                        Err(err) => return slice_error(_py, err),
                    };
                    if end < start {
                        let out = alloc_list(_py, &[]);
                        if out.is_null() {
                            return MoltObject::none().bits();
                        }
                        return MoltObject::from_ptr(out).bits();
                    }
                    let elems = seq_vec_ref(ptr);
                    let slice = &elems[start as usize..end as usize];
                    let out = alloc_list(_py, slice);
                    if out.is_null() {
                        return MoltObject::none().bits();
                    }
                    return MoltObject::from_ptr(out).bits();
                }
                if type_id == TYPE_ID_TUPLE {
                    let len = tuple_len(ptr) as isize;
                    let start = match decode_slice_bound(_py, start_obj, len, 0) {
                        Ok(v) => v,
                        Err(err) => return slice_error(_py, err),
                    };
                    let end = match decode_slice_bound(_py, end_obj, len, len) {
                        Ok(v) => v,
                        Err(err) => return slice_error(_py, err),
                    };
                    if end < start {
                        let out = alloc_tuple(_py, &[]);
                        if out.is_null() {
                            return MoltObject::none().bits();
                        }
                        return MoltObject::from_ptr(out).bits();
                    }
                    let elems = seq_vec_ref(ptr);
                    let slice = &elems[start as usize..end as usize];
                    let out = alloc_tuple(_py, slice);
                    if out.is_null() {
                        return MoltObject::none().bits();
                    }
                    return MoltObject::from_ptr(out).bits();
                }
            }
        }
        let slice_bits = molt_slice_new(start_bits, end_bits, MoltObject::none().bits());
        if obj_from_bits(slice_bits).is_none() {
            return MoltObject::none().bits();
        }
        let res_bits = molt_index(obj_bits, slice_bits);
        dec_ref_bits(_py, slice_bits);
        res_bits
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_find(hay_bits: u64, needle_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let none_bits = MoltObject::none().bits();
        let false_bits = MoltObject::from_bool(false).bits();
        molt_string_find_slice(
            hay_bits,
            needle_bits,
            none_bits,
            none_bits,
            false_bits,
            false_bits,
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_rfind(hay_bits: u64, needle_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let none_bits = MoltObject::none().bits();
        let false_bits = MoltObject::from_bool(false).bits();
        molt_string_rfind_slice(
            hay_bits,
            needle_bits,
            none_bits,
            none_bits,
            false_bits,
            false_bits,
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_index(hay_bits: u64, needle_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let none_bits = MoltObject::none().bits();
        let false_bits = MoltObject::from_bool(false).bits();
        molt_string_index_slice(
            hay_bits,
            needle_bits,
            none_bits,
            none_bits,
            false_bits,
            false_bits,
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_rindex(hay_bits: u64, needle_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let none_bits = MoltObject::none().bits();
        let false_bits = MoltObject::from_bool(false).bits();
        molt_string_rindex_slice(
            hay_bits,
            needle_bits,
            none_bits,
            none_bits,
            false_bits,
            false_bits,
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_find_slice(
    hay_bits: u64,
    needle_bits: u64,
    start_bits: u64,
    end_bits: u64,
    has_start_bits: u64,
    has_end_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let has_start = to_i64(obj_from_bits(has_start_bits)).unwrap_or(0) != 0;
        let has_end = to_i64(obj_from_bits(has_end_bits)).unwrap_or(0) != 0;
        if let Some(hay_ptr) = hay.as_ptr() {
            unsafe {
                if object_type_id(hay_ptr) != TYPE_ID_STRING {
                    return MoltObject::none().bits();
                }
                let needle_ptr = match needle.as_ptr() {
                    Some(ptr) => ptr,
                    None => {
                        let msg = format!("must be str, not {}", type_name(_py, needle));
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                if object_type_id(needle_ptr) != TYPE_ID_STRING {
                    let msg = format!("must be str, not {}", type_name(_py, needle));
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
                let hay_len = string_len(hay_ptr);
                let needle_len = string_len(needle_ptr);
                let hay_bytes = std::slice::from_raw_parts(string_bytes(hay_ptr), hay_len);
                let needle_bytes = std::slice::from_raw_parts(string_bytes(needle_ptr), needle_len);
                let total_chars =
                    utf8_codepoint_count_cached(_py, hay_bytes, Some(hay_ptr as usize));
                let (start, end, start_raw) = slice_bounds_from_args(
                    _py,
                    start_bits,
                    end_bits,
                    has_start,
                    has_end,
                    total_chars,
                );
                if end < start {
                    return MoltObject::from_int(-1).bits();
                }
                if needle_bytes.is_empty() {
                    if start_raw > total_chars {
                        return MoltObject::from_int(-1).bits();
                    }
                    return MoltObject::from_int(start).bits();
                }
                let start_byte =
                    utf8_char_to_byte_index_cached(_py, hay_bytes, start, Some(hay_ptr as usize));
                let end_byte =
                    utf8_char_to_byte_index_cached(_py, hay_bytes, end, Some(hay_ptr as usize))
                        .min(hay_bytes.len());
                let slice = &hay_bytes[start_byte..end_byte];
                let idx = bytes_find_impl(slice, needle_bytes);
                if idx < 0 {
                    return MoltObject::from_int(-1).bits();
                }
                if hay_bytes.is_ascii() && needle_bytes.is_ascii() {
                    return MoltObject::from_int(start + idx).bits();
                }
                let byte_idx = start_byte + idx as usize;
                let char_idx = utf8_byte_to_char_index_cached(
                    _py,
                    hay_bytes,
                    byte_idx,
                    Some(hay_ptr as usize),
                );
                MoltObject::from_int(char_idx).bits()
            }
        } else {
            MoltObject::none().bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_rfind_slice(
    hay_bits: u64,
    needle_bits: u64,
    start_bits: u64,
    end_bits: u64,
    has_start_bits: u64,
    has_end_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let has_start = to_i64(obj_from_bits(has_start_bits)).unwrap_or(0) != 0;
        let has_end = to_i64(obj_from_bits(has_end_bits)).unwrap_or(0) != 0;
        if let Some(hay_ptr) = hay.as_ptr() {
            unsafe {
                if object_type_id(hay_ptr) != TYPE_ID_STRING {
                    return MoltObject::none().bits();
                }
                let needle_ptr = match needle.as_ptr() {
                    Some(ptr) => ptr,
                    None => {
                        let msg = format!("must be str, not {}", type_name(_py, needle));
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                if object_type_id(needle_ptr) != TYPE_ID_STRING {
                    let msg = format!("must be str, not {}", type_name(_py, needle));
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
                let hay_len = string_len(hay_ptr);
                let needle_len = string_len(needle_ptr);
                let hay_bytes = std::slice::from_raw_parts(string_bytes(hay_ptr), hay_len);
                let needle_bytes = std::slice::from_raw_parts(string_bytes(needle_ptr), needle_len);
                let total_chars =
                    utf8_codepoint_count_cached(_py, hay_bytes, Some(hay_ptr as usize));
                let (start, end, start_raw) = slice_bounds_from_args(
                    _py,
                    start_bits,
                    end_bits,
                    has_start,
                    has_end,
                    total_chars,
                );
                if end < start {
                    return MoltObject::from_int(-1).bits();
                }
                if needle_bytes.is_empty() {
                    if start_raw > total_chars {
                        return MoltObject::from_int(-1).bits();
                    }
                    return MoltObject::from_int(end).bits();
                }
                let start_byte =
                    utf8_char_to_byte_index_cached(_py, hay_bytes, start, Some(hay_ptr as usize));
                let end_byte =
                    utf8_char_to_byte_index_cached(_py, hay_bytes, end, Some(hay_ptr as usize))
                        .min(hay_bytes.len());
                let slice = &hay_bytes[start_byte..end_byte];
                let idx = bytes_rfind_impl(slice, needle_bytes);
                if idx < 0 {
                    return MoltObject::from_int(-1).bits();
                }
                if hay_bytes.is_ascii() && needle_bytes.is_ascii() {
                    return MoltObject::from_int(start + idx).bits();
                }
                let byte_idx = start_byte + idx as usize;
                let char_idx = utf8_byte_to_char_index_cached(
                    _py,
                    hay_bytes,
                    byte_idx,
                    Some(hay_ptr as usize),
                );
                MoltObject::from_int(char_idx).bits()
            }
        } else {
            MoltObject::none().bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_index_slice(
    hay_bits: u64,
    needle_bits: u64,
    start_bits: u64,
    end_bits: u64,
    has_start_bits: u64,
    has_end_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let out_bits = molt_string_find_slice(
            hay_bits,
            needle_bits,
            start_bits,
            end_bits,
            has_start_bits,
            has_end_bits,
        );
        match to_i64(obj_from_bits(out_bits)) {
            Some(idx) if idx >= 0 => out_bits,
            Some(_) => raise_exception::<_>(_py, "ValueError", "substring not found"),
            None => out_bits,
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_rindex_slice(
    hay_bits: u64,
    needle_bits: u64,
    start_bits: u64,
    end_bits: u64,
    has_start_bits: u64,
    has_end_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let out_bits = molt_string_rfind_slice(
            hay_bits,
            needle_bits,
            start_bits,
            end_bits,
            has_start_bits,
            has_end_bits,
        );
        match to_i64(obj_from_bits(out_bits)) {
            Some(idx) if idx >= 0 => out_bits,
            Some(_) => raise_exception::<_>(_py, "ValueError", "substring not found"),
            None => out_bits,
        }
    })
}

fn partition_string_bytes(
    _py: &PyToken<'_>,
    hay_bytes: &[u8],
    sep_bytes: &[u8],
    from_right: bool,
) -> Option<u64> {
    let idx = if from_right {
        bytes_rfind_impl(hay_bytes, sep_bytes)
    } else {
        bytes_find_impl(hay_bytes, sep_bytes)
    };
    let (head_bytes, sep_bytes, tail_bytes) = if idx < 0 {
        if from_right {
            (&[][..], &[][..], hay_bytes)
        } else {
            (hay_bytes, &[][..], &[][..])
        }
    } else {
        let idx = idx as usize;
        let end = idx + sep_bytes.len();
        (&hay_bytes[..idx], sep_bytes, &hay_bytes[end..])
    };
    let head_ptr = alloc_string(_py, head_bytes);
    if head_ptr.is_null() {
        return None;
    }
    let head_bits = MoltObject::from_ptr(head_ptr).bits();
    let sep_ptr = alloc_string(_py, sep_bytes);
    if sep_ptr.is_null() {
        dec_ref_bits(_py, head_bits);
        return None;
    }
    let sep_bits = MoltObject::from_ptr(sep_ptr).bits();
    let tail_ptr = alloc_string(_py, tail_bytes);
    if tail_ptr.is_null() {
        dec_ref_bits(_py, head_bits);
        dec_ref_bits(_py, sep_bits);
        return None;
    }
    let tail_bits = MoltObject::from_ptr(tail_ptr).bits();
    let tuple_ptr = alloc_tuple(_py, &[head_bits, sep_bits, tail_bits]);
    if tuple_ptr.is_null() {
        dec_ref_bits(_py, head_bits);
        dec_ref_bits(_py, sep_bits);
        dec_ref_bits(_py, tail_bits);
        return None;
    }
    Some(MoltObject::from_ptr(tuple_ptr).bits())
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_partition(hay_bits: u64, sep_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let sep = obj_from_bits(sep_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_STRING {
                return MoltObject::none().bits();
            }
            let sep_ptr = match sep.as_ptr() {
                Some(ptr) => ptr,
                None => {
                    let msg = format!("must be str, not {}", type_name(_py, sep));
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            };
            if object_type_id(sep_ptr) != TYPE_ID_STRING {
                let msg = format!("must be str, not {}", type_name(_py, sep));
                return raise_exception::<_>(_py, "TypeError", &msg);
            }
            let hay_bytes = std::slice::from_raw_parts(string_bytes(hay_ptr), string_len(hay_ptr));
            let sep_bytes = std::slice::from_raw_parts(string_bytes(sep_ptr), string_len(sep_ptr));
            if sep_bytes.is_empty() {
                return raise_exception::<_>(_py, "ValueError", "empty separator");
            }
            let tuple_bits = partition_string_bytes(_py, hay_bytes, sep_bytes, false);
            tuple_bits.unwrap_or_else(|| MoltObject::none().bits())
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_rpartition(hay_bits: u64, sep_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let sep = obj_from_bits(sep_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_STRING {
                return MoltObject::none().bits();
            }
            let sep_ptr = match sep.as_ptr() {
                Some(ptr) => ptr,
                None => {
                    let msg = format!("must be str, not {}", type_name(_py, sep));
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            };
            if object_type_id(sep_ptr) != TYPE_ID_STRING {
                let msg = format!("must be str, not {}", type_name(_py, sep));
                return raise_exception::<_>(_py, "TypeError", &msg);
            }
            let hay_bytes = std::slice::from_raw_parts(string_bytes(hay_ptr), string_len(hay_ptr));
            let sep_bytes = std::slice::from_raw_parts(string_bytes(sep_ptr), string_len(sep_ptr));
            if sep_bytes.is_empty() {
                return raise_exception::<_>(_py, "ValueError", "empty separator");
            }
            let tuple_bits = partition_string_bytes(_py, hay_bytes, sep_bytes, true);
            tuple_bits.unwrap_or_else(|| MoltObject::none().bits())
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_startswith(hay_bits: u64, needle_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let none_bits = MoltObject::none().bits();
        let false_bits = MoltObject::from_bool(false).bits();
        molt_string_startswith_slice(
            hay_bits,
            needle_bits,
            none_bits,
            none_bits,
            false_bits,
            false_bits,
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_endswith(hay_bits: u64, needle_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let none_bits = MoltObject::none().bits();
        let false_bits = MoltObject::from_bool(false).bits();
        molt_string_endswith_slice(
            hay_bits,
            needle_bits,
            none_bits,
            none_bits,
            false_bits,
            false_bits,
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_startswith_slice(
    hay_bits: u64,
    needle_bits: u64,
    start_bits: u64,
    end_bits: u64,
    has_start_bits: u64,
    has_end_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let has_start = to_i64(obj_from_bits(has_start_bits)).unwrap_or(0) != 0;
        let has_end = to_i64(obj_from_bits(has_end_bits)).unwrap_or(0) != 0;
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_STRING {
                return MoltObject::none().bits();
            }
            let hay_bytes = std::slice::from_raw_parts(string_bytes(hay_ptr), string_len(hay_ptr));
            let total_chars = utf8_codepoint_count_cached(_py, hay_bytes, Some(hay_ptr as usize));
            let (start, end, start_raw) =
                slice_bounds_from_args(_py, start_bits, end_bits, has_start, has_end, total_chars);
            if end < start {
                return MoltObject::from_bool(false).bits();
            }
            let start_byte =
                utf8_char_to_byte_index_cached(_py, hay_bytes, start, Some(hay_ptr as usize));
            let end_byte =
                utf8_char_to_byte_index_cached(_py, hay_bytes, end, Some(hay_ptr as usize))
                    .min(hay_bytes.len());
            let slice = &hay_bytes[start_byte..end_byte];
            if let Some(needle_ptr) = needle.as_ptr() {
                let needle_type = object_type_id(needle_ptr);
                if needle_type == TYPE_ID_STRING {
                    let needle_bytes = std::slice::from_raw_parts(
                        string_bytes(needle_ptr),
                        string_len(needle_ptr),
                    );
                    let ok = slice_match(slice, needle_bytes, start_raw, total_chars, false);
                    return MoltObject::from_bool(ok).bits();
                }
                if needle_type == TYPE_ID_TUPLE {
                    let elems = seq_vec_ref(needle_ptr);
                    if elems.is_empty() {
                        return MoltObject::from_bool(false).bits();
                    }
                    for &elem_bits in elems.iter() {
                        let elem = obj_from_bits(elem_bits);
                        let elem_ptr = match elem.as_ptr() {
                            Some(ptr) => ptr,
                            None => {
                                let msg = format!(
                                    "tuple for startswith must only contain str, not {}",
                                    type_name(_py, elem)
                                );
                                return raise_exception::<_>(_py, "TypeError", &msg);
                            }
                        };
                        if object_type_id(elem_ptr) != TYPE_ID_STRING {
                            let msg = format!(
                                "tuple for startswith must only contain str, not {}",
                                type_name(_py, elem)
                            );
                            return raise_exception::<_>(_py, "TypeError", &msg);
                        }
                        let needle_bytes = std::slice::from_raw_parts(
                            string_bytes(elem_ptr),
                            string_len(elem_ptr),
                        );
                        if slice_match(slice, needle_bytes, start_raw, total_chars, false) {
                            return MoltObject::from_bool(true).bits();
                        }
                    }
                    return MoltObject::from_bool(false).bits();
                }
            }
            let msg = format!(
                "startswith first arg must be str or a tuple of str, not {}",
                type_name(_py, needle)
            );
            raise_exception::<_>(_py, "TypeError", &msg)
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_endswith_slice(
    hay_bits: u64,
    needle_bits: u64,
    start_bits: u64,
    end_bits: u64,
    has_start_bits: u64,
    has_end_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let has_start = to_i64(obj_from_bits(has_start_bits)).unwrap_or(0) != 0;
        let has_end = to_i64(obj_from_bits(has_end_bits)).unwrap_or(0) != 0;
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_STRING {
                return MoltObject::none().bits();
            }
            let hay_bytes = std::slice::from_raw_parts(string_bytes(hay_ptr), string_len(hay_ptr));
            let total_chars = utf8_codepoint_count_cached(_py, hay_bytes, Some(hay_ptr as usize));
            let (start, end, start_raw) =
                slice_bounds_from_args(_py, start_bits, end_bits, has_start, has_end, total_chars);
            if end < start {
                return MoltObject::from_bool(false).bits();
            }
            let start_byte =
                utf8_char_to_byte_index_cached(_py, hay_bytes, start, Some(hay_ptr as usize));
            let end_byte =
                utf8_char_to_byte_index_cached(_py, hay_bytes, end, Some(hay_ptr as usize))
                    .min(hay_bytes.len());
            let slice = &hay_bytes[start_byte..end_byte];
            if let Some(needle_ptr) = needle.as_ptr() {
                let needle_type = object_type_id(needle_ptr);
                if needle_type == TYPE_ID_STRING {
                    let needle_bytes = std::slice::from_raw_parts(
                        string_bytes(needle_ptr),
                        string_len(needle_ptr),
                    );
                    let ok = slice_match(slice, needle_bytes, start_raw, total_chars, true);
                    return MoltObject::from_bool(ok).bits();
                }
                if needle_type == TYPE_ID_TUPLE {
                    let elems = seq_vec_ref(needle_ptr);
                    if elems.is_empty() {
                        return MoltObject::from_bool(false).bits();
                    }
                    for &elem_bits in elems.iter() {
                        let elem = obj_from_bits(elem_bits);
                        let elem_ptr = match elem.as_ptr() {
                            Some(ptr) => ptr,
                            None => {
                                let msg = format!(
                                    "tuple for endswith must only contain str, not {}",
                                    type_name(_py, elem)
                                );
                                return raise_exception::<_>(_py, "TypeError", &msg);
                            }
                        };
                        if object_type_id(elem_ptr) != TYPE_ID_STRING {
                            let msg = format!(
                                "tuple for endswith must only contain str, not {}",
                                type_name(_py, elem)
                            );
                            return raise_exception::<_>(_py, "TypeError", &msg);
                        }
                        let needle_bytes = std::slice::from_raw_parts(
                            string_bytes(elem_ptr),
                            string_len(elem_ptr),
                        );
                        if slice_match(slice, needle_bytes, start_raw, total_chars, true) {
                            return MoltObject::from_bool(true).bits();
                        }
                    }
                    return MoltObject::from_bool(false).bits();
                }
            }
            let msg = format!(
                "endswith first arg must be str or a tuple of str, not {}",
                type_name(_py, needle)
            );
            raise_exception::<_>(_py, "TypeError", &msg)
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_count(hay_bits: u64, needle_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_STRING {
                return MoltObject::none().bits();
            }
            let needle_ptr = match needle.as_ptr() {
                Some(ptr) => ptr,
                None => {
                    let msg = format!("must be str, not {}", type_name(_py, needle));
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            };
            if object_type_id(needle_ptr) != TYPE_ID_STRING {
                let msg = format!("must be str, not {}", type_name(_py, needle));
                return raise_exception::<_>(_py, "TypeError", &msg);
            }
            let hay_bytes = std::slice::from_raw_parts(string_bytes(hay_ptr), string_len(hay_ptr));
            let needle_bytes =
                std::slice::from_raw_parts(string_bytes(needle_ptr), string_len(needle_ptr));
            let count = if needle_bytes.is_empty() {
                utf8_codepoint_count_cached(_py, hay_bytes, Some(hay_ptr as usize)) + 1
            } else if let Some(cache) = utf8_count_cache_lookup(_py, hay_ptr as usize, needle_bytes)
            {
                cache.count
            } else {
                profile_hit(_py, &runtime_state(_py).string_count_cache_miss);
                let count = bytes_count_impl(hay_bytes, needle_bytes);
                utf8_count_cache_store(
                    _py,
                    hay_ptr as usize,
                    hay_bytes,
                    needle_bytes,
                    count,
                    Vec::new(),
                );
                count
            };
            MoltObject::from_int(count).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_count_slice(
    hay_bits: u64,
    needle_bits: u64,
    start_bits: u64,
    end_bits: u64,
    has_start_bits: u64,
    has_end_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let has_start = to_i64(obj_from_bits(has_start_bits)).unwrap_or(0) != 0;
        let has_end = to_i64(obj_from_bits(has_end_bits)).unwrap_or(0) != 0;
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_STRING {
                return MoltObject::none().bits();
            }
            let needle_ptr = match needle.as_ptr() {
                Some(ptr) => ptr,
                None => {
                    let msg = format!("must be str, not {}", type_name(_py, needle));
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            };
            if object_type_id(needle_ptr) != TYPE_ID_STRING {
                let msg = format!("must be str, not {}", type_name(_py, needle));
                return raise_exception::<_>(_py, "TypeError", &msg);
            }
            let hay_bytes = std::slice::from_raw_parts(string_bytes(hay_ptr), string_len(hay_ptr));
            let needle_bytes =
                std::slice::from_raw_parts(string_bytes(needle_ptr), string_len(needle_ptr));
            let total_chars = utf8_codepoint_count_cached(_py, hay_bytes, Some(hay_ptr as usize));
            let (start, end, start_raw) =
                slice_bounds_from_args(_py, start_bits, end_bits, has_start, has_end, total_chars);
            if end < start {
                return MoltObject::from_int(0).bits();
            }
            if needle_bytes.is_empty() {
                if start_raw > total_chars {
                    return MoltObject::from_int(0).bits();
                }
                let count = end - start + 1;
                return MoltObject::from_int(count).bits();
            }
            let start_byte =
                utf8_char_to_byte_index_cached(_py, hay_bytes, start, Some(hay_ptr as usize));
            let end_byte =
                utf8_char_to_byte_index_cached(_py, hay_bytes, end, Some(hay_ptr as usize))
                    .min(hay_bytes.len());
            if let Some(cache) = utf8_count_cache_lookup(_py, hay_ptr as usize, needle_bytes) {
                let cache =
                    utf8_count_cache_upgrade_prefix(_py, hay_ptr as usize, &cache, hay_bytes);
                let count = utf8_count_cache_count_slice(&cache, hay_bytes, start_byte, end_byte);
                return MoltObject::from_int(count).bits();
            }
            let slice = &hay_bytes[start_byte..end_byte];
            let count = bytes_count_impl(slice, needle_bytes);
            MoltObject::from_int(count).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_join(sep_bits: u64, items_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let sep = obj_from_bits(sep_bits);
        let items = obj_from_bits(items_bits);
        let sep_ptr = match sep.as_ptr() {
            Some(ptr) => ptr,
            None => return MoltObject::none().bits(),
        };
        unsafe {
            if object_type_id(sep_ptr) != TYPE_ID_STRING {
                return raise_exception::<_>(_py, "TypeError", "join expects a str separator");
            }
            let sep_bytes = std::slice::from_raw_parts(string_bytes(sep_ptr), string_len(sep_ptr));
            let mut total_len = 0usize;
            struct StringPart {
                bits: u64,
                data: *const u8,
                len: usize,
            }
            let mut parts = Vec::new();
            let mut all_same = true;
            let mut first_bits = 0u64;
            let mut first_data = std::ptr::null();
            let mut first_len = 0usize;
            let mut owned_bits = Vec::new();
            let mut iter_owned = false;
            if let Some(ptr) = items.as_ptr() {
                let type_id = object_type_id(ptr);
                if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                    let elems = seq_vec_ref(ptr);
                    parts.reserve(elems.len());
                    for (idx, &elem_bits) in elems.iter().enumerate() {
                        let elem_obj = obj_from_bits(elem_bits);
                        let elem_ptr = match elem_obj.as_ptr() {
                            Some(ptr) => ptr,
                            None => {
                                let msg = format!(
                                    "sequence item {idx}: expected str instance, {} found",
                                    type_name(_py, elem_obj)
                                );
                                return raise_exception::<_>(_py, "TypeError", &msg);
                            }
                        };
                        if object_type_id(elem_ptr) != TYPE_ID_STRING {
                            let msg = format!(
                                "sequence item {idx}: expected str instance, {} found",
                                type_name(_py, elem_obj)
                            );
                            return raise_exception::<_>(_py, "TypeError", &msg);
                        }
                        let len = string_len(elem_ptr);
                        total_len += len;
                        let data = string_bytes(elem_ptr);
                        if idx == 0 {
                            first_bits = elem_bits;
                            first_data = data;
                            first_len = len;
                        } else if elem_bits != first_bits {
                            all_same = false;
                        }
                        parts.push(StringPart {
                            bits: elem_bits,
                            data,
                            len,
                        });
                    }
                }
            }
            if parts.is_empty() {
                let iter_bits = molt_iter(items_bits);
                if obj_from_bits(iter_bits).is_none() {
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    return raise_exception::<_>(_py, "TypeError", "can only join an iterable");
                }
                iter_owned = true;
                let mut idx = 0usize;
                loop {
                    let pair_bits = molt_iter_next(iter_bits);
                    if exception_pending(_py) {
                        for bits in owned_bits.iter().copied() {
                            dec_ref_bits(_py, bits);
                        }
                        return MoltObject::none().bits();
                    }
                    let pair_obj = obj_from_bits(pair_bits);
                    let Some(pair_ptr) = pair_obj.as_ptr() else {
                        for bits in owned_bits.iter().copied() {
                            dec_ref_bits(_py, bits);
                        }
                        return MoltObject::none().bits();
                    };
                    if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                        for bits in owned_bits.iter().copied() {
                            dec_ref_bits(_py, bits);
                        }
                        return MoltObject::none().bits();
                    }
                    let pair_elems = seq_vec_ref(pair_ptr);
                    if pair_elems.len() < 2 {
                        for bits in owned_bits.iter().copied() {
                            dec_ref_bits(_py, bits);
                        }
                        return MoltObject::none().bits();
                    }
                    let done_bits = pair_elems[1];
                    if is_truthy(_py, obj_from_bits(done_bits)) {
                        break;
                    }
                    let elem_bits = pair_elems[0];
                    let elem_obj = obj_from_bits(elem_bits);
                    let elem_ptr = match elem_obj.as_ptr() {
                        Some(ptr) => ptr,
                        None => {
                            for bits in owned_bits.iter().copied() {
                                dec_ref_bits(_py, bits);
                            }
                            let msg = format!(
                                "sequence item {idx}: expected str instance, {} found",
                                type_name(_py, elem_obj)
                            );
                            return raise_exception::<_>(_py, "TypeError", &msg);
                        }
                    };
                    if object_type_id(elem_ptr) != TYPE_ID_STRING {
                        for bits in owned_bits.iter().copied() {
                            dec_ref_bits(_py, bits);
                        }
                        let msg = format!(
                            "sequence item {idx}: expected str instance, {} found",
                            type_name(_py, elem_obj)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                    let len = string_len(elem_ptr);
                    total_len += len;
                    let data = string_bytes(elem_ptr);
                    if idx == 0 {
                        first_bits = elem_bits;
                        first_data = data;
                        first_len = len;
                    } else if elem_bits != first_bits {
                        all_same = false;
                    }
                    parts.push(StringPart {
                        bits: elem_bits,
                        data,
                        len,
                    });
                    inc_ref_bits(_py, elem_bits);
                    owned_bits.push(elem_bits);
                    idx += 1;
                }
            }
            if !parts.is_empty() {
                let sep_total = sep_bytes
                    .len()
                    .saturating_mul(parts.len().saturating_sub(1));
                total_len = total_len.saturating_add(sep_total);
            }
            let mut result_bits = None;
            if parts.len() == 1 && !iter_owned {
                inc_ref_bits(_py, parts[0].bits);
                result_bits = Some(parts[0].bits);
            }
            if let Some(bits) = result_bits {
                return bits;
            }
            let out_ptr = alloc_bytes_like_with_len(_py, total_len, TYPE_ID_STRING);
            if out_ptr.is_null() {
                if iter_owned {
                    for bits in owned_bits.iter().copied() {
                        dec_ref_bits(_py, bits);
                    }
                }
                return MoltObject::none().bits();
            }
            let mut cursor = out_ptr.add(std::mem::size_of::<usize>());
            if all_same && parts.len() > 1 {
                let sep_len = sep_bytes.len();
                let elem_len = first_len;
                if elem_len > 0 {
                    std::ptr::copy_nonoverlapping(first_data, cursor, elem_len);
                    cursor = cursor.add(elem_len);
                }
                let pattern_len = sep_len.saturating_add(elem_len);
                let total_pattern_bytes = pattern_len.saturating_mul(parts.len() - 1);
                if total_pattern_bytes > 0 {
                    if sep_len > 0 {
                        std::ptr::copy_nonoverlapping(sep_bytes.as_ptr(), cursor, sep_len);
                    }
                    if elem_len > 0 {
                        std::ptr::copy_nonoverlapping(first_data, cursor.add(sep_len), elem_len);
                    }
                    let pattern_start = cursor;
                    let mut filled = pattern_len;
                    while filled < total_pattern_bytes {
                        let copy_len = (total_pattern_bytes - filled).min(filled);
                        std::ptr::copy_nonoverlapping(
                            pattern_start,
                            pattern_start.add(filled),
                            copy_len,
                        );
                        filled += copy_len;
                    }
                }
                let out_bits = MoltObject::from_ptr(out_ptr).bits();
                if iter_owned {
                    for bits in owned_bits.iter().copied() {
                        dec_ref_bits(_py, bits);
                    }
                }
                return out_bits;
            }
            for (idx, part) in parts.iter().enumerate() {
                if idx > 0 {
                    std::ptr::copy_nonoverlapping(sep_bytes.as_ptr(), cursor, sep_bytes.len());
                    cursor = cursor.add(sep_bytes.len());
                }
                std::ptr::copy_nonoverlapping(part.data, cursor, part.len);
                cursor = cursor.add(part.len);
            }
            let out_bits = MoltObject::from_ptr(out_ptr).bits();
            if iter_owned {
                for bits in owned_bits.iter().copied() {
                    dec_ref_bits(_py, bits);
                }
            }
            out_bits
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_join(sep_bits: u64, items_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let sep = obj_from_bits(sep_bits);
        let items = obj_from_bits(items_bits);
        let sep_ptr = match sep.as_ptr() {
            Some(ptr) => ptr,
            None => return MoltObject::none().bits(),
        };
        unsafe {
            if object_type_id(sep_ptr) != TYPE_ID_BYTES {
                return raise_exception::<_>(_py, "TypeError", "join expects a bytes separator");
            }
            let sep_bytes = bytes_like_slice(sep_ptr).unwrap_or(&[]);
            let mut total_len = 0usize;
            struct BytesPart {
                bits: u64,
                data: *const u8,
                len: usize,
                type_id: u32,
            }
            let mut parts = Vec::new();
            let mut all_same = true;
            let mut first_bits = 0u64;
            let mut first_data = std::ptr::null();
            let mut first_len = 0usize;
            let mut owned_bits = Vec::new();
            let mut iter_owned = false;
            if let Some(ptr) = items.as_ptr() {
                let type_id = object_type_id(ptr);
                if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                    let elems = seq_vec_ref(ptr);
                    parts.reserve(elems.len());
                    for (idx, &elem_bits) in elems.iter().enumerate() {
                        let elem_obj = obj_from_bits(elem_bits);
                        let elem_ptr = match elem_obj.as_ptr() {
                            Some(ptr) => ptr,
                            None => {
                                let msg = format!(
                                    "sequence item {idx}: expected a bytes-like object, {} found",
                                    type_name(_py, elem_obj)
                                );
                                return raise_exception::<_>(_py, "TypeError", &msg);
                            }
                        };
                        let Some(elem_bytes) = bytes_like_slice(elem_ptr) else {
                            let msg = format!(
                                "sequence item {idx}: expected a bytes-like object, {} found",
                                type_name(_py, elem_obj)
                            );
                            return raise_exception::<_>(_py, "TypeError", &msg);
                        };
                        let len = elem_bytes.len();
                        total_len = total_len.saturating_add(len);
                        let data = elem_bytes.as_ptr();
                        if idx == 0 {
                            first_bits = elem_bits;
                            first_data = data;
                            first_len = len;
                        } else if elem_bits != first_bits {
                            all_same = false;
                        }
                        parts.push(BytesPart {
                            bits: elem_bits,
                            data,
                            len,
                            type_id: object_type_id(elem_ptr),
                        });
                    }
                }
            }
            if parts.is_empty() {
                let iter_bits = molt_iter(items_bits);
                if obj_from_bits(iter_bits).is_none() {
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    return raise_exception::<_>(_py, "TypeError", "can only join an iterable");
                }
                iter_owned = true;
                let mut idx = 0usize;
                loop {
                    let pair_bits = molt_iter_next(iter_bits);
                    if exception_pending(_py) {
                        for bits in owned_bits.iter().copied() {
                            dec_ref_bits(_py, bits);
                        }
                        return MoltObject::none().bits();
                    }
                    let pair_obj = obj_from_bits(pair_bits);
                    let Some(pair_ptr) = pair_obj.as_ptr() else {
                        for bits in owned_bits.iter().copied() {
                            dec_ref_bits(_py, bits);
                        }
                        return MoltObject::none().bits();
                    };
                    if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                        for bits in owned_bits.iter().copied() {
                            dec_ref_bits(_py, bits);
                        }
                        return MoltObject::none().bits();
                    }
                    let pair_elems = seq_vec_ref(pair_ptr);
                    if pair_elems.len() < 2 {
                        for bits in owned_bits.iter().copied() {
                            dec_ref_bits(_py, bits);
                        }
                        return MoltObject::none().bits();
                    }
                    let done_bits = pair_elems[1];
                    if is_truthy(_py, obj_from_bits(done_bits)) {
                        break;
                    }
                    let elem_bits = pair_elems[0];
                    let elem_obj = obj_from_bits(elem_bits);
                    let elem_ptr = match elem_obj.as_ptr() {
                        Some(ptr) => ptr,
                        None => {
                            for bits in owned_bits.iter().copied() {
                                dec_ref_bits(_py, bits);
                            }
                            let msg = format!(
                                "sequence item {idx}: expected a bytes-like object, {} found",
                                type_name(_py, elem_obj)
                            );
                            return raise_exception::<_>(_py, "TypeError", &msg);
                        }
                    };
                    let Some(elem_bytes) = bytes_like_slice(elem_ptr) else {
                        for bits in owned_bits.iter().copied() {
                            dec_ref_bits(_py, bits);
                        }
                        let msg = format!(
                            "sequence item {idx}: expected a bytes-like object, {} found",
                            type_name(_py, elem_obj)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    };
                    let len = elem_bytes.len();
                    total_len = total_len.saturating_add(len);
                    let data = elem_bytes.as_ptr();
                    if idx == 0 {
                        first_bits = elem_bits;
                        first_data = data;
                        first_len = len;
                    } else if elem_bits != first_bits {
                        all_same = false;
                    }
                    parts.push(BytesPart {
                        bits: elem_bits,
                        data,
                        len,
                        type_id: object_type_id(elem_ptr),
                    });
                    inc_ref_bits(_py, elem_bits);
                    owned_bits.push(elem_bits);
                    idx += 1;
                }
            }
            if !parts.is_empty() {
                let sep_total = sep_bytes
                    .len()
                    .saturating_mul(parts.len().saturating_sub(1));
                total_len = total_len.saturating_add(sep_total);
            }
            if parts.len() == 1 && !iter_owned && parts[0].type_id == TYPE_ID_BYTES {
                inc_ref_bits(_py, parts[0].bits);
                return parts[0].bits;
            }
            let out_ptr = alloc_bytes_like_with_len(_py, total_len, TYPE_ID_BYTES);
            if out_ptr.is_null() {
                if iter_owned {
                    for bits in owned_bits.iter().copied() {
                        dec_ref_bits(_py, bits);
                    }
                }
                return MoltObject::none().bits();
            }
            let mut cursor = out_ptr.add(std::mem::size_of::<usize>());
            if all_same && parts.len() > 1 {
                let sep_len = sep_bytes.len();
                let elem_len = first_len;
                if elem_len > 0 {
                    std::ptr::copy_nonoverlapping(first_data, cursor, elem_len);
                    cursor = cursor.add(elem_len);
                }
                let pattern_len = sep_len.saturating_add(elem_len);
                let total_pattern_bytes = pattern_len.saturating_mul(parts.len() - 1);
                if total_pattern_bytes > 0 {
                    if sep_len > 0 {
                        std::ptr::copy_nonoverlapping(sep_bytes.as_ptr(), cursor, sep_len);
                    }
                    if elem_len > 0 {
                        std::ptr::copy_nonoverlapping(first_data, cursor.add(sep_len), elem_len);
                    }
                    let pattern_start = cursor;
                    let mut filled = pattern_len;
                    while filled < total_pattern_bytes {
                        let copy_len = (total_pattern_bytes - filled).min(filled);
                        std::ptr::copy_nonoverlapping(
                            pattern_start,
                            pattern_start.add(filled),
                            copy_len,
                        );
                        filled += copy_len;
                    }
                }
                let out_bits = MoltObject::from_ptr(out_ptr).bits();
                if iter_owned {
                    for bits in owned_bits.iter().copied() {
                        dec_ref_bits(_py, bits);
                    }
                }
                return out_bits;
            }
            for (idx, part) in parts.iter().enumerate() {
                if idx > 0 {
                    std::ptr::copy_nonoverlapping(sep_bytes.as_ptr(), cursor, sep_bytes.len());
                    cursor = cursor.add(sep_bytes.len());
                }
                std::ptr::copy_nonoverlapping(part.data, cursor, part.len);
                cursor = cursor.add(part.len);
            }
            let out_bits = MoltObject::from_ptr(out_ptr).bits();
            if iter_owned {
                for bits in owned_bits.iter().copied() {
                    dec_ref_bits(_py, bits);
                }
            }
            out_bits
        }
    })
}

#[derive(Copy, Clone)]
enum FormatContext {
    FormatString,
    FormatSpec,
}

struct FormatState {
    next_auto: usize,
    used_auto: bool,
    used_manual: bool,
}

struct FormatField<'a> {
    field_name: &'a str,
    conversion: Option<char>,
    format_spec: &'a str,
}

fn format_raise_value_error_str(_py: &PyToken<'_>, msg: &str) -> Option<String> {
    raise_exception::<_>(_py, "ValueError", msg)
}

fn format_raise_value_error_bits(_py: &PyToken<'_>, msg: &str) -> Option<u64> {
    raise_exception::<_>(_py, "ValueError", msg)
}

fn format_raise_index_error_bits(_py: &PyToken<'_>, msg: &str) -> Option<u64> {
    raise_exception::<_>(_py, "IndexError", msg)
}

fn parse_format_field<'a>(
    _py: &PyToken<'_>,
    text: &'a str,
    start: usize,
    context: FormatContext,
) -> Option<(FormatField<'a>, usize)> {
    let bytes = text.as_bytes();
    let len = bytes.len();
    if start >= len {
        let msg = match context {
            FormatContext::FormatSpec => "unmatched '{' in format spec",
            FormatContext::FormatString => "Single '{' encountered in format string",
        };
        return raise_exception::<_>(_py, "ValueError", msg);
    }
    let mut idx = start;
    while idx < len {
        let b = bytes[idx];
        if b == b'!' || b == b':' || b == b'}' {
            break;
        }
        idx += 1;
    }
    let field_name = &text[start..idx];
    let mut conversion = None;
    if idx < len && bytes[idx] == b'!' {
        idx += 1;
        if idx >= len {
            let msg = match context {
                FormatContext::FormatSpec => "unmatched '{' in format spec",
                FormatContext::FormatString => "expected '}' before end of string",
            };
            return raise_exception::<_>(_py, "ValueError", msg);
        }
        let conv = bytes[idx] as char;
        if conv != 'r' && conv != 's' && conv != 'a' {
            if conv == '}' {
                return raise_exception::<_>(_py, "ValueError", "unmatched '{' in format spec");
            }
            let msg = format!("Unknown conversion specifier {conv}");
            return raise_exception::<_>(_py, "ValueError", &msg);
        }
        conversion = Some(conv);
        idx += 1;
    }
    let mut format_spec = "";
    if idx < len && bytes[idx] == b':' {
        idx += 1;
        let spec_start = idx;
        while idx < len {
            let b = bytes[idx];
            if b == b'{' {
                if idx + 1 < len && bytes[idx + 1] == b'{' {
                    idx += 2;
                    continue;
                }
                let (_, next_idx) =
                    parse_format_field(_py, text, idx + 1, FormatContext::FormatSpec)?;
                idx = next_idx;
                continue;
            }
            if b == b'}' {
                if idx + 1 < len && bytes[idx + 1] == b'}' {
                    idx += 2;
                    continue;
                }
                break;
            }
            idx += 1;
        }
        if idx >= len {
            let msg = match context {
                FormatContext::FormatSpec => "unmatched '{' in format spec",
                FormatContext::FormatString => "expected '}' before end of string",
            };
            return raise_exception::<_>(_py, "ValueError", msg);
        }
        format_spec = &text[spec_start..idx];
    }
    if idx >= len || bytes[idx] != b'}' {
        let msg = match context {
            FormatContext::FormatSpec => "unmatched '{' in format spec",
            FormatContext::FormatString => "expected '}' before end of string",
        };
        return raise_exception::<_>(_py, "ValueError", msg);
    }
    let next_idx = idx + 1;
    Some((
        FormatField {
            field_name,
            conversion,
            format_spec,
        },
        next_idx,
    ))
}

fn format_string_impl(
    _py: &PyToken<'_>,
    text: &str,
    args: &[u64],
    kwargs_bits: u64,
    state: &mut FormatState,
    context: FormatContext,
) -> Option<String> {
    let bytes = text.as_bytes();
    let len = bytes.len();
    let mut out = String::with_capacity(text.len());
    let mut idx = 0usize;
    while idx < len {
        let b = bytes[idx];
        if b == b'{' {
            if idx + 1 < len && bytes[idx + 1] == b'{' {
                out.push('{');
                idx += 2;
                continue;
            }
            let (field, next_idx) = parse_format_field(_py, text, idx + 1, context)?;
            let rendered = format_field(_py, field, args, kwargs_bits, state)?;
            out.push_str(&rendered);
            idx = next_idx;
            continue;
        }
        if b == b'}' {
            if idx + 1 < len && bytes[idx + 1] == b'}' {
                out.push('}');
                idx += 2;
                continue;
            }
            return format_raise_value_error_str(_py, "Single '}' encountered in format string");
        }
        let start = idx;
        idx += 1;
        while idx < len && bytes[idx] != b'{' && bytes[idx] != b'}' {
            idx += 1;
        }
        out.push_str(&text[start..idx]);
    }
    Some(out)
}

fn resolve_format_field(
    _py: &PyToken<'_>,
    field_name: &str,
    args: &[u64],
    kwargs_bits: u64,
    state: &mut FormatState,
) -> Option<u64> {
    let bytes = field_name.as_bytes();
    let len = bytes.len();
    let mut idx = 0usize;
    while idx < len && bytes[idx] != b'.' && bytes[idx] != b'[' {
        idx += 1;
    }
    let base = &field_name[..idx];
    let base_bits = if base.is_empty() {
        if state.used_manual {
            return format_raise_value_error_bits(
                _py,
                "cannot switch from manual field specification to automatic field numbering",
            );
        }
        state.used_auto = true;
        let index = state.next_auto;
        state.next_auto += 1;
        if index >= args.len() {
            let msg = format!("Replacement index {index} out of range for positional args tuple");
            return format_raise_index_error_bits(_py, &msg);
        }
        args[index]
    } else if base.as_bytes().iter().all(|b| b.is_ascii_digit()) {
        if state.used_auto {
            return format_raise_value_error_bits(
                _py,
                "cannot switch from automatic field numbering to manual field specification",
            );
        }
        state.used_manual = true;
        let index = match base.parse::<usize>() {
            Ok(val) => val,
            Err(_) => {
                return format_raise_value_error_bits(
                    _py,
                    "Too many decimal digits in format string",
                );
            }
        };
        if index >= args.len() {
            let msg = format!("Replacement index {base} out of range for positional args tuple");
            return format_raise_index_error_bits(_py, &msg);
        }
        args[index]
    } else {
        if state.used_auto {
            return format_raise_value_error_bits(
                _py,
                "cannot switch from automatic field numbering to manual field specification",
            );
        }
        state.used_manual = true;
        let key_ptr = alloc_string(_py, base.as_bytes());
        if key_ptr.is_null() {
            return None;
        }
        let key_bits = MoltObject::from_ptr(key_ptr).bits();
        let kwargs_obj = obj_from_bits(kwargs_bits);
        let mut val_bits = None;
        if let Some(dict_ptr) = kwargs_obj.as_ptr() {
            unsafe {
                if object_type_id(dict_ptr) == TYPE_ID_DICT {
                    val_bits = dict_get_in_place(_py, dict_ptr, key_bits);
                }
            }
        }
        if val_bits.is_none() {
            raise_key_error_with_key::<()>(_py, key_bits);
            dec_ref_bits(_py, key_bits);
            return None;
        }
        dec_ref_bits(_py, key_bits);
        val_bits.unwrap()
    };
    let mut current_bits = base_bits;
    while idx < len {
        if bytes[idx] == b'.' {
            idx += 1;
            if idx >= len {
                return format_raise_value_error_bits(_py, "Empty attribute in format string");
            }
            let start = idx;
            while idx < len && bytes[idx] != b'.' && bytes[idx] != b'[' {
                idx += 1;
            }
            let attr = &field_name[start..idx];
            if attr.is_empty() {
                return format_raise_value_error_bits(_py, "Empty attribute in format string");
            }
            let attr_ptr = alloc_string(_py, attr.as_bytes());
            if attr_ptr.is_null() {
                return None;
            }
            let attr_bits = MoltObject::from_ptr(attr_ptr).bits();
            current_bits = molt_get_attr_name(current_bits, attr_bits);
            dec_ref_bits(_py, attr_bits);
            if exception_pending(_py) {
                return None;
            }
            continue;
        }
        if bytes[idx] == b'[' {
            idx += 1;
            if idx >= len {
                return format_raise_value_error_bits(_py, "expected '}' before end of string");
            }
            let start = idx;
            while idx < len && bytes[idx] != b']' {
                idx += 1;
            }
            if idx >= len {
                return format_raise_value_error_bits(_py, "expected '}' before end of string");
            }
            let key = &field_name[start..idx];
            if key.is_empty() {
                return format_raise_value_error_bits(_py, "Empty attribute in format string");
            }
            idx += 1;
            if idx < len && bytes[idx] != b'.' && bytes[idx] != b'[' {
                return format_raise_value_error_bits(
                    _py,
                    "Only '.' or '[' may follow ']' in format field specifier",
                );
            }
            let (key_bits, drop_key) = if key.as_bytes().iter().all(|b| b.is_ascii_digit()) {
                let val = match key.parse::<i64>() {
                    Ok(num) => num,
                    Err(_) => {
                        return format_raise_value_error_bits(
                            _py,
                            "Too many decimal digits in format string",
                        );
                    }
                };
                (MoltObject::from_int(val).bits(), false)
            } else {
                let key_ptr = alloc_string(_py, key.as_bytes());
                if key_ptr.is_null() {
                    return None;
                }
                (MoltObject::from_ptr(key_ptr).bits(), true)
            };
            current_bits = molt_index(current_bits, key_bits);
            if drop_key {
                dec_ref_bits(_py, key_bits);
            }
            if exception_pending(_py) {
                return None;
            }
            continue;
        }
        break;
    }
    Some(current_bits)
}

fn format_field(
    _py: &PyToken<'_>,
    field: FormatField,
    args: &[u64],
    kwargs_bits: u64,
    state: &mut FormatState,
) -> Option<String> {
    let mut value_bits = resolve_format_field(_py, field.field_name, args, kwargs_bits, state)?;
    if exception_pending(_py) {
        return None;
    }
    let mut drop_value = false;
    if let Some(conv) = field.conversion {
        value_bits = match conv {
            'r' => {
                drop_value = true;
                molt_repr_from_obj(value_bits)
            }
            's' => {
                drop_value = true;
                molt_str_from_obj(value_bits)
            }
            'a' => {
                drop_value = true;
                molt_ascii_from_obj(value_bits)
            }
            _ => value_bits,
        };
        if exception_pending(_py) {
            return None;
        }
    }
    let spec_text = if field.format_spec.is_empty() {
        String::new()
    } else {
        format_string_impl(
            _py,
            field.format_spec,
            args,
            kwargs_bits,
            state,
            FormatContext::FormatSpec,
        )?
    };
    let spec_ptr = alloc_string(_py, spec_text.as_bytes());
    if spec_ptr.is_null() {
        return None;
    }
    let spec_bits = MoltObject::from_ptr(spec_ptr).bits();
    let formatted_bits = molt_format_builtin(value_bits, spec_bits);
    dec_ref_bits(_py, spec_bits);
    if drop_value {
        dec_ref_bits(_py, value_bits);
    }
    if exception_pending(_py) {
        return None;
    }
    let formatted_obj = obj_from_bits(formatted_bits);
    let rendered =
        string_obj_to_owned(formatted_obj).unwrap_or_else(|| format_obj_str(_py, formatted_obj));
    dec_ref_bits(_py, formatted_bits);
    Some(rendered)
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_format_method(
    self_bits: u64,
    args_bits: u64,
    kwargs_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let self_obj = obj_from_bits(self_bits);
        let Some(self_ptr) = self_obj.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(self_ptr) != TYPE_ID_STRING {
                return raise_exception::<_>(_py, "TypeError", "format requires a string");
            }
            let text = string_obj_to_owned(self_obj).unwrap_or_default();
            let args_obj = obj_from_bits(args_bits);
            let Some(args_ptr) = args_obj.as_ptr() else {
                return raise_exception::<_>(_py, "TypeError", "format arguments must be a tuple");
            };
            if object_type_id(args_ptr) != TYPE_ID_TUPLE {
                return raise_exception::<_>(_py, "TypeError", "format arguments must be a tuple");
            }
            let args_vec = seq_vec_ref(args_ptr);
            let mut state = FormatState {
                next_auto: 0,
                used_auto: false,
                used_manual: false,
            };
            let Some(rendered) = format_string_impl(
                _py,
                &text,
                args_vec.as_slice(),
                kwargs_bits,
                &mut state,
                FormatContext::FormatString,
            ) else {
                return MoltObject::none().bits();
            };
            let out_ptr = alloc_string(_py, rendered.as_bytes());
            if out_ptr.is_null() {
                return MoltObject::none().bits();
            }
            MoltObject::from_ptr(out_ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_format(val_bits: u64, spec_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let spec_obj = obj_from_bits(spec_bits);
        let spec_ptr = match spec_obj.as_ptr() {
            Some(ptr) => ptr,
            None => return raise_exception::<_>(_py, "TypeError", "format spec must be a str"),
        };
        unsafe {
            if object_type_id(spec_ptr) != TYPE_ID_STRING {
                return raise_exception::<_>(_py, "TypeError", "format spec must be a str");
            }
            let spec_bytes =
                std::slice::from_raw_parts(string_bytes(spec_ptr), string_len(spec_ptr));
            let spec_text = match std::str::from_utf8(spec_bytes) {
                Ok(val) => val,
                Err(_) => {
                    return raise_exception::<_>(
                        _py,
                        "ValueError",
                        "format spec must be valid UTF-8",
                    );
                }
            };
            let spec = match parse_format_spec(spec_text) {
                Ok(val) => val,
                Err(msg) => return raise_exception::<_>(_py, "ValueError", msg),
            };
            let obj = obj_from_bits(val_bits);
            let rendered = match format_with_spec(_py, obj, &spec) {
                Ok(val) => val,
                Err((kind, msg)) => return raise_exception::<_>(_py, kind, msg.as_ref()),
            };
            let out_ptr = alloc_string(_py, rendered.as_bytes());
            if out_ptr.is_null() {
                return MoltObject::none().bits();
            }
            MoltObject::from_ptr(out_ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_find(hay_bits: u64, needle_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let none_bits = MoltObject::none().bits();
        let false_bits = MoltObject::from_bool(false).bits();
        molt_bytes_find_slice(
            hay_bits,
            needle_bits,
            none_bits,
            none_bits,
            false_bits,
            false_bits,
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_find_slice(
    hay_bits: u64,
    needle_bits: u64,
    start_bits: u64,
    end_bits: u64,
    has_start_bits: u64,
    has_end_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let has_start = to_i64(obj_from_bits(has_start_bits)).unwrap_or(0) != 0;
        let has_end = to_i64(obj_from_bits(has_end_bits)).unwrap_or(0) != 0;
        if let Some(hay_ptr) = hay.as_ptr() {
            unsafe {
                if object_type_id(hay_ptr) != TYPE_ID_BYTES {
                    return MoltObject::none().bits();
                }
                let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
                let total = hay_bytes.len() as i64;
                let (start, end, start_raw) =
                    slice_bounds_from_args(_py, start_bits, end_bits, has_start, has_end, total);
                if end < start {
                    return MoltObject::from_int(-1).bits();
                }
                let slice = &hay_bytes[start as usize..end as usize];
                if let Some(byte) = needle.as_int() {
                    if !(0..=255).contains(&byte) {
                        return raise_exception::<_>(
                            _py,
                            "ValueError",
                            "byte must be in range(0, 256)",
                        );
                    }
                    let idx = match memchr(byte as u8, slice) {
                        Some(pos) => start + pos as i64,
                        None => -1,
                    };
                    return MoltObject::from_int(idx).bits();
                }
                let needle_ptr = match needle.as_ptr() {
                    Some(ptr) => ptr,
                    None => {
                        let msg = format!(
                            "argument should be integer or bytes-like object, not '{}'",
                            type_name(_py, needle)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                let needle_bytes = match bytes_like_slice(needle_ptr) {
                    Some(slice) => slice,
                    None => {
                        let msg = format!(
                            "argument should be integer or bytes-like object, not '{}'",
                            type_name(_py, needle)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                if needle_bytes.is_empty() {
                    if start_raw > total {
                        return MoltObject::from_int(-1).bits();
                    }
                    return MoltObject::from_int(start).bits();
                }
                let idx = bytes_find_impl(slice, needle_bytes);
                let out = if idx < 0 { -1 } else { start + idx };
                MoltObject::from_int(out).bits()
            }
        } else {
            MoltObject::none().bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_rfind(hay_bits: u64, needle_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let none_bits = MoltObject::none().bits();
        let false_bits = MoltObject::from_bool(false).bits();
        molt_bytes_rfind_slice(
            hay_bits,
            needle_bits,
            none_bits,
            none_bits,
            false_bits,
            false_bits,
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_rfind_slice(
    hay_bits: u64,
    needle_bits: u64,
    start_bits: u64,
    end_bits: u64,
    has_start_bits: u64,
    has_end_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let has_start = to_i64(obj_from_bits(has_start_bits)).unwrap_or(0) != 0;
        let has_end = to_i64(obj_from_bits(has_end_bits)).unwrap_or(0) != 0;
        if let Some(hay_ptr) = hay.as_ptr() {
            unsafe {
                if object_type_id(hay_ptr) != TYPE_ID_BYTES {
                    return MoltObject::none().bits();
                }
                let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
                let total = hay_bytes.len() as i64;
                let (start, end, start_raw) =
                    slice_bounds_from_args(_py, start_bits, end_bits, has_start, has_end, total);
                if end < start {
                    return MoltObject::from_int(-1).bits();
                }
                let slice = &hay_bytes[start as usize..end as usize];
                if let Some(byte) = needle.as_int() {
                    if !(0..=255).contains(&byte) {
                        return raise_exception::<_>(
                            _py,
                            "ValueError",
                            "byte must be in range(0, 256)",
                        );
                    }
                    let idx = match memchr::memrchr(byte as u8, slice) {
                        Some(pos) => start + pos as i64,
                        None => -1,
                    };
                    return MoltObject::from_int(idx).bits();
                }
                let needle_ptr = match needle.as_ptr() {
                    Some(ptr) => ptr,
                    None => {
                        let msg = format!(
                            "argument should be integer or bytes-like object, not '{}'",
                            type_name(_py, needle)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                let needle_bytes = match bytes_like_slice(needle_ptr) {
                    Some(slice) => slice,
                    None => {
                        let msg = format!(
                            "argument should be integer or bytes-like object, not '{}'",
                            type_name(_py, needle)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                if needle_bytes.is_empty() {
                    if start_raw > total {
                        return MoltObject::from_int(-1).bits();
                    }
                    return MoltObject::from_int(end).bits();
                }
                let idx = bytes_rfind_impl(slice, needle_bytes);
                let out = if idx < 0 { -1 } else { start + idx };
                MoltObject::from_int(out).bits()
            }
        } else {
            MoltObject::none().bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_startswith(hay_bits: u64, needle_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let none_bits = MoltObject::none().bits();
        let false_bits = MoltObject::from_bool(false).bits();
        molt_bytes_startswith_slice(
            hay_bits,
            needle_bits,
            none_bits,
            none_bits,
            false_bits,
            false_bits,
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_endswith(hay_bits: u64, needle_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let none_bits = MoltObject::none().bits();
        let false_bits = MoltObject::from_bool(false).bits();
        molt_bytes_endswith_slice(
            hay_bits,
            needle_bits,
            none_bits,
            none_bits,
            false_bits,
            false_bits,
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_startswith_slice(
    hay_bits: u64,
    needle_bits: u64,
    start_bits: u64,
    end_bits: u64,
    has_start_bits: u64,
    has_end_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let has_start = to_i64(obj_from_bits(has_start_bits)).unwrap_or(0) != 0;
        let has_end = to_i64(obj_from_bits(has_end_bits)).unwrap_or(0) != 0;
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_BYTES {
                return MoltObject::none().bits();
            }
            let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
            let total = hay_bytes.len() as i64;
            let (start, end, start_raw) =
                slice_bounds_from_args(_py, start_bits, end_bits, has_start, has_end, total);
            if end < start {
                return MoltObject::from_bool(false).bits();
            }
            let slice = &hay_bytes[start as usize..end as usize];
            if let Some(needle_ptr) = needle.as_ptr() {
                let needle_type = object_type_id(needle_ptr);
                if needle_type == TYPE_ID_TUPLE {
                    let elems = seq_vec_ref(needle_ptr);
                    if elems.is_empty() {
                        return MoltObject::from_bool(false).bits();
                    }
                    for &elem_bits in elems.iter() {
                        let elem = obj_from_bits(elem_bits);
                        let elem_ptr = match elem.as_ptr() {
                            Some(ptr) => ptr,
                            None => {
                                let msg = format!(
                                    "a bytes-like object is required, not '{}'",
                                    type_name(_py, elem)
                                );
                                return raise_exception::<_>(_py, "TypeError", &msg);
                            }
                        };
                        let needle_bytes = match bytes_like_slice(elem_ptr) {
                            Some(slice) => slice,
                            None => {
                                let msg = format!(
                                    "a bytes-like object is required, not '{}'",
                                    type_name(_py, elem)
                                );
                                return raise_exception::<_>(_py, "TypeError", &msg);
                            }
                        };
                        if slice_match(slice, needle_bytes, start_raw, total, false) {
                            return MoltObject::from_bool(true).bits();
                        }
                    }
                    return MoltObject::from_bool(false).bits();
                }
                if let Some(needle_bytes) = bytes_like_slice(needle_ptr) {
                    let ok = slice_match(slice, needle_bytes, start_raw, total, false);
                    return MoltObject::from_bool(ok).bits();
                }
            }
            let msg = format!(
                "startswith first arg must be bytes or a tuple of bytes, not {}",
                type_name(_py, needle)
            );
            raise_exception::<_>(_py, "TypeError", &msg)
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_endswith_slice(
    hay_bits: u64,
    needle_bits: u64,
    start_bits: u64,
    end_bits: u64,
    has_start_bits: u64,
    has_end_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let has_start = to_i64(obj_from_bits(has_start_bits)).unwrap_or(0) != 0;
        let has_end = to_i64(obj_from_bits(has_end_bits)).unwrap_or(0) != 0;
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_BYTES {
                return MoltObject::none().bits();
            }
            let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
            let total = hay_bytes.len() as i64;
            let (start, end, start_raw) =
                slice_bounds_from_args(_py, start_bits, end_bits, has_start, has_end, total);
            if end < start {
                return MoltObject::from_bool(false).bits();
            }
            let slice = &hay_bytes[start as usize..end as usize];
            if let Some(needle_ptr) = needle.as_ptr() {
                let needle_type = object_type_id(needle_ptr);
                if needle_type == TYPE_ID_TUPLE {
                    let elems = seq_vec_ref(needle_ptr);
                    if elems.is_empty() {
                        return MoltObject::from_bool(false).bits();
                    }
                    for &elem_bits in elems.iter() {
                        let elem = obj_from_bits(elem_bits);
                        let elem_ptr = match elem.as_ptr() {
                            Some(ptr) => ptr,
                            None => {
                                let msg = format!(
                                    "a bytes-like object is required, not '{}'",
                                    type_name(_py, elem)
                                );
                                return raise_exception::<_>(_py, "TypeError", &msg);
                            }
                        };
                        let needle_bytes = match bytes_like_slice(elem_ptr) {
                            Some(slice) => slice,
                            None => {
                                let msg = format!(
                                    "a bytes-like object is required, not '{}'",
                                    type_name(_py, elem)
                                );
                                return raise_exception::<_>(_py, "TypeError", &msg);
                            }
                        };
                        if slice_match(slice, needle_bytes, start_raw, total, true) {
                            return MoltObject::from_bool(true).bits();
                        }
                    }
                    return MoltObject::from_bool(false).bits();
                }
                if let Some(needle_bytes) = bytes_like_slice(needle_ptr) {
                    let ok = slice_match(slice, needle_bytes, start_raw, total, true);
                    return MoltObject::from_bool(ok).bits();
                }
            }
            let msg = format!(
                "endswith first arg must be bytes or a tuple of bytes, not {}",
                type_name(_py, needle)
            );
            raise_exception::<_>(_py, "TypeError", &msg)
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_count(hay_bits: u64, needle_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_BYTES {
                return MoltObject::none().bits();
            }
            let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
            if let Some(byte) = needle.as_int() {
                if !(0..=255).contains(&byte) {
                    return raise_exception::<_>(
                        _py,
                        "ValueError",
                        "byte must be in range(0, 256)",
                    );
                }
                let count = memchr::memchr_iter(byte as u8, hay_bytes).count() as i64;
                return MoltObject::from_int(count).bits();
            }
            let needle_ptr = match needle.as_ptr() {
                Some(ptr) => ptr,
                None => {
                    let msg = format!(
                        "argument should be integer or bytes-like object, not '{}'",
                        type_name(_py, needle)
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            };
            let needle_bytes = match bytes_like_slice(needle_ptr) {
                Some(slice) => slice,
                None => {
                    let msg = format!(
                        "argument should be integer or bytes-like object, not '{}'",
                        type_name(_py, needle)
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            };
            let count = bytes_count_impl(hay_bytes, needle_bytes);
            MoltObject::from_int(count).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_count_slice(
    hay_bits: u64,
    needle_bits: u64,
    start_bits: u64,
    end_bits: u64,
    has_start_bits: u64,
    has_end_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let has_start = to_i64(obj_from_bits(has_start_bits)).unwrap_or(0) != 0;
        let has_end = to_i64(obj_from_bits(has_end_bits)).unwrap_or(0) != 0;
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_BYTES {
                return MoltObject::none().bits();
            }
            let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
            let total = hay_bytes.len() as i64;
            let (start, end, start_raw) =
                slice_bounds_from_args(_py, start_bits, end_bits, has_start, has_end, total);
            if end < start {
                return MoltObject::from_int(0).bits();
            }
            if let Some(byte) = needle.as_int() {
                if !(0..=255).contains(&byte) {
                    return raise_exception::<_>(
                        _py,
                        "ValueError",
                        "byte must be in range(0, 256)",
                    );
                }
                let slice = &hay_bytes[start as usize..end as usize];
                let count = memchr::memchr_iter(byte as u8, slice).count() as i64;
                return MoltObject::from_int(count).bits();
            }
            let needle_ptr = match needle.as_ptr() {
                Some(ptr) => ptr,
                None => {
                    let msg = format!(
                        "argument should be integer or bytes-like object, not '{}'",
                        type_name(_py, needle)
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            };
            let needle_bytes = match bytes_like_slice(needle_ptr) {
                Some(slice) => slice,
                None => {
                    let msg = format!(
                        "argument should be integer or bytes-like object, not '{}'",
                        type_name(_py, needle)
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            };
            if needle_bytes.is_empty() {
                if start_raw > total {
                    return MoltObject::from_int(0).bits();
                }
                let count = end - start + 1;
                return MoltObject::from_int(count).bits();
            }
            let slice = &hay_bytes[start as usize..end as usize];
            let count = bytes_count_impl(slice, needle_bytes);
            MoltObject::from_int(count).bits()
        }
    })
}

fn build_utf8_cache(bytes: &[u8]) -> Utf8IndexCache {
    let mut offsets = Vec::new();
    let mut prefix = Vec::new();
    let mut total = 0i64;
    let mut idx = 0usize;
    offsets.push(0);
    prefix.push(0);
    while idx < bytes.len() {
        let mut end = (idx + UTF8_CACHE_BLOCK).min(bytes.len());
        while end < bytes.len() && (bytes[end] & 0b1100_0000) == 0b1000_0000 {
            end += 1;
        }
        total += count_utf8_bytes(&bytes[idx..end]);
        offsets.push(end);
        prefix.push(total);
        idx = end;
    }
    Utf8IndexCache { offsets, prefix }
}

fn utf8_cache_get_or_build(
    _py: &PyToken<'_>,
    key: usize,
    bytes: &[u8],
) -> Option<Arc<Utf8IndexCache>> {
    if bytes.len() < UTF8_CACHE_MIN_LEN || bytes.is_ascii() {
        return None;
    }
    if let Ok(store) = runtime_state(_py).utf8_index_cache.lock() {
        if let Some(cache) = store.get(key) {
            return Some(cache);
        }
    }
    let cache = Arc::new(build_utf8_cache(bytes));
    if let Ok(mut store) = runtime_state(_py).utf8_index_cache.lock() {
        if let Some(existing) = store.get(key) {
            return Some(existing);
        }
        store.insert(key, cache.clone());
    }
    Some(cache)
}

pub(crate) fn utf8_cache_remove(_py: &PyToken<'_>, key: usize) {
    if let Ok(mut store) = runtime_state(_py).utf8_index_cache.lock() {
        store.remove(key);
    }
    utf8_count_cache_remove(_py, key);
    utf8_count_cache_tls_remove(key);
}

fn utf8_count_cache_shard(key: usize) -> usize {
    let mut x = key as u64;
    x ^= x >> 33;
    x = x.wrapping_mul(0xff51afd7ed558ccd);
    x ^= x >> 33;
    (x as usize) & (UTF8_COUNT_CACHE_SHARDS - 1)
}

fn utf8_count_cache_remove(_py: &PyToken<'_>, key: usize) {
    let shard = utf8_count_cache_shard(key);
    if let Some(store) = runtime_state(_py).utf8_count_cache.get(shard) {
        if let Ok(mut guard) = store.lock() {
            guard.remove(key);
        }
    }
}

fn utf8_count_cache_lookup(
    _py: &PyToken<'_>,
    key: usize,
    needle: &[u8],
) -> Option<Arc<Utf8CountCache>> {
    if let Some(cache) = UTF8_COUNT_TLS.with(|cell| {
        cell.borrow().as_ref().and_then(|entry| {
            if entry.key == key && entry.cache.needle == needle {
                Some(entry.cache.clone())
            } else {
                None
            }
        })
    }) {
        profile_hit(_py, &runtime_state(_py).string_count_cache_hit);
        return Some(cache);
    }
    let shard = utf8_count_cache_shard(key);
    let store = runtime_state(_py)
        .utf8_count_cache
        .get(shard)?
        .lock()
        .ok()?;
    let cache = store.get(key)?;
    if cache.needle == needle {
        profile_hit(_py, &runtime_state(_py).string_count_cache_hit);
        return Some(cache);
    }
    None
}

fn build_utf8_count_prefix(hay_bytes: &[u8], needle: &[u8]) -> Vec<i64> {
    if hay_bytes.len() < UTF8_COUNT_PREFIX_MIN_LEN || needle.is_empty() {
        return Vec::new();
    }
    let blocks = hay_bytes.len().div_ceil(UTF8_CACHE_BLOCK);
    let mut prefix = vec![0i64; blocks + 1];
    let mut count = 0i64;
    let mut idx = 1usize;
    let mut next_boundary = UTF8_CACHE_BLOCK.min(hay_bytes.len());
    let finder = memmem::Finder::new(needle);
    for pos in finder.find_iter(hay_bytes) {
        while pos >= next_boundary && idx < prefix.len() {
            prefix[idx] = count;
            idx += 1;
            next_boundary = (next_boundary + UTF8_CACHE_BLOCK).min(hay_bytes.len());
        }
        count += 1;
    }
    while idx < prefix.len() {
        prefix[idx] = count;
        idx += 1;
    }
    prefix
}

fn utf8_count_cache_store(
    _py: &PyToken<'_>,
    key: usize,
    hay_bytes: &[u8],
    needle: &[u8],
    count: i64,
    prefix: Vec<i64>,
) {
    let cache = Arc::new(Utf8CountCache {
        needle: needle.to_vec(),
        count,
        prefix,
        hay_len: hay_bytes.len(),
    });
    let shard = utf8_count_cache_shard(key);
    if let Some(store) = runtime_state(_py).utf8_count_cache.get(shard) {
        if let Ok(mut guard) = store.lock() {
            guard.insert(key, cache.clone());
        }
    }
    UTF8_COUNT_TLS.with(|cell| {
        *cell.borrow_mut() = Some(Utf8CountCacheEntry { key, cache });
    });
}

fn utf8_count_cache_upgrade_prefix(
    _py: &PyToken<'_>,
    key: usize,
    cache: &Arc<Utf8CountCache>,
    hay_bytes: &[u8],
) -> Arc<Utf8CountCache> {
    if !cache.prefix.is_empty()
        || cache.hay_len != hay_bytes.len()
        || hay_bytes.len() < UTF8_COUNT_PREFIX_MIN_LEN
        || cache.needle.is_empty()
    {
        return cache.clone();
    }
    let prefix = build_utf8_count_prefix(hay_bytes, &cache.needle);
    if prefix.is_empty() {
        return cache.clone();
    }
    let upgraded = Arc::new(Utf8CountCache {
        needle: cache.needle.clone(),
        count: cache.count,
        prefix,
        hay_len: cache.hay_len,
    });
    let shard = utf8_count_cache_shard(key);
    if let Some(store) = runtime_state(_py).utf8_count_cache.get(shard) {
        if let Ok(mut guard) = store.lock() {
            guard.insert(key, upgraded.clone());
        }
    }
    UTF8_COUNT_TLS.with(|cell| {
        *cell.borrow_mut() = Some(Utf8CountCacheEntry {
            key,
            cache: upgraded.clone(),
        });
    });
    upgraded
}

fn utf8_count_cache_tls_remove(key: usize) {
    UTF8_COUNT_TLS.with(|cell| {
        let mut guard = cell.borrow_mut();
        if guard.as_ref().is_some_and(|entry| entry.key == key) {
            *guard = None;
        }
    });
}

fn count_matches_range(
    hay_bytes: &[u8],
    needle: &[u8],
    window_start: usize,
    window_end: usize,
    start_min: usize,
    start_max: usize,
) -> i64 {
    if window_end <= window_start || start_min > start_max {
        return 0;
    }
    let finder = memmem::Finder::new(needle);
    let mut count = 0i64;
    for pos in finder.find_iter(&hay_bytes[window_start..window_end]) {
        let abs = window_start + pos;
        if abs < start_min {
            continue;
        }
        if abs > start_max {
            break;
        }
        count += 1;
    }
    count
}

fn utf8_count_cache_count_slice(
    cache: &Utf8CountCache,
    hay_bytes: &[u8],
    start: usize,
    end: usize,
) -> i64 {
    let needle = &cache.needle;
    let needle_len = needle.len();
    if needle_len == 0 || end <= start {
        return 0;
    }
    if end - start < needle_len {
        return 0;
    }
    if cache.prefix.is_empty() || cache.hay_len != hay_bytes.len() {
        return bytes_count_impl(&hay_bytes[start..end], needle);
    }
    let end_limit = end - needle_len;
    let block = UTF8_CACHE_BLOCK;
    let start_block = start / block;
    let end_block = end_limit / block;
    if start_block == end_block {
        return bytes_count_impl(&hay_bytes[start..end], needle);
    }
    let mut total = 0i64;
    let block_end = ((start_block + 1) * block).min(hay_bytes.len());
    let left_scan_end = (block_end + needle_len - 1).min(end);
    let left_max = (block_end.saturating_sub(1)).min(end_limit);
    total += count_matches_range(hay_bytes, needle, start, left_scan_end, start, left_max);
    if end_block > start_block + 1 {
        total += cache.prefix[end_block] - cache.prefix[start_block + 1];
    }
    let right_block_start = (end_block * block).min(hay_bytes.len());
    if right_block_start <= end_limit {
        total += count_matches_range(
            hay_bytes,
            needle,
            right_block_start,
            end,
            right_block_start,
            end_limit,
        );
    }
    total
}

fn utf8_count_prefix_cached(bytes: &[u8], cache: &Utf8IndexCache, prefix_len: usize) -> i64 {
    let prefix_len = prefix_len.min(bytes.len());
    let block_idx = match cache.offsets.binary_search(&prefix_len) {
        Ok(idx) => idx,
        Err(idx) => idx.saturating_sub(1),
    };
    let mut total = *cache.prefix.get(block_idx).unwrap_or(&0);
    let start = *cache.offsets.get(block_idx).unwrap_or(&0);
    if start < prefix_len {
        total += count_utf8_bytes(&bytes[start..prefix_len]);
    }
    total
}

pub(crate) fn utf8_codepoint_count_cached(
    _py: &PyToken<'_>,
    bytes: &[u8],
    cache_key: Option<usize>,
) -> i64 {
    if bytes.is_ascii() {
        return bytes.len() as i64;
    }
    if let Some(key) = cache_key {
        if let Some(cache) = utf8_cache_get_or_build(_py, key, bytes) {
            return *cache.prefix.last().unwrap_or(&0);
        }
    }
    utf8_count_prefix_blocked(bytes, bytes.len())
}

fn utf8_byte_to_char_index_cached(
    _py: &PyToken<'_>,
    bytes: &[u8],
    byte_idx: usize,
    cache_key: Option<usize>,
) -> i64 {
    if byte_idx == 0 {
        return 0;
    }
    if bytes.is_ascii() {
        return byte_idx.min(bytes.len()) as i64;
    }
    let prefix_len = byte_idx.min(bytes.len());
    if let Some(key) = cache_key {
        if let Some(cache) = utf8_cache_get_or_build(_py, key, bytes) {
            return utf8_count_prefix_cached(bytes, &cache, prefix_len);
        }
    }
    utf8_count_prefix_blocked(bytes, prefix_len)
}

fn wtf8_from_bytes(bytes: &[u8]) -> &Wtf8 {
    // SAFETY: Molt string bytes are constructed as well-formed WTF-8.
    unsafe { &*(bytes as *const [u8] as *const Wtf8) }
}

fn wtf8_codepoint_at(bytes: &[u8], idx: usize) -> Option<CodePoint> {
    wtf8_from_bytes(bytes).code_points().nth(idx)
}

fn wtf8_codepoint_count_scan(bytes: &[u8]) -> i64 {
    let mut idx = 0usize;
    let mut count = 0i64;
    while idx < bytes.len() {
        let width = utf8_char_width(bytes[idx]);
        if width == 0 {
            idx = idx.saturating_add(1);
        } else {
            idx = idx.saturating_add(width);
        }
        count += 1;
    }
    count
}

fn wtf8_has_surrogates(bytes: &[u8]) -> bool {
    wtf8_from_bytes(bytes).as_str().is_none()
}

fn push_wtf8_codepoint(out: &mut Vec<u8>, code: u32) {
    if code <= 0x7F {
        out.push(code as u8);
    } else if code <= 0x7FF {
        out.push(0xC0 | ((code >> 6) as u8));
        out.push(0x80 | (code as u8 & 0x3F));
    } else if code <= 0xFFFF {
        out.push(0xE0 | ((code >> 12) as u8));
        out.push(0x80 | (((code >> 6) as u8) & 0x3F));
        out.push(0x80 | (code as u8 & 0x3F));
    } else {
        out.push(0xF0 | ((code >> 18) as u8));
        out.push(0x80 | (((code >> 12) as u8) & 0x3F));
        out.push(0x80 | (((code >> 6) as u8) & 0x3F));
        out.push(0x80 | (code as u8 & 0x3F));
    }
}

fn utf8_char_width(first: u8) -> usize {
    if first < 0xC0 {
        1
    } else if first < 0xE0 {
        2
    } else if first < 0xF0 {
        3
    } else if first < 0xF8 {
        4
    } else {
        1
    }
}

fn utf8_char_to_byte_index_scan(bytes: &[u8], target: usize) -> usize {
    let mut idx = 0usize;
    let mut count = 0usize;
    while idx < bytes.len() && count < target {
        let width = utf8_char_width(bytes[idx]);
        idx = idx.saturating_add(width);
        count = count.saturating_add(1);
    }
    idx.min(bytes.len())
}

fn utf8_char_to_byte_index_cached(
    _py: &PyToken<'_>,
    bytes: &[u8],
    char_idx: i64,
    cache_key: Option<usize>,
) -> usize {
    if char_idx <= 0 {
        return 0;
    }
    if bytes.is_ascii() {
        return (char_idx as usize).min(bytes.len());
    }
    let total = utf8_codepoint_count_cached(_py, bytes, cache_key);
    if char_idx >= total {
        return bytes.len();
    }
    let target = char_idx as usize;
    if let Some(key) = cache_key {
        if let Some(cache) = utf8_cache_get_or_build(_py, key, bytes) {
            let mut lo = 0usize;
            let mut hi = cache.prefix.len().saturating_sub(1);
            while lo < hi {
                let mid = (lo + hi).div_ceil(2);
                if (cache.prefix.get(mid).copied().unwrap_or(0) as usize) <= target {
                    lo = mid;
                } else {
                    hi = mid.saturating_sub(1);
                }
            }
            let mut count = cache.prefix.get(lo).copied().unwrap_or(0) as usize;
            let mut idx = cache.offsets.get(lo).copied().unwrap_or(0);
            while idx < bytes.len() && count < target {
                let width = utf8_char_width(bytes[idx]);
                idx = idx.saturating_add(width);
                count = count.saturating_add(1);
            }
            return idx.min(bytes.len());
        }
    }
    utf8_char_to_byte_index_scan(bytes, target)
}

fn utf8_count_prefix_blocked(bytes: &[u8], prefix_len: usize) -> i64 {
    const BLOCK: usize = 4096;
    let mut total = 0i64;
    let mut idx = 0usize;
    while idx + BLOCK <= prefix_len {
        total += count_utf8_bytes(&bytes[idx..idx + BLOCK]);
        idx += BLOCK;
    }
    if idx < prefix_len {
        total += count_utf8_bytes(&bytes[idx..prefix_len]);
    }
    total
}

#[cfg(not(target_arch = "wasm32"))]
fn count_utf8_bytes(bytes: &[u8]) -> i64 {
    if std::str::from_utf8(bytes).is_ok() {
        simdutf::count_utf8(bytes) as i64
    } else {
        wtf8_codepoint_count_scan(bytes)
    }
}

#[cfg(target_arch = "wasm32")]
fn count_utf8_bytes(bytes: &[u8]) -> i64 {
    wtf8_codepoint_count_scan(bytes)
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_find(hay_bits: u64, needle_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let none_bits = MoltObject::none().bits();
        let false_bits = MoltObject::from_bool(false).bits();
        molt_bytearray_find_slice(
            hay_bits,
            needle_bits,
            none_bits,
            none_bits,
            false_bits,
            false_bits,
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_rfind(hay_bits: u64, needle_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let none_bits = MoltObject::none().bits();
        let false_bits = MoltObject::from_bool(false).bits();
        molt_bytearray_rfind_slice(
            hay_bits,
            needle_bits,
            none_bits,
            none_bits,
            false_bits,
            false_bits,
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_startswith(hay_bits: u64, needle_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let none_bits = MoltObject::none().bits();
        let false_bits = MoltObject::from_bool(false).bits();
        molt_bytearray_startswith_slice(
            hay_bits,
            needle_bits,
            none_bits,
            none_bits,
            false_bits,
            false_bits,
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_endswith(hay_bits: u64, needle_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let none_bits = MoltObject::none().bits();
        let false_bits = MoltObject::from_bool(false).bits();
        molt_bytearray_endswith_slice(
            hay_bits,
            needle_bits,
            none_bits,
            none_bits,
            false_bits,
            false_bits,
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_find_slice(
    hay_bits: u64,
    needle_bits: u64,
    start_bits: u64,
    end_bits: u64,
    has_start_bits: u64,
    has_end_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let has_start = to_i64(obj_from_bits(has_start_bits)).unwrap_or(0) != 0;
        let has_end = to_i64(obj_from_bits(has_end_bits)).unwrap_or(0) != 0;
        if let Some(hay_ptr) = hay.as_ptr() {
            unsafe {
                if object_type_id(hay_ptr) != TYPE_ID_BYTEARRAY {
                    return MoltObject::none().bits();
                }
                let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
                let total = hay_bytes.len() as i64;
                let (start, end, start_raw) =
                    slice_bounds_from_args(_py, start_bits, end_bits, has_start, has_end, total);
                if end < start {
                    return MoltObject::from_int(-1).bits();
                }
                let slice = &hay_bytes[start as usize..end as usize];
                if let Some(byte) = needle.as_int() {
                    if !(0..=255).contains(&byte) {
                        return raise_exception::<_>(
                            _py,
                            "ValueError",
                            "byte must be in range(0, 256)",
                        );
                    }
                    let idx = match memchr(byte as u8, slice) {
                        Some(pos) => start + pos as i64,
                        None => -1,
                    };
                    return MoltObject::from_int(idx).bits();
                }
                let needle_ptr = match needle.as_ptr() {
                    Some(ptr) => ptr,
                    None => {
                        let msg = format!(
                            "argument should be integer or bytes-like object, not '{}'",
                            type_name(_py, needle)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                let needle_bytes = match bytes_like_slice(needle_ptr) {
                    Some(slice) => slice,
                    None => {
                        let msg = format!(
                            "argument should be integer or bytes-like object, not '{}'",
                            type_name(_py, needle)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                if needle_bytes.is_empty() {
                    if start_raw > total {
                        return MoltObject::from_int(-1).bits();
                    }
                    return MoltObject::from_int(start).bits();
                }
                let idx = bytes_find_impl(slice, needle_bytes);
                let out = if idx < 0 { -1 } else { start + idx };
                MoltObject::from_int(out).bits()
            }
        } else {
            MoltObject::none().bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_rfind_slice(
    hay_bits: u64,
    needle_bits: u64,
    start_bits: u64,
    end_bits: u64,
    has_start_bits: u64,
    has_end_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let has_start = to_i64(obj_from_bits(has_start_bits)).unwrap_or(0) != 0;
        let has_end = to_i64(obj_from_bits(has_end_bits)).unwrap_or(0) != 0;
        if let Some(hay_ptr) = hay.as_ptr() {
            unsafe {
                if object_type_id(hay_ptr) != TYPE_ID_BYTEARRAY {
                    return MoltObject::none().bits();
                }
                let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
                let total = hay_bytes.len() as i64;
                let (start, end, start_raw) =
                    slice_bounds_from_args(_py, start_bits, end_bits, has_start, has_end, total);
                if end < start {
                    return MoltObject::from_int(-1).bits();
                }
                let slice = &hay_bytes[start as usize..end as usize];
                if let Some(byte) = needle.as_int() {
                    if !(0..=255).contains(&byte) {
                        return raise_exception::<_>(
                            _py,
                            "ValueError",
                            "byte must be in range(0, 256)",
                        );
                    }
                    let idx = match memchr::memrchr(byte as u8, slice) {
                        Some(pos) => start + pos as i64,
                        None => -1,
                    };
                    return MoltObject::from_int(idx).bits();
                }
                let needle_ptr = match needle.as_ptr() {
                    Some(ptr) => ptr,
                    None => {
                        let msg = format!(
                            "argument should be integer or bytes-like object, not '{}'",
                            type_name(_py, needle)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                let needle_bytes = match bytes_like_slice(needle_ptr) {
                    Some(slice) => slice,
                    None => {
                        let msg = format!(
                            "argument should be integer or bytes-like object, not '{}'",
                            type_name(_py, needle)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                if needle_bytes.is_empty() {
                    if start_raw > total {
                        return MoltObject::from_int(-1).bits();
                    }
                    return MoltObject::from_int(end).bits();
                }
                let idx = bytes_rfind_impl(slice, needle_bytes);
                let out = if idx < 0 { -1 } else { start + idx };
                MoltObject::from_int(out).bits()
            }
        } else {
            MoltObject::none().bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_startswith_slice(
    hay_bits: u64,
    needle_bits: u64,
    start_bits: u64,
    end_bits: u64,
    has_start_bits: u64,
    has_end_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let has_start = to_i64(obj_from_bits(has_start_bits)).unwrap_or(0) != 0;
        let has_end = to_i64(obj_from_bits(has_end_bits)).unwrap_or(0) != 0;
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_BYTEARRAY {
                return MoltObject::none().bits();
            }
            let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
            let total = hay_bytes.len() as i64;
            let (start, end, start_raw) =
                slice_bounds_from_args(_py, start_bits, end_bits, has_start, has_end, total);
            if end < start {
                return MoltObject::from_bool(false).bits();
            }
            let slice = &hay_bytes[start as usize..end as usize];
            if let Some(needle_ptr) = needle.as_ptr() {
                let needle_type = object_type_id(needle_ptr);
                if needle_type == TYPE_ID_TUPLE {
                    let elems = seq_vec_ref(needle_ptr);
                    if elems.is_empty() {
                        return MoltObject::from_bool(false).bits();
                    }
                    for &elem_bits in elems.iter() {
                        let elem = obj_from_bits(elem_bits);
                        let elem_ptr = match elem.as_ptr() {
                            Some(ptr) => ptr,
                            None => {
                                let msg = format!(
                                    "a bytes-like object is required, not '{}'",
                                    type_name(_py, elem)
                                );
                                return raise_exception::<_>(_py, "TypeError", &msg);
                            }
                        };
                        let needle_bytes = match bytes_like_slice(elem_ptr) {
                            Some(slice) => slice,
                            None => {
                                let msg = format!(
                                    "a bytes-like object is required, not '{}'",
                                    type_name(_py, elem)
                                );
                                return raise_exception::<_>(_py, "TypeError", &msg);
                            }
                        };
                        if slice_match(slice, needle_bytes, start_raw, total, false) {
                            return MoltObject::from_bool(true).bits();
                        }
                    }
                    return MoltObject::from_bool(false).bits();
                }
                if let Some(needle_bytes) = bytes_like_slice(needle_ptr) {
                    let ok = slice_match(slice, needle_bytes, start_raw, total, false);
                    return MoltObject::from_bool(ok).bits();
                }
            }
            let msg = format!(
                "startswith first arg must be bytes or a tuple of bytes, not {}",
                type_name(_py, needle)
            );
            raise_exception::<_>(_py, "TypeError", &msg)
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_endswith_slice(
    hay_bits: u64,
    needle_bits: u64,
    start_bits: u64,
    end_bits: u64,
    has_start_bits: u64,
    has_end_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let has_start = to_i64(obj_from_bits(has_start_bits)).unwrap_or(0) != 0;
        let has_end = to_i64(obj_from_bits(has_end_bits)).unwrap_or(0) != 0;
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_BYTEARRAY {
                return MoltObject::none().bits();
            }
            let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
            let total = hay_bytes.len() as i64;
            let (start, end, start_raw) =
                slice_bounds_from_args(_py, start_bits, end_bits, has_start, has_end, total);
            if end < start {
                return MoltObject::from_bool(false).bits();
            }
            let slice = &hay_bytes[start as usize..end as usize];
            if let Some(needle_ptr) = needle.as_ptr() {
                let needle_type = object_type_id(needle_ptr);
                if needle_type == TYPE_ID_TUPLE {
                    let elems = seq_vec_ref(needle_ptr);
                    if elems.is_empty() {
                        return MoltObject::from_bool(false).bits();
                    }
                    for &elem_bits in elems.iter() {
                        let elem = obj_from_bits(elem_bits);
                        let elem_ptr = match elem.as_ptr() {
                            Some(ptr) => ptr,
                            None => {
                                let msg = format!(
                                    "a bytes-like object is required, not '{}'",
                                    type_name(_py, elem)
                                );
                                return raise_exception::<_>(_py, "TypeError", &msg);
                            }
                        };
                        let needle_bytes = match bytes_like_slice(elem_ptr) {
                            Some(slice) => slice,
                            None => {
                                let msg = format!(
                                    "a bytes-like object is required, not '{}'",
                                    type_name(_py, elem)
                                );
                                return raise_exception::<_>(_py, "TypeError", &msg);
                            }
                        };
                        if slice_match(slice, needle_bytes, start_raw, total, true) {
                            return MoltObject::from_bool(true).bits();
                        }
                    }
                    return MoltObject::from_bool(false).bits();
                }
                if let Some(needle_bytes) = bytes_like_slice(needle_ptr) {
                    let ok = slice_match(slice, needle_bytes, start_raw, total, true);
                    return MoltObject::from_bool(ok).bits();
                }
            }
            let msg = format!(
                "endswith first arg must be bytes or a tuple of bytes, not {}",
                type_name(_py, needle)
            );
            raise_exception::<_>(_py, "TypeError", &msg)
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_count(hay_bits: u64, needle_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_BYTEARRAY {
                return MoltObject::none().bits();
            }
            let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
            if let Some(byte) = needle.as_int() {
                if !(0..=255).contains(&byte) {
                    return raise_exception::<_>(
                        _py,
                        "ValueError",
                        "byte must be in range(0, 256)",
                    );
                }
                let count = memchr::memchr_iter(byte as u8, hay_bytes).count() as i64;
                return MoltObject::from_int(count).bits();
            }
            let needle_ptr = match needle.as_ptr() {
                Some(ptr) => ptr,
                None => {
                    let msg = format!(
                        "argument should be integer or bytes-like object, not '{}'",
                        type_name(_py, needle)
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            };
            let needle_bytes = match bytes_like_slice(needle_ptr) {
                Some(slice) => slice,
                None => {
                    let msg = format!(
                        "argument should be integer or bytes-like object, not '{}'",
                        type_name(_py, needle)
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            };
            let count = bytes_count_impl(hay_bytes, needle_bytes);
            MoltObject::from_int(count).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_count_slice(
    hay_bits: u64,
    needle_bits: u64,
    start_bits: u64,
    end_bits: u64,
    has_start_bits: u64,
    has_end_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let has_start = to_i64(obj_from_bits(has_start_bits)).unwrap_or(0) != 0;
        let has_end = to_i64(obj_from_bits(has_end_bits)).unwrap_or(0) != 0;
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_BYTEARRAY {
                return MoltObject::none().bits();
            }
            let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
            let total = hay_bytes.len() as i64;
            let (start, end, start_raw) =
                slice_bounds_from_args(_py, start_bits, end_bits, has_start, has_end, total);
            if end < start {
                return MoltObject::from_int(0).bits();
            }
            if let Some(byte) = needle.as_int() {
                if !(0..=255).contains(&byte) {
                    return raise_exception::<_>(
                        _py,
                        "ValueError",
                        "byte must be in range(0, 256)",
                    );
                }
                let slice = &hay_bytes[start as usize..end as usize];
                let count = memchr::memchr_iter(byte as u8, slice).count() as i64;
                return MoltObject::from_int(count).bits();
            }
            let needle_ptr = match needle.as_ptr() {
                Some(ptr) => ptr,
                None => {
                    let msg = format!(
                        "argument should be integer or bytes-like object, not '{}'",
                        type_name(_py, needle)
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            };
            let needle_bytes = match bytes_like_slice(needle_ptr) {
                Some(slice) => slice,
                None => {
                    let msg = format!(
                        "argument should be integer or bytes-like object, not '{}'",
                        type_name(_py, needle)
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            };
            if needle_bytes.is_empty() {
                if start_raw > total {
                    return MoltObject::from_int(0).bits();
                }
                let count = end - start + 1;
                return MoltObject::from_int(count).bits();
            }
            let slice = &hay_bytes[start as usize..end as usize];
            let count = bytes_count_impl(slice, needle_bytes);
            MoltObject::from_int(count).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_splitlines(hay_bits: u64, keepends_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let keepends = is_truthy(_py, obj_from_bits(keepends_bits));
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_BYTES {
                return MoltObject::none().bits();
            }
            let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
            let list_bits =
                splitlines_bytes_to_list(_py, hay_bytes, keepends, |bytes| alloc_bytes(_py, bytes));
            list_bits.unwrap_or_else(|| MoltObject::none().bits())
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_splitlines(hay_bits: u64, keepends_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let keepends = is_truthy(_py, obj_from_bits(keepends_bits));
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_BYTEARRAY {
                return MoltObject::none().bits();
            }
            let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
            let list_bits = splitlines_bytes_to_list(_py, hay_bytes, keepends, |bytes| {
                alloc_bytearray(_py, bytes)
            });
            list_bits.unwrap_or_else(|| MoltObject::none().bits())
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_splitlines(hay_bits: u64, keepends_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let keepends = is_truthy(_py, obj_from_bits(keepends_bits));
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_STRING {
                return MoltObject::none().bits();
            }
            let hay_bytes = std::slice::from_raw_parts(string_bytes(hay_ptr), string_len(hay_ptr));
            let Ok(hay_str) = std::str::from_utf8(hay_bytes) else {
                return MoltObject::none().bits();
            };
            let list_bits = splitlines_string_to_list(_py, hay_str, keepends);
            list_bits.unwrap_or_else(|| MoltObject::none().bits())
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_split(hay_bits: u64, needle_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let maxsplit_bits = MoltObject::from_int(-1).bits();
        molt_string_split_max(hay_bits, needle_bits, maxsplit_bits)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_split_max(
    hay_bits: u64,
    needle_bits: u64,
    maxsplit_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let maxsplit = split_maxsplit_from_obj(_py, maxsplit_bits);
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        if let Some(hay_ptr) = hay.as_ptr() {
            unsafe {
                if object_type_id(hay_ptr) != TYPE_ID_STRING {
                    return MoltObject::none().bits();
                }
                let hay_bytes =
                    std::slice::from_raw_parts(string_bytes(hay_ptr), string_len(hay_ptr));
                if needle.is_none() {
                    let Ok(hay_str) = std::str::from_utf8(hay_bytes) else {
                        return MoltObject::none().bits();
                    };
                    let list_bits =
                        split_string_whitespace_to_list_maxsplit(_py, hay_str, maxsplit);
                    return list_bits.unwrap_or_else(|| MoltObject::none().bits());
                }
                let Some(needle_ptr) = needle.as_ptr() else {
                    return MoltObject::none().bits();
                };
                if object_type_id(needle_ptr) != TYPE_ID_STRING {
                    let msg = format!("must be str or None, not {}", type_name(_py, needle));
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
                let needle_bytes =
                    std::slice::from_raw_parts(string_bytes(needle_ptr), string_len(needle_ptr));
                if needle_bytes.is_empty() {
                    return raise_exception::<_>(_py, "ValueError", "empty separator");
                }
                let list_bits =
                    split_string_bytes_to_list_maxsplit(_py, hay_bytes, needle_bytes, maxsplit);
                let list_bits = match list_bits {
                    Some(val) => val,
                    None => return MoltObject::none().bits(),
                };
                return list_bits;
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_rsplit(hay_bits: u64, needle_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let maxsplit_bits = MoltObject::from_int(-1).bits();
        molt_string_rsplit_max(hay_bits, needle_bits, maxsplit_bits)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_rsplit_max(
    hay_bits: u64,
    needle_bits: u64,
    maxsplit_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let maxsplit = split_maxsplit_from_obj(_py, maxsplit_bits);
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        if let Some(hay_ptr) = hay.as_ptr() {
            unsafe {
                if object_type_id(hay_ptr) != TYPE_ID_STRING {
                    return MoltObject::none().bits();
                }
                let hay_bytes =
                    std::slice::from_raw_parts(string_bytes(hay_ptr), string_len(hay_ptr));
                if needle.is_none() {
                    let Ok(hay_str) = std::str::from_utf8(hay_bytes) else {
                        return MoltObject::none().bits();
                    };
                    let list_bits =
                        rsplit_string_whitespace_to_list_maxsplit(_py, hay_str, maxsplit);
                    return list_bits.unwrap_or_else(|| MoltObject::none().bits());
                }
                let Some(needle_ptr) = needle.as_ptr() else {
                    return MoltObject::none().bits();
                };
                if object_type_id(needle_ptr) != TYPE_ID_STRING {
                    let msg = format!("must be str or None, not {}", type_name(_py, needle));
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
                let needle_bytes =
                    std::slice::from_raw_parts(string_bytes(needle_ptr), string_len(needle_ptr));
                if needle_bytes.is_empty() {
                    return raise_exception::<_>(_py, "ValueError", "empty separator");
                }
                let list_bits =
                    rsplit_string_bytes_to_list_maxsplit(_py, hay_bytes, needle_bytes, maxsplit);
                let list_bits = match list_bits {
                    Some(val) => val,
                    None => return MoltObject::none().bits(),
                };
                return list_bits;
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_replace(
    hay_bits: u64,
    needle_bits: u64,
    replacement_bits: u64,
    count_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let replacement = obj_from_bits(replacement_bits);
        let count_err = format!(
            "'{}' object cannot be interpreted as an integer",
            type_name(_py, obj_from_bits(count_bits))
        );
        let count = index_i64_from_obj(_py, count_bits, &count_err);
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        if let Some(hay_ptr) = hay.as_ptr() {
            unsafe {
                if object_type_id(hay_ptr) != TYPE_ID_STRING {
                    return MoltObject::none().bits();
                }
                let needle_ptr = match needle.as_ptr() {
                    Some(ptr) => ptr,
                    None => {
                        let msg = format!(
                            "replace() argument 1 must be str, not {}",
                            type_name(_py, needle)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                if object_type_id(needle_ptr) != TYPE_ID_STRING {
                    let msg = format!(
                        "replace() argument 1 must be str, not {}",
                        type_name(_py, needle)
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
                let repl_ptr = match replacement.as_ptr() {
                    Some(ptr) => ptr,
                    None => {
                        let msg = format!(
                            "replace() argument 2 must be str, not {}",
                            type_name(_py, replacement)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                if object_type_id(repl_ptr) != TYPE_ID_STRING {
                    let msg = format!(
                        "replace() argument 2 must be str, not {}",
                        type_name(_py, replacement)
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
                let hay_bytes =
                    std::slice::from_raw_parts(string_bytes(hay_ptr), string_len(hay_ptr));
                let needle_bytes =
                    std::slice::from_raw_parts(string_bytes(needle_ptr), string_len(needle_ptr));
                let repl_bytes =
                    std::slice::from_raw_parts(string_bytes(repl_ptr), string_len(repl_ptr));
                let out = match replace_string_impl(
                    _py,
                    hay_ptr,
                    hay_bytes,
                    needle_bytes,
                    repl_bytes,
                    count,
                ) {
                    Some(out) => out,
                    None => return MoltObject::none().bits(),
                };
                let ptr = alloc_string(_py, &out);
                if ptr.is_null() {
                    return MoltObject::none().bits();
                }
                return MoltObject::from_ptr(ptr).bits();
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_encode(hay_bits: u64, encoding_bits: u64, errors_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_STRING {
                return MoltObject::none().bits();
            }
            let encoding = match parse_codec_arg(_py, encoding_bits, "encode", "encoding", "utf-8")
            {
                Some(val) => val,
                None => return MoltObject::none().bits(),
            };
            let errors = match parse_codec_arg(_py, errors_bits, "encode", "errors", "strict") {
                Some(val) => val,
                None => return MoltObject::none().bits(),
            };
            let bytes = std::slice::from_raw_parts(string_bytes(hay_ptr), string_len(hay_ptr));
            let out = match encode_string_with_errors(bytes, &encoding, Some(&errors)) {
                Ok(bytes) => bytes,
                Err(EncodeError::UnknownEncoding(name)) => {
                    let msg = format!("unknown encoding: {name}");
                    return raise_exception::<_>(_py, "LookupError", &msg);
                }
                Err(EncodeError::UnknownErrorHandler(name)) => {
                    let msg = format!("unknown error handler name '{name}'");
                    return raise_exception::<_>(_py, "LookupError", &msg);
                }
                Err(EncodeError::InvalidChar {
                    encoding,
                    code,
                    pos,
                    limit,
                }) => {
                    let reason = encode_error_reason(encoding, code, limit);
                    return raise_unicode_encode_error::<_>(
                        _py,
                        encoding,
                        hay_bits,
                        pos,
                        pos + 1,
                        &reason,
                    );
                }
            };
            let ptr = alloc_bytes(_py, &out);
            if ptr.is_null() {
                return MoltObject::none().bits();
            }
            MoltObject::from_ptr(ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_lower(hay_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_STRING {
                return MoltObject::none().bits();
            }
            let hay_bytes = std::slice::from_raw_parts(string_bytes(hay_ptr), string_len(hay_ptr));
            let Ok(hay_str) = std::str::from_utf8(hay_bytes) else {
                return MoltObject::none().bits();
            };
            let lowered = hay_str.to_lowercase();
            let ptr = alloc_string(_py, lowered.as_bytes());
            if ptr.is_null() {
                return MoltObject::none().bits();
            }
            MoltObject::from_ptr(ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_casefold(hay_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_STRING {
                return MoltObject::none().bits();
            }
            let hay_bytes = std::slice::from_raw_parts(string_bytes(hay_ptr), string_len(hay_ptr));
            let Ok(hay_str) = std::str::from_utf8(hay_bytes) else {
                return MoltObject::none().bits();
            };
            let folded: String = hay_str
                .case_fold_with(Variant::Full, Locale::NonTurkic)
                .collect();
            let ptr = alloc_string(_py, folded.as_bytes());
            if ptr.is_null() {
                return MoltObject::none().bits();
            }
            MoltObject::from_ptr(ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_upper(hay_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_STRING {
                return MoltObject::none().bits();
            }
            let hay_bytes = std::slice::from_raw_parts(string_bytes(hay_ptr), string_len(hay_ptr));
            let Ok(hay_str) = std::str::from_utf8(hay_bytes) else {
                return MoltObject::none().bits();
            };
            let uppered = hay_str.to_uppercase();
            let ptr = alloc_string(_py, uppered.as_bytes());
            if ptr.is_null() {
                return MoltObject::none().bits();
            }
            MoltObject::from_ptr(ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_isidentifier(hay_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_STRING {
                return MoltObject::none().bits();
            }
            let hay_bytes = std::slice::from_raw_parts(string_bytes(hay_ptr), string_len(hay_ptr));
            let Ok(hay_str) = std::str::from_utf8(hay_bytes) else {
                return MoltObject::from_bool(false).bits();
            };
            let mut chars = hay_str.chars();
            let Some(first) = chars.next() else {
                return MoltObject::from_bool(false).bits();
            };
            if !(first == '_' || is_xid_start(first)) {
                return MoltObject::from_bool(false).bits();
            }
            for ch in chars {
                if ch == '_' || is_xid_continue(ch) {
                    continue;
                }
                return MoltObject::from_bool(false).bits();
            }
            MoltObject::from_bool(true).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_isdigit(hay_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_STRING {
                return MoltObject::none().bits();
            }
            let hay_bytes = std::slice::from_raw_parts(string_bytes(hay_ptr), string_len(hay_ptr));
            let Ok(hay_str) = std::str::from_utf8(hay_bytes) else {
                return MoltObject::from_bool(false).bits();
            };
            let mut seen = false;
            for ch in hay_str.chars() {
                if unicode_digit_table::is_digit(ch as u32) {
                    seen = true;
                    continue;
                }
                return MoltObject::from_bool(false).bits();
            }
            MoltObject::from_bool(seen).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_capitalize(hay_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_STRING {
                return MoltObject::none().bits();
            }
            let hay_bytes = std::slice::from_raw_parts(string_bytes(hay_ptr), string_len(hay_ptr));
            let Ok(hay_str) = std::str::from_utf8(hay_bytes) else {
                return MoltObject::none().bits();
            };
            let mut out = String::with_capacity(hay_str.len());
            let mut chars = hay_str.chars();
            if let Some(first) = chars.next() {
                out.extend(first.to_uppercase());
                for ch in chars {
                    out.extend(ch.to_lowercase());
                }
            }
            let ptr = alloc_string(_py, out.as_bytes());
            if ptr.is_null() {
                return MoltObject::none().bits();
            }
            MoltObject::from_ptr(ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_strip(hay_bits: u64, chars_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let chars = obj_from_bits(chars_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_STRING {
                return MoltObject::none().bits();
            }
            let hay_bytes = std::slice::from_raw_parts(string_bytes(hay_ptr), string_len(hay_ptr));
            let Ok(hay_str) = std::str::from_utf8(hay_bytes) else {
                return MoltObject::none().bits();
            };
            let trimmed = if chars.is_none() {
                hay_str.trim()
            } else {
                let Some(chars_ptr) = chars.as_ptr() else {
                    return raise_exception::<_>(
                        _py,
                        "TypeError",
                        "lstrip arg must be None or str",
                    );
                };
                if object_type_id(chars_ptr) != TYPE_ID_STRING {
                    return raise_exception::<_>(
                        _py,
                        "TypeError",
                        "lstrip arg must be None or str",
                    );
                }
                let chars_bytes =
                    std::slice::from_raw_parts(string_bytes(chars_ptr), string_len(chars_ptr));
                let Ok(chars_str) = std::str::from_utf8(chars_bytes) else {
                    return MoltObject::none().bits();
                };
                if chars_str.is_empty() {
                    hay_str
                } else {
                    let mut strip_chars = HashSet::new();
                    for ch in chars_str.chars() {
                        strip_chars.insert(ch);
                    }
                    let mut start = None;
                    for (idx, ch) in hay_str.char_indices() {
                        if !strip_chars.contains(&ch) {
                            start = Some(idx);
                            break;
                        }
                    }
                    match start {
                        None => "",
                        Some(start_idx) => {
                            let mut end = None;
                            for (idx, ch) in hay_str.char_indices().rev() {
                                if !strip_chars.contains(&ch) {
                                    end = Some(idx + ch.len_utf8());
                                    break;
                                }
                            }
                            let end_idx = end.unwrap_or(start_idx);
                            &hay_str[start_idx..end_idx]
                        }
                    }
                }
            };
            let ptr = alloc_string(_py, trimmed.as_bytes());
            if ptr.is_null() {
                return MoltObject::none().bits();
            }
            MoltObject::from_ptr(ptr).bits()
        }
    })
}

fn string_lstrip_chars<'a>(hay_str: &'a str, chars_str: &str) -> &'a str {
    if chars_str.is_empty() {
        return hay_str;
    }
    let mut strip_chars = HashSet::new();
    for ch in chars_str.chars() {
        strip_chars.insert(ch);
    }
    for (idx, ch) in hay_str.char_indices() {
        if !strip_chars.contains(&ch) {
            return &hay_str[idx..];
        }
    }
    ""
}

fn string_rstrip_chars<'a>(hay_str: &'a str, chars_str: &str) -> &'a str {
    if chars_str.is_empty() {
        return hay_str;
    }
    let mut strip_chars = HashSet::new();
    for ch in chars_str.chars() {
        strip_chars.insert(ch);
    }
    for (idx, ch) in hay_str.char_indices().rev() {
        if !strip_chars.contains(&ch) {
            let end = idx + ch.len_utf8();
            return &hay_str[..end];
        }
    }
    ""
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_lstrip(hay_bits: u64, chars_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let chars = obj_from_bits(chars_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_STRING {
                return MoltObject::none().bits();
            }
            let hay_bytes = std::slice::from_raw_parts(string_bytes(hay_ptr), string_len(hay_ptr));
            let Ok(hay_str) = std::str::from_utf8(hay_bytes) else {
                return MoltObject::none().bits();
            };
            let trimmed = if chars.is_none() {
                hay_str.trim_start()
            } else {
                let Some(chars_ptr) = chars.as_ptr() else {
                    return raise_exception::<_>(
                        _py,
                        "TypeError",
                        "rstrip arg must be None or str",
                    );
                };
                if object_type_id(chars_ptr) != TYPE_ID_STRING {
                    return raise_exception::<_>(
                        _py,
                        "TypeError",
                        "rstrip arg must be None or str",
                    );
                }
                let chars_bytes =
                    std::slice::from_raw_parts(string_bytes(chars_ptr), string_len(chars_ptr));
                let Ok(chars_str) = std::str::from_utf8(chars_bytes) else {
                    return MoltObject::none().bits();
                };
                string_lstrip_chars(hay_str, chars_str)
            };
            let ptr = alloc_string(_py, trimmed.as_bytes());
            if ptr.is_null() {
                return MoltObject::none().bits();
            }
            MoltObject::from_ptr(ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_rstrip(hay_bits: u64, chars_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let chars = obj_from_bits(chars_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_STRING {
                return MoltObject::none().bits();
            }
            let hay_bytes = std::slice::from_raw_parts(string_bytes(hay_ptr), string_len(hay_ptr));
            let Ok(hay_str) = std::str::from_utf8(hay_bytes) else {
                return MoltObject::none().bits();
            };
            let trimmed = if chars.is_none() {
                hay_str.trim_end()
            } else {
                let Some(chars_ptr) = chars.as_ptr() else {
                    return raise_exception::<_>(_py, "TypeError", "strip arg must be None or str");
                };
                if object_type_id(chars_ptr) != TYPE_ID_STRING {
                    return raise_exception::<_>(_py, "TypeError", "strip arg must be None or str");
                }
                let chars_bytes =
                    std::slice::from_raw_parts(string_bytes(chars_ptr), string_len(chars_ptr));
                let Ok(chars_str) = std::str::from_utf8(chars_bytes) else {
                    return MoltObject::none().bits();
                };
                string_rstrip_chars(hay_str, chars_str)
            };
            let ptr = alloc_string(_py, trimmed.as_bytes());
            if ptr.is_null() {
                return MoltObject::none().bits();
            }
            MoltObject::from_ptr(ptr).bits()
        }
    })
}

fn partition_bytes_to_tuple<F>(
    _py: &PyToken<'_>,
    hay_bytes: &[u8],
    sep_bytes: &[u8],
    from_right: bool,
    mut alloc: F,
) -> Option<u64>
where
    F: FnMut(&[u8]) -> *mut u8,
{
    let idx = if from_right {
        bytes_rfind_impl(hay_bytes, sep_bytes)
    } else {
        bytes_find_impl(hay_bytes, sep_bytes)
    };
    let (head_bytes, sep_bytes, tail_bytes) = if idx < 0 {
        if from_right {
            (&[][..], &[][..], hay_bytes)
        } else {
            (hay_bytes, &[][..], &[][..])
        }
    } else {
        let idx = idx as usize;
        let end = idx + sep_bytes.len();
        (&hay_bytes[..idx], sep_bytes, &hay_bytes[end..])
    };
    let head_ptr = alloc(head_bytes);
    if head_ptr.is_null() {
        return None;
    }
    let head_bits = MoltObject::from_ptr(head_ptr).bits();
    let sep_ptr = alloc(sep_bytes);
    if sep_ptr.is_null() {
        dec_ref_bits(_py, head_bits);
        return None;
    }
    let sep_bits = MoltObject::from_ptr(sep_ptr).bits();
    let tail_ptr = alloc(tail_bytes);
    if tail_ptr.is_null() {
        dec_ref_bits(_py, head_bits);
        dec_ref_bits(_py, sep_bits);
        return None;
    }
    let tail_bits = MoltObject::from_ptr(tail_ptr).bits();
    let tuple_ptr = alloc_tuple(_py, &[head_bits, sep_bits, tail_bits]);
    if tuple_ptr.is_null() {
        dec_ref_bits(_py, head_bits);
        dec_ref_bits(_py, sep_bits);
        dec_ref_bits(_py, tail_bits);
        return None;
    }
    Some(MoltObject::from_ptr(tuple_ptr).bits())
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_partition(hay_bits: u64, sep_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let sep = obj_from_bits(sep_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_BYTES {
                return MoltObject::none().bits();
            }
            let sep_ptr = match sep.as_ptr() {
                Some(ptr) => ptr,
                None => {
                    let msg = format!(
                        "a bytes-like object is required, not '{}'",
                        type_name(_py, sep)
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            };
            let sep_bytes = match bytes_like_slice(sep_ptr) {
                Some(slice) => slice,
                None => {
                    let msg = format!(
                        "a bytes-like object is required, not '{}'",
                        type_name(_py, sep)
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            };
            if sep_bytes.is_empty() {
                return raise_exception::<_>(_py, "ValueError", "empty separator");
            }
            let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
            let tuple_bits = partition_bytes_to_tuple(_py, hay_bytes, sep_bytes, false, |bytes| {
                alloc_bytes(_py, bytes)
            });
            tuple_bits.unwrap_or_else(|| MoltObject::none().bits())
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_rpartition(hay_bits: u64, sep_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let sep = obj_from_bits(sep_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_BYTES {
                return MoltObject::none().bits();
            }
            let sep_ptr = match sep.as_ptr() {
                Some(ptr) => ptr,
                None => {
                    let msg = format!(
                        "a bytes-like object is required, not '{}'",
                        type_name(_py, sep)
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            };
            let sep_bytes = match bytes_like_slice(sep_ptr) {
                Some(slice) => slice,
                None => {
                    let msg = format!(
                        "a bytes-like object is required, not '{}'",
                        type_name(_py, sep)
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            };
            if sep_bytes.is_empty() {
                return raise_exception::<_>(_py, "ValueError", "empty separator");
            }
            let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
            let tuple_bits = partition_bytes_to_tuple(_py, hay_bytes, sep_bytes, true, |bytes| {
                alloc_bytes(_py, bytes)
            });
            tuple_bits.unwrap_or_else(|| MoltObject::none().bits())
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_partition(hay_bits: u64, sep_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let sep = obj_from_bits(sep_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_BYTEARRAY {
                return MoltObject::none().bits();
            }
            let sep_ptr = match sep.as_ptr() {
                Some(ptr) => ptr,
                None => {
                    let msg = format!(
                        "a bytes-like object is required, not '{}'",
                        type_name(_py, sep)
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            };
            let sep_bytes = match bytes_like_slice(sep_ptr) {
                Some(slice) => slice,
                None => {
                    let msg = format!(
                        "a bytes-like object is required, not '{}'",
                        type_name(_py, sep)
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            };
            if sep_bytes.is_empty() {
                return raise_exception::<_>(_py, "ValueError", "empty separator");
            }
            let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
            let tuple_bits = partition_bytes_to_tuple(_py, hay_bytes, sep_bytes, false, |bytes| {
                alloc_bytearray(_py, bytes)
            });
            tuple_bits.unwrap_or_else(|| MoltObject::none().bits())
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_rpartition(hay_bits: u64, sep_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let sep = obj_from_bits(sep_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_BYTEARRAY {
                return MoltObject::none().bits();
            }
            let sep_ptr = match sep.as_ptr() {
                Some(ptr) => ptr,
                None => {
                    let msg = format!(
                        "a bytes-like object is required, not '{}'",
                        type_name(_py, sep)
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            };
            let sep_bytes = match bytes_like_slice(sep_ptr) {
                Some(slice) => slice,
                None => {
                    let msg = format!(
                        "a bytes-like object is required, not '{}'",
                        type_name(_py, sep)
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            };
            if sep_bytes.is_empty() {
                return raise_exception::<_>(_py, "ValueError", "empty separator");
            }
            let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
            let tuple_bits = partition_bytes_to_tuple(_py, hay_bytes, sep_bytes, true, |bytes| {
                alloc_bytearray(_py, bytes)
            });
            tuple_bits.unwrap_or_else(|| MoltObject::none().bits())
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_split(hay_bits: u64, needle_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let maxsplit_bits = MoltObject::from_int(-1).bits();
        molt_bytes_split_max(hay_bits, needle_bits, maxsplit_bits)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_split_max(hay_bits: u64, needle_bits: u64, maxsplit_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let maxsplit = split_maxsplit_from_obj(_py, maxsplit_bits);
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        if let Some(hay_ptr) = hay.as_ptr() {
            unsafe {
                if object_type_id(hay_ptr) != TYPE_ID_BYTES {
                    return MoltObject::none().bits();
                }
                let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
                if needle.is_none() {
                    let list_bits = split_bytes_whitespace_to_list_maxsplit(
                        _py,
                        hay_bytes,
                        maxsplit,
                        |bytes| alloc_bytes(_py, bytes),
                    );
                    return list_bits.unwrap_or_else(|| MoltObject::none().bits());
                }
                let needle_ptr = match needle.as_ptr() {
                    Some(ptr) => ptr,
                    None => {
                        let msg = format!(
                            "a bytes-like object is required, not '{}'",
                            type_name(_py, needle)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                let needle_bytes = match bytes_like_slice(needle_ptr) {
                    Some(slice) => slice,
                    None => {
                        let msg = format!(
                            "a bytes-like object is required, not '{}'",
                            type_name(_py, needle)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                if needle_bytes.is_empty() {
                    return raise_exception::<_>(_py, "ValueError", "empty separator");
                }
                let list_bits = match split_bytes_to_list_maxsplit(
                    _py,
                    hay_bytes,
                    needle_bytes,
                    maxsplit,
                    |bytes| alloc_bytes(_py, bytes),
                ) {
                    Some(val) => val,
                    None => return MoltObject::none().bits(),
                };
                return list_bits;
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_rsplit(hay_bits: u64, needle_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let maxsplit_bits = MoltObject::from_int(-1).bits();
        molt_bytes_rsplit_max(hay_bits, needle_bits, maxsplit_bits)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_rsplit_max(
    hay_bits: u64,
    needle_bits: u64,
    maxsplit_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let maxsplit = split_maxsplit_from_obj(_py, maxsplit_bits);
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        if let Some(hay_ptr) = hay.as_ptr() {
            unsafe {
                if object_type_id(hay_ptr) != TYPE_ID_BYTES {
                    return MoltObject::none().bits();
                }
                let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
                if needle.is_none() {
                    let list_bits = rsplit_bytes_whitespace_to_list_maxsplit(
                        _py,
                        hay_bytes,
                        maxsplit,
                        |bytes| alloc_bytes(_py, bytes),
                    );
                    return list_bits.unwrap_or_else(|| MoltObject::none().bits());
                }
                let needle_ptr = match needle.as_ptr() {
                    Some(ptr) => ptr,
                    None => {
                        let msg = format!(
                            "a bytes-like object is required, not '{}'",
                            type_name(_py, needle)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                let needle_bytes = match bytes_like_slice(needle_ptr) {
                    Some(slice) => slice,
                    None => {
                        let msg = format!(
                            "a bytes-like object is required, not '{}'",
                            type_name(_py, needle)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                if needle_bytes.is_empty() {
                    return raise_exception::<_>(_py, "ValueError", "empty separator");
                }
                let list_bits = rsplit_bytes_to_list_maxsplit(
                    _py,
                    hay_bytes,
                    needle_bytes,
                    maxsplit,
                    |bytes| alloc_bytes(_py, bytes),
                );
                let list_bits = match list_bits {
                    Some(val) => val,
                    None => return MoltObject::none().bits(),
                };
                return list_bits;
            }
        }
        MoltObject::none().bits()
    })
}

fn trace_bytes_strip() -> bool {
    static TRACE: OnceLock<bool> = OnceLock::new();
    *TRACE.get_or_init(|| {
        matches!(
            std::env::var("MOLT_TRACE_BYTES_STRIP").ok().as_deref(),
            Some("1")
        )
    })
}

fn bytes_strip_impl<F>(
    _py: &PyToken<'_>,
    hay_bits: u64,
    chars_bits: u64,
    type_id: u32,
    mut alloc: F,
    left: bool,
    right: bool,
) -> u64
where
    F: FnMut(&[u8]) -> *mut u8,
{
    const ASCII_WHITESPACE: [u8; 6] = [b' ', b'\t', b'\n', b'\r', 0x0b, 0x0c];
    let trace = trace_bytes_strip();
    let hay = obj_from_bits(hay_bits);
    let chars = obj_from_bits(chars_bits);
    let Some(hay_ptr) = hay.as_ptr() else {
        return MoltObject::none().bits();
    };
    unsafe {
        if object_type_id(hay_ptr) != type_id {
            return MoltObject::none().bits();
        }
        let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
        let strip_bytes = if chars.is_none() {
            &ASCII_WHITESPACE[..]
        } else {
            let Some(chars_ptr) = chars.as_ptr() else {
                let msg = format!(
                    "a bytes-like object is required, not '{}'",
                    type_name(_py, chars)
                );
                return raise_exception::<_>(_py, "TypeError", &msg);
            };
            match bytes_like_slice(chars_ptr) {
                Some(slice) => slice,
                None => {
                    let msg = format!(
                        "a bytes-like object is required, not '{}'",
                        type_name(_py, chars)
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
            }
        };
        let (start, end) = bytes_strip_range(hay_bytes, strip_bytes, left, right);
        let ptr = alloc(&hay_bytes[start..end]);
        if trace {
            eprintln!(
                "bytes_strip_impl start={start} end={end} out_len={} ptr_null={}",
                end.saturating_sub(start),
                ptr.is_null()
            );
        }
        if ptr.is_null() {
            return MoltObject::none().bits();
        }
        MoltObject::from_ptr(ptr).bits()
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_strip(hay_bits: u64, chars_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        if trace_bytes_strip() {
            let hay = obj_from_bits(hay_bits);
            let info = hay
                .as_ptr()
                .map(|ptr| unsafe { (object_type_id(ptr), bytes_len(ptr)) });
            eprintln!("molt_bytes_strip hay_bits={hay_bits} info={info:?}");
        }
        bytes_strip_impl(
            _py,
            hay_bits,
            chars_bits,
            TYPE_ID_BYTES,
            |bytes| alloc_bytes(_py, bytes),
            true,
            true,
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_lstrip(hay_bits: u64, chars_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        bytes_strip_impl(
            _py,
            hay_bits,
            chars_bits,
            TYPE_ID_BYTES,
            |bytes| alloc_bytes(_py, bytes),
            true,
            false,
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_rstrip(hay_bits: u64, chars_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        bytes_strip_impl(
            _py,
            hay_bits,
            chars_bits,
            TYPE_ID_BYTES,
            |bytes| alloc_bytes(_py, bytes),
            false,
            true,
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_split(hay_bits: u64, needle_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let maxsplit_bits = MoltObject::from_int(-1).bits();
        molt_bytearray_split_max(hay_bits, needle_bits, maxsplit_bits)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_split_max(
    hay_bits: u64,
    needle_bits: u64,
    maxsplit_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let maxsplit = split_maxsplit_from_obj(_py, maxsplit_bits);
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        if let Some(hay_ptr) = hay.as_ptr() {
            unsafe {
                if object_type_id(hay_ptr) != TYPE_ID_BYTEARRAY {
                    return MoltObject::none().bits();
                }
                let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
                if needle.is_none() {
                    let list_bits = split_bytes_whitespace_to_list_maxsplit(
                        _py,
                        hay_bytes,
                        maxsplit,
                        |bytes| alloc_bytearray(_py, bytes),
                    );
                    return list_bits.unwrap_or_else(|| MoltObject::none().bits());
                }
                let needle_ptr = match needle.as_ptr() {
                    Some(ptr) => ptr,
                    None => {
                        let msg = format!(
                            "a bytes-like object is required, not '{}'",
                            type_name(_py, needle)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                let needle_bytes = match bytes_like_slice(needle_ptr) {
                    Some(slice) => slice,
                    None => {
                        let msg = format!(
                            "a bytes-like object is required, not '{}'",
                            type_name(_py, needle)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                if needle_bytes.is_empty() {
                    return raise_exception::<_>(_py, "ValueError", "empty separator");
                }
                let list_bits = match split_bytes_to_list_maxsplit(
                    _py,
                    hay_bytes,
                    needle_bytes,
                    maxsplit,
                    |bytes| alloc_bytearray(_py, bytes),
                ) {
                    Some(val) => val,
                    None => return MoltObject::none().bits(),
                };
                return list_bits;
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_rsplit(hay_bits: u64, needle_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let maxsplit_bits = MoltObject::from_int(-1).bits();
        molt_bytearray_rsplit_max(hay_bits, needle_bits, maxsplit_bits)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_rsplit_max(
    hay_bits: u64,
    needle_bits: u64,
    maxsplit_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let maxsplit = split_maxsplit_from_obj(_py, maxsplit_bits);
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        if let Some(hay_ptr) = hay.as_ptr() {
            unsafe {
                if object_type_id(hay_ptr) != TYPE_ID_BYTEARRAY {
                    return MoltObject::none().bits();
                }
                let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
                if needle.is_none() {
                    let list_bits = rsplit_bytes_whitespace_to_list_maxsplit(
                        _py,
                        hay_bytes,
                        maxsplit,
                        |bytes| alloc_bytearray(_py, bytes),
                    );
                    return list_bits.unwrap_or_else(|| MoltObject::none().bits());
                }
                let needle_ptr = match needle.as_ptr() {
                    Some(ptr) => ptr,
                    None => {
                        let msg = format!(
                            "a bytes-like object is required, not '{}'",
                            type_name(_py, needle)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                let needle_bytes = match bytes_like_slice(needle_ptr) {
                    Some(slice) => slice,
                    None => {
                        let msg = format!(
                            "a bytes-like object is required, not '{}'",
                            type_name(_py, needle)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                if needle_bytes.is_empty() {
                    return raise_exception::<_>(_py, "ValueError", "empty separator");
                }
                let list_bits = rsplit_bytes_to_list_maxsplit(
                    _py,
                    hay_bytes,
                    needle_bytes,
                    maxsplit,
                    |bytes| alloc_bytearray(_py, bytes),
                );
                let list_bits = match list_bits {
                    Some(val) => val,
                    None => return MoltObject::none().bits(),
                };
                return list_bits;
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_strip(hay_bits: u64, chars_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        bytes_strip_impl(
            _py,
            hay_bits,
            chars_bits,
            TYPE_ID_BYTEARRAY,
            |bytes| alloc_bytearray(_py, bytes),
            true,
            true,
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_lstrip(hay_bits: u64, chars_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        bytes_strip_impl(
            _py,
            hay_bits,
            chars_bits,
            TYPE_ID_BYTEARRAY,
            |bytes| alloc_bytearray(_py, bytes),
            true,
            false,
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_rstrip(hay_bits: u64, chars_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        bytes_strip_impl(
            _py,
            hay_bits,
            chars_bits,
            TYPE_ID_BYTEARRAY,
            |bytes| alloc_bytearray(_py, bytes),
            false,
            true,
        )
    })
}

fn bytes_decode_impl(
    _py: &PyToken<'_>,
    hay_bits: u64,
    encoding_bits: u64,
    errors_bits: u64,
    type_id: u32,
) -> u64 {
    let hay = obj_from_bits(hay_bits);
    let Some(hay_ptr) = hay.as_ptr() else {
        return MoltObject::none().bits();
    };
    unsafe {
        if object_type_id(hay_ptr) != type_id {
            return MoltObject::none().bits();
        }
        let encoding = match parse_codec_arg(_py, encoding_bits, "decode", "encoding", "utf-8") {
            Some(val) => val,
            None => return MoltObject::none().bits(),
        };
        let errors = match parse_codec_arg(_py, errors_bits, "decode", "errors", "strict") {
            Some(val) => val,
            None => return MoltObject::none().bits(),
        };
        let bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
        let out_bits = match decode_bytes_text(&encoding, &errors, bytes) {
            Ok((text_bytes, _label)) => {
                let ptr = alloc_string(_py, &text_bytes);
                if ptr.is_null() {
                    return MoltObject::none().bits();
                }
                MoltObject::from_ptr(ptr).bits()
            }
            Err(DecodeTextError::UnknownEncoding(name)) => {
                let msg = format!("unknown encoding: {name}");
                return raise_exception::<_>(_py, "LookupError", &msg);
            }
            Err(DecodeTextError::UnknownErrorHandler(name)) => {
                let msg = format!("unknown error handler name '{name}'");
                return raise_exception::<_>(_py, "LookupError", &msg);
            }
            Err(DecodeTextError::Failure(DecodeFailure::Byte { pos, byte, message }, label)) => {
                let msg = decode_error_byte(&label, byte, pos, message);
                return raise_exception::<_>(_py, "UnicodeDecodeError", &msg);
            }
            Err(DecodeTextError::Failure(
                DecodeFailure::Range {
                    start,
                    end,
                    message,
                },
                label,
            )) => {
                let msg = decode_error_range(&label, start, end, message);
                return raise_exception::<_>(_py, "UnicodeDecodeError", &msg);
            }
            Err(DecodeTextError::Failure(DecodeFailure::UnknownErrorHandler(name), _label)) => {
                let msg = format!("unknown error handler name '{name}'");
                return raise_exception::<_>(_py, "LookupError", &msg);
            }
        };
        out_bits
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_decode(hay_bits: u64, encoding_bits: u64, errors_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        bytes_decode_impl(_py, hay_bits, encoding_bits, errors_bits, TYPE_ID_BYTES)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_decode(
    hay_bits: u64,
    encoding_bits: u64,
    errors_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        bytes_decode_impl(_py, hay_bits, encoding_bits, errors_bits, TYPE_ID_BYTEARRAY)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_replace(
    hay_bits: u64,
    needle_bits: u64,
    replacement_bits: u64,
    count_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let replacement = obj_from_bits(replacement_bits);
        let count_err = format!(
            "'{}' object cannot be interpreted as an integer",
            type_name(_py, obj_from_bits(count_bits))
        );
        let count = index_i64_from_obj(_py, count_bits, &count_err);
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        if let Some(hay_ptr) = hay.as_ptr() {
            unsafe {
                if object_type_id(hay_ptr) != TYPE_ID_BYTES {
                    return MoltObject::none().bits();
                }
                let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
                let needle_ptr = match needle.as_ptr() {
                    Some(ptr) => ptr,
                    None => {
                        let msg = format!(
                            "a bytes-like object is required, not '{}'",
                            type_name(_py, needle)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                let needle_bytes = match bytes_like_slice(needle_ptr) {
                    Some(slice) => slice,
                    None => {
                        let msg = format!(
                            "a bytes-like object is required, not '{}'",
                            type_name(_py, needle)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                let repl_ptr = match replacement.as_ptr() {
                    Some(ptr) => ptr,
                    None => {
                        let msg = format!(
                            "a bytes-like object is required, not '{}'",
                            type_name(_py, replacement)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                let repl_bytes = match bytes_like_slice(repl_ptr) {
                    Some(slice) => slice,
                    None => {
                        let msg = format!(
                            "a bytes-like object is required, not '{}'",
                            type_name(_py, replacement)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                let out = if count < 0 {
                    match replace_bytes_impl(hay_bytes, needle_bytes, repl_bytes) {
                        Some(out) => out,
                        None => return MoltObject::none().bits(),
                    }
                } else {
                    replace_bytes_impl_limit(hay_bytes, needle_bytes, repl_bytes, count as usize)
                };
                let ptr = alloc_bytes(_py, &out);
                if ptr.is_null() {
                    return MoltObject::none().bits();
                }
                return MoltObject::from_ptr(ptr).bits();
            }
        }
        MoltObject::none().bits()
    })
}

#[inline]
fn bytes_ascii_upper(bytes: &[u8]) -> Vec<u8> {
    let mut out = Vec::with_capacity(bytes.len());
    for &b in bytes {
        if b.is_ascii_lowercase() {
            out.push(b.to_ascii_uppercase());
        } else {
            out.push(b);
        }
    }
    out
}

#[inline]
fn bytes_ascii_lower(bytes: &[u8]) -> Vec<u8> {
    let mut out = Vec::with_capacity(bytes.len());
    for &b in bytes {
        if b.is_ascii_uppercase() {
            out.push(b.to_ascii_lowercase());
        } else {
            out.push(b);
        }
    }
    out
}

fn bytes_hex_sep_from_bits(_py: &PyToken<'_>, sep_bits: u64) -> Result<Option<String>, u64> {
    if sep_bits == 0 || obj_from_bits(sep_bits).is_none() {
        return Ok(None);
    }
    let sep_obj = obj_from_bits(sep_bits);
    let Some(sep_ptr) = sep_obj.as_ptr() else {
        return Err(raise_exception::<_>(
            _py,
            "TypeError",
            "sep must be str or bytes",
        ));
    };
    unsafe {
        let type_id = object_type_id(sep_ptr);
        if type_id == TYPE_ID_STRING {
            let bytes = std::slice::from_raw_parts(string_bytes(sep_ptr), string_len(sep_ptr));
            let Ok(sep_str) = std::str::from_utf8(bytes) else {
                return Err(raise_exception::<_>(
                    _py,
                    "TypeError",
                    "sep must be str or bytes",
                ));
            };
            if sep_str.chars().count() != 1 {
                return Err(raise_exception::<_>(
                    _py,
                    "ValueError",
                    "sep must be length 1",
                ));
            }
            return Ok(Some(sep_str.to_string()));
        }
        if type_id == TYPE_ID_BYTES || type_id == TYPE_ID_BYTEARRAY {
            let bytes = bytes_like_slice(sep_ptr).unwrap_or(&[]);
            if bytes.len() != 1 {
                return Err(raise_exception::<_>(
                    _py,
                    "ValueError",
                    "sep must be length 1",
                ));
            }
            let ch = char::from(bytes[0]);
            return Ok(Some(ch.to_string()));
        }
    }
    Err(raise_exception::<_>(
        _py,
        "TypeError",
        "sep must be str or bytes",
    ))
}

fn bytes_hex_string(bytes: &[u8], sep: Option<&str>, bytes_per_sep: i64) -> String {
    const HEX: &[u8; 16] = b"0123456789abcdef";
    if bytes.is_empty() {
        return String::new();
    }
    let hex_len = bytes.len() * 2;
    let Some(sep_str) = sep else {
        let mut out = String::with_capacity(hex_len);
        for &b in bytes {
            out.push(char::from(HEX[(b >> 4) as usize]));
            out.push(char::from(HEX[(b & 0xF) as usize]));
        }
        return out;
    };
    let group = bytes_per_sep.unsigned_abs() as usize;
    let separators = if group == 0 {
        0
    } else {
        (bytes.len().saturating_sub(1)) / group
    };
    let mut out = String::with_capacity(hex_len + separators * sep_str.len());
    if bytes_per_sep > 0 {
        for (idx, &b) in bytes.iter().enumerate() {
            if idx > 0 && idx % group == 0 {
                out.push_str(sep_str);
            }
            out.push(char::from(HEX[(b >> 4) as usize]));
            out.push(char::from(HEX[(b & 0xF) as usize]));
        }
    } else {
        let mut first_group = bytes.len() % group;
        if first_group == 0 {
            first_group = group;
        }
        for (idx, &b) in bytes.iter().enumerate() {
            if idx == first_group
                || (idx > first_group && (idx - first_group).is_multiple_of(group))
            {
                out.push_str(sep_str);
            }
            out.push(char::from(HEX[(b >> 4) as usize]));
            out.push(char::from(HEX[(b & 0xF) as usize]));
        }
    }
    out
}

fn bytes_hex_from_bits(
    _py: &PyToken<'_>,
    bytes: &[u8],
    sep_bits: u64,
    bytes_per_sep_bits: u64,
) -> u64 {
    let sep_opt = if sep_bits == missing_bits(_py) {
        None
    } else {
        match bytes_hex_sep_from_bits(_py, sep_bits) {
            Ok(sep) => sep,
            Err(err_bits) => return err_bits,
        }
    };
    let bytes_per_sep = if bytes_per_sep_bits == missing_bits(_py) {
        1
    } else {
        index_i64_from_obj(_py, bytes_per_sep_bits, "bytes_per_sep must be int")
    };
    if exception_pending(_py) {
        return MoltObject::none().bits();
    }
    if bytes_per_sep == 0 {
        return raise_exception::<_>(_py, "ValueError", "bytes_per_sep must not be 0");
    }
    let text = bytes_hex_string(bytes, sep_opt.as_deref(), bytes_per_sep);
    let ptr = alloc_string(_py, text.as_bytes());
    if ptr.is_null() {
        return MoltObject::none().bits();
    }
    MoltObject::from_ptr(ptr).bits()
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_upper(hay_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_BYTES {
                return MoltObject::none().bits();
            }
            let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
            let out = bytes_ascii_upper(hay_bytes);
            let ptr = alloc_bytes(_py, &out);
            if ptr.is_null() {
                return MoltObject::none().bits();
            }
            MoltObject::from_ptr(ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_lower(hay_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_BYTES {
                return MoltObject::none().bits();
            }
            let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
            let out = bytes_ascii_lower(hay_bytes);
            let ptr = alloc_bytes(_py, &out);
            if ptr.is_null() {
                return MoltObject::none().bits();
            }
            MoltObject::from_ptr(ptr).bits()
        }
    })
}

fn bytes_translate_impl(
    _py: &PyToken<'_>,
    hay_bytes: &[u8],
    table_bits: u64,
    delete_bits: u64,
) -> Result<Vec<u8>, u64> {
    let table_obj = obj_from_bits(table_bits);
    let table_opt = if table_obj.is_none() {
        None
    } else {
        let table_ptr = match table_obj.as_ptr() {
            Some(ptr) => ptr,
            None => {
                let msg = format!(
                    "a bytes-like object is required, not '{}'",
                    type_name(_py, table_obj)
                );
                return Err(raise_exception::<_>(_py, "TypeError", &msg));
            }
        };
        let table_bytes = match unsafe { bytes_like_slice(table_ptr) } {
            Some(slice) => slice,
            None => {
                let msg = format!(
                    "a bytes-like object is required, not '{}'",
                    type_name(_py, table_obj)
                );
                return Err(raise_exception::<_>(_py, "TypeError", &msg));
            }
        };
        if table_bytes.len() != 256 {
            return Err(raise_exception::<_>(
                _py,
                "ValueError",
                "translation table must be 256 characters long",
            ));
        }
        Some(table_bytes)
    };
    let delete_bytes = if is_missing_bits(_py, delete_bits) {
        &[]
    } else {
        let delete_obj = obj_from_bits(delete_bits);
        let delete_ptr = match delete_obj.as_ptr() {
            Some(ptr) => ptr,
            None => {
                let msg = format!(
                    "a bytes-like object is required, not '{}'",
                    type_name(_py, delete_obj)
                );
                return Err(raise_exception::<_>(_py, "TypeError", &msg));
            }
        };
        match unsafe { bytes_like_slice(delete_ptr) } {
            Some(slice) => slice,
            None => {
                let msg = format!(
                    "a bytes-like object is required, not '{}'",
                    type_name(_py, delete_obj)
                );
                return Err(raise_exception::<_>(_py, "TypeError", &msg));
            }
        }
    };
    if hay_bytes.is_empty() {
        return Ok(Vec::new());
    }
    let mut delete_map = [false; 256];
    for &b in delete_bytes {
        delete_map[b as usize] = true;
    }
    let mut out = Vec::with_capacity(hay_bytes.len());
    match table_opt {
        Some(table) => {
            for &b in hay_bytes {
                if delete_map[b as usize] {
                    continue;
                }
                out.push(table[b as usize]);
            }
        }
        None => {
            for &b in hay_bytes {
                if delete_map[b as usize] {
                    continue;
                }
                out.push(b);
            }
        }
    }
    Ok(out)
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_translate(hay_bits: u64, table_bits: u64, delete_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_BYTES {
                return MoltObject::none().bits();
            }
            let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
            let out = match bytes_translate_impl(_py, hay_bytes, table_bits, delete_bits) {
                Ok(out) => out,
                Err(err_bits) => return err_bits,
            };
            let ptr = alloc_bytes(_py, &out);
            if ptr.is_null() {
                return MoltObject::none().bits();
            }
            MoltObject::from_ptr(ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_translate(
    hay_bits: u64,
    table_bits: u64,
    delete_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_BYTEARRAY {
                return MoltObject::none().bits();
            }
            let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
            let out = match bytes_translate_impl(_py, hay_bytes, table_bits, delete_bits) {
                Ok(out) => out,
                Err(err_bits) => return err_bits,
            };
            let ptr = alloc_bytearray(_py, &out);
            if ptr.is_null() {
                return MoltObject::none().bits();
            }
            MoltObject::from_ptr(ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_maketrans(from_bits: u64, to_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let from_obj = obj_from_bits(from_bits);
        let to_obj = obj_from_bits(to_bits);
        let from_ptr = match from_obj.as_ptr() {
            Some(ptr) => ptr,
            None => {
                let msg = format!(
                    "a bytes-like object is required, not '{}'",
                    type_name(_py, from_obj)
                );
                return raise_exception::<_>(_py, "TypeError", &msg);
            }
        };
        let to_ptr = match to_obj.as_ptr() {
            Some(ptr) => ptr,
            None => {
                let msg = format!(
                    "a bytes-like object is required, not '{}'",
                    type_name(_py, to_obj)
                );
                return raise_exception::<_>(_py, "TypeError", &msg);
            }
        };
        let from_bytes = match unsafe { bytes_like_slice(from_ptr) } {
            Some(slice) => slice,
            None => {
                let msg = format!(
                    "a bytes-like object is required, not '{}'",
                    type_name(_py, from_obj)
                );
                return raise_exception::<_>(_py, "TypeError", &msg);
            }
        };
        let to_bytes = match unsafe { bytes_like_slice(to_ptr) } {
            Some(slice) => slice,
            None => {
                let msg = format!(
                    "a bytes-like object is required, not '{}'",
                    type_name(_py, to_obj)
                );
                return raise_exception::<_>(_py, "TypeError", &msg);
            }
        };
        if from_bytes.len() != to_bytes.len() {
            return raise_exception::<_>(
                _py,
                "ValueError",
                "maketrans arguments must have same length",
            );
        }
        let mut table = [0u8; 256];
        for (idx, slot) in table.iter_mut().enumerate() {
            *slot = idx as u8;
        }
        for (from_byte, to_byte) in from_bytes.iter().zip(to_bytes.iter()) {
            table[*from_byte as usize] = *to_byte;
        }
        let ptr = alloc_bytes(_py, &table);
        if ptr.is_null() {
            return MoltObject::none().bits();
        }
        MoltObject::from_ptr(ptr).bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_hex(hay_bits: u64, sep_bits: u64, bytes_per_sep_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_BYTES {
                return MoltObject::none().bits();
            }
            let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
            bytes_hex_from_bits(_py, hay_bytes, sep_bits, bytes_per_sep_bits)
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_hex(hay_bits: u64, sep_bits: u64, bytes_per_sep_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let Some(hay_ptr) = hay.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(hay_ptr) != TYPE_ID_BYTEARRAY {
                return MoltObject::none().bits();
            }
            let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
            bytes_hex_from_bits(_py, hay_bytes, sep_bits, bytes_per_sep_bits)
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_replace(
    hay_bits: u64,
    needle_bits: u64,
    replacement_bits: u64,
    count_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let hay = obj_from_bits(hay_bits);
        let needle = obj_from_bits(needle_bits);
        let replacement = obj_from_bits(replacement_bits);
        let count_err = format!(
            "'{}' object cannot be interpreted as an integer",
            type_name(_py, obj_from_bits(count_bits))
        );
        let count = index_i64_from_obj(_py, count_bits, &count_err);
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        if let Some(hay_ptr) = hay.as_ptr() {
            unsafe {
                if object_type_id(hay_ptr) != TYPE_ID_BYTEARRAY {
                    return MoltObject::none().bits();
                }
                let hay_bytes = bytes_like_slice(hay_ptr).unwrap_or(&[]);
                let needle_ptr = match needle.as_ptr() {
                    Some(ptr) => ptr,
                    None => {
                        let msg = format!(
                            "a bytes-like object is required, not '{}'",
                            type_name(_py, needle)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                let needle_bytes = match bytes_like_slice(needle_ptr) {
                    Some(slice) => slice,
                    None => {
                        let msg = format!(
                            "a bytes-like object is required, not '{}'",
                            type_name(_py, needle)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                let repl_ptr = match replacement.as_ptr() {
                    Some(ptr) => ptr,
                    None => {
                        let msg = format!(
                            "a bytes-like object is required, not '{}'",
                            type_name(_py, replacement)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                let repl_bytes = match bytes_like_slice(repl_ptr) {
                    Some(slice) => slice,
                    None => {
                        let msg = format!(
                            "a bytes-like object is required, not '{}'",
                            type_name(_py, replacement)
                        );
                        return raise_exception::<_>(_py, "TypeError", &msg);
                    }
                };
                let out = if count < 0 {
                    match replace_bytes_impl(hay_bytes, needle_bytes, repl_bytes) {
                        Some(out) => out,
                        None => return MoltObject::none().bits(),
                    }
                } else {
                    replace_bytes_impl_limit(hay_bytes, needle_bytes, repl_bytes, count as usize)
                };
                let ptr = alloc_bytearray(_py, &out);
                if ptr.is_null() {
                    return MoltObject::none().bits();
                }
                return MoltObject::from_ptr(ptr).bits();
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_intarray_from_seq(bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(bits);
        if let Some(ptr) = obj.as_ptr() {
            unsafe {
                let type_id = object_type_id(ptr);
                let elems = if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                    seq_vec_ref(ptr)
                } else {
                    return MoltObject::none().bits();
                };
                let mut out = Vec::with_capacity(elems.len());
                for &elem in elems {
                    let val = MoltObject::from_bits(elem);
                    if let Some(i) = val.as_int() {
                        out.push(i);
                    } else {
                        return MoltObject::none().bits();
                    }
                }
                let out_ptr = alloc_intarray(_py, &out);
                if out_ptr.is_null() {
                    return MoltObject::none().bits();
                }
                return MoltObject::from_ptr(out_ptr).bits();
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_tuple_from_list(bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(bits);
        if let Some(ptr) = obj.as_ptr() {
            unsafe {
                let type_id = object_type_id(ptr);
                if type_id == TYPE_ID_TUPLE {
                    inc_ref_bits(_py, bits);
                    return bits;
                }
                if type_id == TYPE_ID_LIST {
                    let elems = seq_vec_ref(ptr);
                    let out_ptr = alloc_tuple(_py, elems);
                    if out_ptr.is_null() {
                        return MoltObject::none().bits();
                    }
                    return MoltObject::from_ptr(out_ptr).bits();
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[derive(Clone, Copy)]
enum BytesCtorKind {
    Bytes,
    Bytearray,
}

impl BytesCtorKind {
    pub(crate) fn name(self) -> &'static str {
        match self {
            BytesCtorKind::Bytes => "bytes",
            BytesCtorKind::Bytearray => "bytearray",
        }
    }

    fn ctor_label(self) -> &'static str {
        match self {
            BytesCtorKind::Bytes => "bytes()",
            BytesCtorKind::Bytearray => "bytearray()",
        }
    }

    fn range_error(self) -> &'static str {
        match self {
            BytesCtorKind::Bytes => "bytes must be in range(0, 256)",
            BytesCtorKind::Bytearray => "byte must be in range(0, 256)",
        }
    }

    fn non_iterable_message(self, type_name: &str) -> String {
        format!("cannot convert '{}' object to {}", type_name, self.name())
    }

    fn arg_type_message(self, arg: &str, type_name: &str) -> String {
        format!(
            "{} argument '{}' must be str, not {}",
            self.ctor_label(),
            arg,
            type_name
        )
    }
}

#[derive(Clone, Copy)]
pub(crate) enum EncodingKind {
    Utf8,
    Utf8Sig,
    Cp1252,
    Cp437,
    Cp850,
    Cp860,
    Cp862,
    Cp863,
    Cp865,
    Cp866,
    Cp874,
    Cp1250,
    Cp1251,
    Cp1253,
    Cp1254,
    Cp1255,
    Cp1256,
    Cp1257,
    Koi8R,
    Koi8U,
    Iso8859_2,
    Iso8859_3,
    Iso8859_4,
    Iso8859_5,
    Iso8859_6,
    Iso8859_7,
    Iso8859_8,
    Iso8859_10,
    Iso8859_15,
    MacRoman,
    Latin1,
    Ascii,
    UnicodeEscape,
    Utf16,
    Utf16LE,
    Utf16BE,
    Utf32,
    Utf32LE,
    Utf32BE,
}

impl EncodingKind {
    pub(crate) fn name(self) -> &'static str {
        match self {
            EncodingKind::Utf8 => "utf-8",
            EncodingKind::Utf8Sig => "utf-8-sig",
            EncodingKind::Cp1252 => "cp1252",
            EncodingKind::Cp437 => "cp437",
            EncodingKind::Cp850 => "cp850",
            EncodingKind::Cp860 => "cp860",
            EncodingKind::Cp862 => "cp862",
            EncodingKind::Cp863 => "cp863",
            EncodingKind::Cp865 => "cp865",
            EncodingKind::Cp866 => "cp866",
            EncodingKind::Cp874 => "cp874",
            EncodingKind::Cp1250 => "cp1250",
            EncodingKind::Cp1251 => "cp1251",
            EncodingKind::Cp1253 => "cp1253",
            EncodingKind::Cp1254 => "cp1254",
            EncodingKind::Cp1255 => "cp1255",
            EncodingKind::Cp1256 => "cp1256",
            EncodingKind::Cp1257 => "cp1257",
            EncodingKind::Koi8R => "koi8-r",
            EncodingKind::Koi8U => "koi8-u",
            EncodingKind::Iso8859_2 => "iso8859-2",
            EncodingKind::Iso8859_3 => "iso8859-3",
            EncodingKind::Iso8859_4 => "iso8859-4",
            EncodingKind::Iso8859_5 => "iso8859-5",
            EncodingKind::Iso8859_6 => "iso8859-6",
            EncodingKind::Iso8859_7 => "iso8859-7",
            EncodingKind::Iso8859_8 => "iso8859-8",
            EncodingKind::Iso8859_10 => "iso8859-10",
            EncodingKind::Iso8859_15 => "iso8859-15",
            EncodingKind::MacRoman => "mac-roman",
            EncodingKind::Latin1 => "latin-1",
            EncodingKind::Ascii => "ascii",
            EncodingKind::UnicodeEscape => "unicode-escape",
            EncodingKind::Utf16 => "utf-16",
            EncodingKind::Utf16LE => "utf-16-le",
            EncodingKind::Utf16BE => "utf-16-be",
            EncodingKind::Utf32 => "utf-32",
            EncodingKind::Utf32LE => "utf-32-le",
            EncodingKind::Utf32BE => "utf-32-be",
        }
    }

    fn ordinal_limit(self) -> u32 {
        match self {
            EncodingKind::Ascii => 128,
            EncodingKind::Latin1 => 256,
            EncodingKind::UnicodeEscape => u32::MAX,
            EncodingKind::Cp1252 => u32::MAX,
            EncodingKind::Cp437 => u32::MAX,
            EncodingKind::Cp850 => u32::MAX,
            EncodingKind::Cp860 => u32::MAX,
            EncodingKind::Cp862 => u32::MAX,
            EncodingKind::Cp863 => u32::MAX,
            EncodingKind::Cp865 => u32::MAX,
            EncodingKind::Cp866 => u32::MAX,
            EncodingKind::Cp874 => u32::MAX,
            EncodingKind::Cp1250 => u32::MAX,
            EncodingKind::Cp1251 => u32::MAX,
            EncodingKind::Cp1253 => u32::MAX,
            EncodingKind::Cp1254 => u32::MAX,
            EncodingKind::Cp1255 => u32::MAX,
            EncodingKind::Cp1256 => u32::MAX,
            EncodingKind::Cp1257 => u32::MAX,
            EncodingKind::Koi8R => u32::MAX,
            EncodingKind::Koi8U => u32::MAX,
            EncodingKind::Iso8859_2 => u32::MAX,
            EncodingKind::Iso8859_3 => u32::MAX,
            EncodingKind::Iso8859_4 => u32::MAX,
            EncodingKind::Iso8859_5 => u32::MAX,
            EncodingKind::Iso8859_6 => u32::MAX,
            EncodingKind::Iso8859_7 => u32::MAX,
            EncodingKind::Iso8859_8 => u32::MAX,
            EncodingKind::Iso8859_10 => u32::MAX,
            EncodingKind::Iso8859_15 => u32::MAX,
            EncodingKind::MacRoman => u32::MAX,
            EncodingKind::Utf8
            | EncodingKind::Utf8Sig
            | EncodingKind::Utf16
            | EncodingKind::Utf16LE
            | EncodingKind::Utf16BE
            | EncodingKind::Utf32
            | EncodingKind::Utf32LE
            | EncodingKind::Utf32BE => u32::MAX,
        }
    }
}

pub(crate) fn encoding_kind_name(kind: EncodingKind) -> &'static str {
    kind.name()
}

pub(crate) enum EncodeError {
    UnknownEncoding(String),
    UnknownErrorHandler(String),
    InvalidChar {
        encoding: &'static str,
        code: u32,
        pos: usize,
        limit: u32,
    },
}

pub(crate) fn normalize_encoding(name: &str) -> Option<EncodingKind> {
    let normalized = name.to_ascii_lowercase().replace('_', "-");
    match normalized.as_str() {
        "utf-8" | "utf8" => Some(EncodingKind::Utf8),
        "utf-8-sig" | "utf8-sig" => Some(EncodingKind::Utf8Sig),
        "cp1252" | "cp-1252" | "windows-1252" => Some(EncodingKind::Cp1252),
        "cp437" | "ibm437" | "437" => Some(EncodingKind::Cp437),
        "cp850" | "ibm850" | "850" | "cp-850" => Some(EncodingKind::Cp850),
        "cp860" | "ibm860" | "860" | "cp-860" => Some(EncodingKind::Cp860),
        "cp862" | "ibm862" | "862" | "cp-862" => Some(EncodingKind::Cp862),
        "cp863" | "ibm863" | "863" | "cp-863" => Some(EncodingKind::Cp863),
        "cp865" | "ibm865" | "865" | "cp-865" => Some(EncodingKind::Cp865),
        "cp866" | "ibm866" | "866" | "cp-866" => Some(EncodingKind::Cp866),
        "cp874" | "cp-874" | "windows-874" => Some(EncodingKind::Cp874),
        "cp1250" | "cp-1250" | "windows-1250" => Some(EncodingKind::Cp1250),
        "cp1251" | "cp-1251" | "windows-1251" => Some(EncodingKind::Cp1251),
        "cp1253" | "cp-1253" | "windows-1253" => Some(EncodingKind::Cp1253),
        "cp1254" | "cp-1254" | "windows-1254" => Some(EncodingKind::Cp1254),
        "cp1255" | "cp-1255" | "windows-1255" => Some(EncodingKind::Cp1255),
        "cp1256" | "cp-1256" | "windows-1256" => Some(EncodingKind::Cp1256),
        "cp1257" | "cp-1257" | "windows-1257" => Some(EncodingKind::Cp1257),
        "koi8-r" | "koi8r" | "koi8_r" => Some(EncodingKind::Koi8R),
        "koi8-u" | "koi8u" | "koi8_u" => Some(EncodingKind::Koi8U),
        "iso-8859-2" | "iso8859-2" | "latin2" | "latin-2" => Some(EncodingKind::Iso8859_2),
        "iso-8859-3" | "iso8859-3" | "latin3" | "latin-3" => Some(EncodingKind::Iso8859_3),
        "iso-8859-4" | "iso8859-4" | "latin4" | "latin-4" => Some(EncodingKind::Iso8859_4),
        "iso-8859-5" | "iso8859-5" | "cyrillic" => Some(EncodingKind::Iso8859_5),
        "iso-8859-6" | "iso8859-6" | "arabic" => Some(EncodingKind::Iso8859_6),
        "iso-8859-7" | "iso8859-7" | "greek" => Some(EncodingKind::Iso8859_7),
        "iso-8859-8" | "iso8859-8" | "hebrew" => Some(EncodingKind::Iso8859_8),
        "iso-8859-10" | "iso8859-10" | "latin6" | "latin-6" => Some(EncodingKind::Iso8859_10),
        "iso-8859-15" | "iso8859-15" | "latin9" | "latin-9" | "latin_9" => {
            Some(EncodingKind::Iso8859_15)
        }
        "mac-roman" | "macroman" | "mac_roman" => Some(EncodingKind::MacRoman),
        "latin-1" | "latin1" | "iso-8859-1" | "iso8859-1" => Some(EncodingKind::Latin1),
        "ascii" | "us-ascii" => Some(EncodingKind::Ascii),
        "unicode-escape" | "unicodeescape" => Some(EncodingKind::UnicodeEscape),
        "utf-16" | "utf16" => Some(EncodingKind::Utf16),
        "utf-16le" | "utf-16-le" | "utf16le" => Some(EncodingKind::Utf16LE),
        "utf-16be" | "utf-16-be" | "utf16be" => Some(EncodingKind::Utf16BE),
        "utf-32" | "utf32" => Some(EncodingKind::Utf32),
        "utf-32le" | "utf-32-le" | "utf32le" => Some(EncodingKind::Utf32LE),
        "utf-32be" | "utf-32-be" | "utf32be" => Some(EncodingKind::Utf32BE),
        _ => None,
    }
}

#[derive(Clone, Copy)]
enum Endian {
    Little,
    Big,
}

fn native_endian() -> Endian {
    if cfg!(target_endian = "big") {
        Endian::Big
    } else {
        Endian::Little
    }
}

fn push_u16(out: &mut Vec<u8>, val: u16, endian: Endian) {
    match endian {
        Endian::Little => out.extend_from_slice(&val.to_le_bytes()),
        Endian::Big => out.extend_from_slice(&val.to_be_bytes()),
    }
}

fn push_u32(out: &mut Vec<u8>, val: u32, endian: Endian) {
    match endian {
        Endian::Little => out.extend_from_slice(&val.to_le_bytes()),
        Endian::Big => out.extend_from_slice(&val.to_be_bytes()),
    }
}

#[allow(dead_code)]
fn encode_utf16(text: &str, endian: Endian, with_bom: bool) -> Vec<u8> {
    let mut out = Vec::with_capacity(text.len().saturating_mul(2) + if with_bom { 2 } else { 0 });
    if with_bom {
        push_u16(&mut out, 0xFEFF, endian);
    }
    for code in text.encode_utf16() {
        push_u16(&mut out, code, endian);
    }
    out
}

#[allow(dead_code)]
fn encode_utf32(text: &str, endian: Endian, with_bom: bool) -> Vec<u8> {
    let mut out = Vec::with_capacity(text.len().saturating_mul(4) + if with_bom { 4 } else { 0 });
    if with_bom {
        push_u32(&mut out, 0x0000_FEFF, endian);
    }
    for ch in text.chars() {
        push_u32(&mut out, ch as u32, endian);
    }
    out
}

fn is_surrogate(code: u32) -> bool {
    (0xD800..=0xDFFF).contains(&code)
}

fn unicode_escape_codepoint(code: u32) -> String {
    if code <= 0xFF {
        format!("\\x{code:02x}")
    } else if code <= 0xFFFF {
        format!("\\u{code:04x}")
    } else {
        format!("\\U{code:08x}")
    }
}

fn unicode_name_escape(code: u32) -> String {
    if let Some(ch) = char::from_u32(code) {
        if let Some(name) = unicode_names2::name(ch) {
            return format!("\\N{{{name}}}");
        }
    }
    unicode_escape_codepoint(code)
}

fn unicode_escape(ch: char) -> String {
    unicode_escape_codepoint(ch as u32)
}

pub(crate) fn encode_error_reason(encoding: &str, code: u32, limit: u32) -> String {
    if encoding == "charmap" {
        return "character maps to <undefined>".to_string();
    }
    if is_surrogate(code) && encoding.starts_with("utf-") {
        return "surrogates not allowed".to_string();
    }
    format!("ordinal not in range({limit})")
}

#[allow(dead_code)]
fn push_backslash_bytes(out: &mut String, bytes: &[u8]) {
    const HEX: &[u8; 16] = b"0123456789abcdef";
    for &byte in bytes {
        out.push('\\');
        out.push('x');
        out.push(HEX[(byte >> 4) as usize] as char);
        out.push(HEX[(byte & 0x0f) as usize] as char);
    }
}

fn push_backslash_bytes_vec(out: &mut Vec<u8>, bytes: &[u8]) {
    const HEX: &[u8; 16] = b"0123456789abcdef";
    for &byte in bytes {
        out.push(b'\\');
        out.push(b'x');
        out.push(HEX[(byte >> 4) as usize]);
        out.push(HEX[(byte & 0x0f) as usize]);
    }
}

fn push_hex_escape(out: &mut Vec<u8>, prefix: u8, code: u32, width: usize) {
    const HEX: &[u8; 16] = b"0123456789abcdef";
    out.push(b'\\');
    out.push(prefix);
    for shift in (0..width).rev() {
        let nibble = ((code >> (shift * 4)) & 0x0f) as usize;
        out.push(HEX[nibble]);
    }
}

fn xmlcharref_bytes(code: u32, buf: &mut [u8; 16]) -> &[u8] {
    buf[0] = b'&';
    buf[1] = b'#';
    let mut digits = [0u8; 10];
    let mut idx = digits.len();
    let mut value = code;
    loop {
        idx = idx.saturating_sub(1);
        digits[idx] = b'0' + (value % 10) as u8;
        value /= 10;
        if value == 0 {
            break;
        }
    }
    let digits_len = digits.len() - idx;
    buf[2..2 + digits_len].copy_from_slice(&digits[idx..]);
    buf[2 + digits_len] = b';';
    &buf[..2 + digits_len + 1]
}

fn push_xmlcharref_ascii(out: &mut Vec<u8>, code: u32) {
    let mut buf = [0u8; 16];
    let bytes = xmlcharref_bytes(code, &mut buf);
    out.extend_from_slice(bytes);
}

fn push_xmlcharref_utf16(out: &mut Vec<u8>, code: u32, endian: Endian) {
    let mut buf = [0u8; 16];
    let bytes = xmlcharref_bytes(code, &mut buf);
    for &byte in bytes {
        push_u16(out, byte as u16, endian);
    }
}

fn push_xmlcharref_utf32(out: &mut Vec<u8>, code: u32, endian: Endian) {
    let mut buf = [0u8; 16];
    let bytes = xmlcharref_bytes(code, &mut buf);
    for &byte in bytes {
        push_u32(out, byte as u32, endian);
    }
}

fn encode_cp1252_byte(code: u32) -> Option<u8> {
    if code <= 0x7F || (0xA0..=0xFF).contains(&code) {
        return Some(code as u8);
    }
    match code {
        0x20AC => Some(0x80),
        0x201A => Some(0x82),
        0x0192 => Some(0x83),
        0x201E => Some(0x84),
        0x2026 => Some(0x85),
        0x2020 => Some(0x86),
        0x2021 => Some(0x87),
        0x02C6 => Some(0x88),
        0x2030 => Some(0x89),
        0x0160 => Some(0x8A),
        0x2039 => Some(0x8B),
        0x0152 => Some(0x8C),
        0x017D => Some(0x8E),
        0x2018 => Some(0x91),
        0x2019 => Some(0x92),
        0x201C => Some(0x93),
        0x201D => Some(0x94),
        0x2022 => Some(0x95),
        0x2013 => Some(0x96),
        0x2014 => Some(0x97),
        0x02DC => Some(0x98),
        0x2122 => Some(0x99),
        0x0161 => Some(0x9A),
        0x203A => Some(0x9B),
        0x0153 => Some(0x9C),
        0x017E => Some(0x9E),
        0x0178 => Some(0x9F),
        _ => None,
    }
}

fn encode_cp437_byte(code: u32) -> Option<u8> {
    match code {
        0x00A0 => Some(0xFF),
        0x00A1 => Some(0xAD),
        0x00A2 => Some(0x9B),
        0x00A3 => Some(0x9C),
        0x00A5 => Some(0x9D),
        0x00AA => Some(0xA6),
        0x00AB => Some(0xAE),
        0x00AC => Some(0xAA),
        0x00B0 => Some(0xF8),
        0x00B1 => Some(0xF1),
        0x00B2 => Some(0xFD),
        0x00B5 => Some(0xE6),
        0x00B7 => Some(0xFA),
        0x00BA => Some(0xA7),
        0x00BB => Some(0xAF),
        0x00BC => Some(0xAC),
        0x00BD => Some(0xAB),
        0x00BF => Some(0xA8),
        0x00C4 => Some(0x8E),
        0x00C5 => Some(0x8F),
        0x00C6 => Some(0x92),
        0x00C7 => Some(0x80),
        0x00C9 => Some(0x90),
        0x00D1 => Some(0xA5),
        0x00D6 => Some(0x99),
        0x00DC => Some(0x9A),
        0x00DF => Some(0xE1),
        0x00E0 => Some(0x85),
        0x00E1 => Some(0xA0),
        0x00E2 => Some(0x83),
        0x00E4 => Some(0x84),
        0x00E5 => Some(0x86),
        0x00E6 => Some(0x91),
        0x00E7 => Some(0x87),
        0x00E8 => Some(0x8A),
        0x00E9 => Some(0x82),
        0x00EA => Some(0x88),
        0x00EB => Some(0x89),
        0x00EC => Some(0x8D),
        0x00ED => Some(0xA1),
        0x00EE => Some(0x8C),
        0x00EF => Some(0x8B),
        0x00F1 => Some(0xA4),
        0x00F2 => Some(0x95),
        0x00F3 => Some(0xA2),
        0x00F4 => Some(0x93),
        0x00F6 => Some(0x94),
        0x00F7 => Some(0xF6),
        0x00F9 => Some(0x97),
        0x00FA => Some(0xA3),
        0x00FB => Some(0x96),
        0x00FC => Some(0x81),
        0x00FF => Some(0x98),
        0x0192 => Some(0x9F),
        0x0393 => Some(0xE2),
        0x0398 => Some(0xE9),
        0x03A3 => Some(0xE4),
        0x03A6 => Some(0xE8),
        0x03A9 => Some(0xEA),
        0x03B1 => Some(0xE0),
        0x03B4 => Some(0xEB),
        0x03B5 => Some(0xEE),
        0x03C0 => Some(0xE3),
        0x03C3 => Some(0xE5),
        0x03C4 => Some(0xE7),
        0x03C6 => Some(0xED),
        0x207F => Some(0xFC),
        0x20A7 => Some(0x9E),
        0x2219 => Some(0xF9),
        0x221A => Some(0xFB),
        0x221E => Some(0xEC),
        0x2229 => Some(0xEF),
        0x2248 => Some(0xF7),
        0x2261 => Some(0xF0),
        0x2264 => Some(0xF3),
        0x2265 => Some(0xF2),
        0x2310 => Some(0xA9),
        0x2320 => Some(0xF4),
        0x2321 => Some(0xF5),
        0x2500 => Some(0xC4),
        0x2502 => Some(0xB3),
        0x250C => Some(0xDA),
        0x2510 => Some(0xBF),
        0x2514 => Some(0xC0),
        0x2518 => Some(0xD9),
        0x251C => Some(0xC3),
        0x2524 => Some(0xB4),
        0x252C => Some(0xC2),
        0x2534 => Some(0xC1),
        0x253C => Some(0xC5),
        0x2550 => Some(0xCD),
        0x2551 => Some(0xBA),
        0x2552 => Some(0xD5),
        0x2553 => Some(0xD6),
        0x2554 => Some(0xC9),
        0x2555 => Some(0xB8),
        0x2556 => Some(0xB7),
        0x2557 => Some(0xBB),
        0x2558 => Some(0xD4),
        0x2559 => Some(0xD3),
        0x255A => Some(0xC8),
        0x255B => Some(0xBE),
        0x255C => Some(0xBD),
        0x255D => Some(0xBC),
        0x255E => Some(0xC6),
        0x255F => Some(0xC7),
        0x2560 => Some(0xCC),
        0x2561 => Some(0xB5),
        0x2562 => Some(0xB6),
        0x2563 => Some(0xB9),
        0x2564 => Some(0xD1),
        0x2565 => Some(0xD2),
        0x2566 => Some(0xCB),
        0x2567 => Some(0xCF),
        0x2568 => Some(0xD0),
        0x2569 => Some(0xCA),
        0x256A => Some(0xD8),
        0x256B => Some(0xD7),
        0x256C => Some(0xCE),
        0x2580 => Some(0xDF),
        0x2584 => Some(0xDC),
        0x2588 => Some(0xDB),
        0x258C => Some(0xDD),
        0x2590 => Some(0xDE),
        0x2591 => Some(0xB0),
        0x2592 => Some(0xB1),
        0x2593 => Some(0xB2),
        0x25A0 => Some(0xFE),
        _ => None,
    }
}

fn encode_cp850_byte(code: u32) -> Option<u8> {
    match code {
        0x00A0 => Some(0xFF),
        0x00A1 => Some(0xAD),
        0x00A2 => Some(0xBD),
        0x00A3 => Some(0x9C),
        0x00A4 => Some(0xCF),
        0x00A5 => Some(0xBE),
        0x00A6 => Some(0xDD),
        0x00A7 => Some(0xF5),
        0x00A8 => Some(0xF9),
        0x00A9 => Some(0xB8),
        0x00AA => Some(0xA6),
        0x00AB => Some(0xAE),
        0x00AC => Some(0xAA),
        0x00AD => Some(0xF0),
        0x00AE => Some(0xA9),
        0x00AF => Some(0xEE),
        0x00B0 => Some(0xF8),
        0x00B1 => Some(0xF1),
        0x00B2 => Some(0xFD),
        0x00B3 => Some(0xFC),
        0x00B4 => Some(0xEF),
        0x00B5 => Some(0xE6),
        0x00B6 => Some(0xF4),
        0x00B7 => Some(0xFA),
        0x00B8 => Some(0xF7),
        0x00B9 => Some(0xFB),
        0x00BA => Some(0xA7),
        0x00BB => Some(0xAF),
        0x00BC => Some(0xAC),
        0x00BD => Some(0xAB),
        0x00BE => Some(0xF3),
        0x00BF => Some(0xA8),
        0x00C0 => Some(0xB7),
        0x00C1 => Some(0xB5),
        0x00C2 => Some(0xB6),
        0x00C3 => Some(0xC7),
        0x00C4 => Some(0x8E),
        0x00C5 => Some(0x8F),
        0x00C6 => Some(0x92),
        0x00C7 => Some(0x80),
        0x00C8 => Some(0xD4),
        0x00C9 => Some(0x90),
        0x00CA => Some(0xD2),
        0x00CB => Some(0xD3),
        0x00CC => Some(0xDE),
        0x00CD => Some(0xD6),
        0x00CE => Some(0xD7),
        0x00CF => Some(0xD8),
        0x00D0 => Some(0xD1),
        0x00D1 => Some(0xA5),
        0x00D2 => Some(0xE3),
        0x00D3 => Some(0xE0),
        0x00D4 => Some(0xE2),
        0x00D5 => Some(0xE5),
        0x00D6 => Some(0x99),
        0x00D7 => Some(0x9E),
        0x00D8 => Some(0x9D),
        0x00D9 => Some(0xEB),
        0x00DA => Some(0xE9),
        0x00DB => Some(0xEA),
        0x00DC => Some(0x9A),
        0x00DD => Some(0xED),
        0x00DE => Some(0xE8),
        0x00DF => Some(0xE1),
        0x00E0 => Some(0x85),
        0x00E1 => Some(0xA0),
        0x00E2 => Some(0x83),
        0x00E3 => Some(0xC6),
        0x00E4 => Some(0x84),
        0x00E5 => Some(0x86),
        0x00E6 => Some(0x91),
        0x00E7 => Some(0x87),
        0x00E8 => Some(0x8A),
        0x00E9 => Some(0x82),
        0x00EA => Some(0x88),
        0x00EB => Some(0x89),
        0x00EC => Some(0x8D),
        0x00ED => Some(0xA1),
        0x00EE => Some(0x8C),
        0x00EF => Some(0x8B),
        0x00F0 => Some(0xD0),
        0x00F1 => Some(0xA4),
        0x00F2 => Some(0x95),
        0x00F3 => Some(0xA2),
        0x00F4 => Some(0x93),
        0x00F5 => Some(0xE4),
        0x00F6 => Some(0x94),
        0x00F7 => Some(0xF6),
        0x00F8 => Some(0x9B),
        0x00F9 => Some(0x97),
        0x00FA => Some(0xA3),
        0x00FB => Some(0x96),
        0x00FC => Some(0x81),
        0x00FD => Some(0xEC),
        0x00FE => Some(0xE7),
        0x00FF => Some(0x98),
        0x0131 => Some(0xD5),
        0x0192 => Some(0x9F),
        0x2017 => Some(0xF2),
        0x2500 => Some(0xC4),
        0x2502 => Some(0xB3),
        0x250C => Some(0xDA),
        0x2510 => Some(0xBF),
        0x2514 => Some(0xC0),
        0x2518 => Some(0xD9),
        0x251C => Some(0xC3),
        0x2524 => Some(0xB4),
        0x252C => Some(0xC2),
        0x2534 => Some(0xC1),
        0x253C => Some(0xC5),
        0x2550 => Some(0xCD),
        0x2551 => Some(0xBA),
        0x2554 => Some(0xC9),
        0x2557 => Some(0xBB),
        0x255A => Some(0xC8),
        0x255D => Some(0xBC),
        0x2560 => Some(0xCC),
        0x2563 => Some(0xB9),
        0x2566 => Some(0xCB),
        0x2569 => Some(0xCA),
        0x256C => Some(0xCE),
        0x2580 => Some(0xDF),
        0x2584 => Some(0xDC),
        0x2588 => Some(0xDB),
        0x2591 => Some(0xB0),
        0x2592 => Some(0xB1),
        0x2593 => Some(0xB2),
        0x25A0 => Some(0xFE),
        _ => None,
    }
}

fn encode_cp865_byte(code: u32) -> Option<u8> {
    match code {
        0x00A0 => Some(0xFF),
        0x00A1 => Some(0xAD),
        0x00A3 => Some(0x9C),
        0x00A4 => Some(0xAF),
        0x00AA => Some(0xA6),
        0x00AB => Some(0xAE),
        0x00AC => Some(0xAA),
        0x00B0 => Some(0xF8),
        0x00B1 => Some(0xF1),
        0x00B2 => Some(0xFD),
        0x00B5 => Some(0xE6),
        0x00B7 => Some(0xFA),
        0x00BA => Some(0xA7),
        0x00BC => Some(0xAC),
        0x00BD => Some(0xAB),
        0x00BF => Some(0xA8),
        0x00C4 => Some(0x8E),
        0x00C5 => Some(0x8F),
        0x00C6 => Some(0x92),
        0x00C7 => Some(0x80),
        0x00C9 => Some(0x90),
        0x00D1 => Some(0xA5),
        0x00D6 => Some(0x99),
        0x00D8 => Some(0x9D),
        0x00DC => Some(0x9A),
        0x00DF => Some(0xE1),
        0x00E0 => Some(0x85),
        0x00E1 => Some(0xA0),
        0x00E2 => Some(0x83),
        0x00E4 => Some(0x84),
        0x00E5 => Some(0x86),
        0x00E6 => Some(0x91),
        0x00E7 => Some(0x87),
        0x00E8 => Some(0x8A),
        0x00E9 => Some(0x82),
        0x00EA => Some(0x88),
        0x00EB => Some(0x89),
        0x00EC => Some(0x8D),
        0x00ED => Some(0xA1),
        0x00EE => Some(0x8C),
        0x00EF => Some(0x8B),
        0x00F1 => Some(0xA4),
        0x00F2 => Some(0x95),
        0x00F3 => Some(0xA2),
        0x00F4 => Some(0x93),
        0x00F6 => Some(0x94),
        0x00F7 => Some(0xF6),
        0x00F8 => Some(0x9B),
        0x00F9 => Some(0x97),
        0x00FA => Some(0xA3),
        0x00FB => Some(0x96),
        0x00FC => Some(0x81),
        0x00FF => Some(0x98),
        0x0192 => Some(0x9F),
        0x0393 => Some(0xE2),
        0x0398 => Some(0xE9),
        0x03A3 => Some(0xE4),
        0x03A6 => Some(0xE8),
        0x03A9 => Some(0xEA),
        0x03B1 => Some(0xE0),
        0x03B4 => Some(0xEB),
        0x03B5 => Some(0xEE),
        0x03C0 => Some(0xE3),
        0x03C3 => Some(0xE5),
        0x03C4 => Some(0xE7),
        0x03C6 => Some(0xED),
        0x207F => Some(0xFC),
        0x20A7 => Some(0x9E),
        0x2219 => Some(0xF9),
        0x221A => Some(0xFB),
        0x221E => Some(0xEC),
        0x2229 => Some(0xEF),
        0x2248 => Some(0xF7),
        0x2261 => Some(0xF0),
        0x2264 => Some(0xF3),
        0x2265 => Some(0xF2),
        0x2310 => Some(0xA9),
        0x2320 => Some(0xF4),
        0x2321 => Some(0xF5),
        0x2500 => Some(0xC4),
        0x2502 => Some(0xB3),
        0x250C => Some(0xDA),
        0x2510 => Some(0xBF),
        0x2514 => Some(0xC0),
        0x2518 => Some(0xD9),
        0x251C => Some(0xC3),
        0x2524 => Some(0xB4),
        0x252C => Some(0xC2),
        0x2534 => Some(0xC1),
        0x253C => Some(0xC5),
        0x2550 => Some(0xCD),
        0x2551 => Some(0xBA),
        0x2552 => Some(0xD5),
        0x2553 => Some(0xD6),
        0x2554 => Some(0xC9),
        0x2555 => Some(0xB8),
        0x2556 => Some(0xB7),
        0x2557 => Some(0xBB),
        0x2558 => Some(0xD4),
        0x2559 => Some(0xD3),
        0x255A => Some(0xC8),
        0x255B => Some(0xBE),
        0x255C => Some(0xBD),
        0x255D => Some(0xBC),
        0x255E => Some(0xC6),
        0x255F => Some(0xC7),
        0x2560 => Some(0xCC),
        0x2561 => Some(0xB5),
        0x2562 => Some(0xB6),
        0x2563 => Some(0xB9),
        0x2564 => Some(0xD1),
        0x2565 => Some(0xD2),
        0x2566 => Some(0xCB),
        0x2567 => Some(0xCF),
        0x2568 => Some(0xD0),
        0x2569 => Some(0xCA),
        0x256A => Some(0xD8),
        0x256B => Some(0xD7),
        0x256C => Some(0xCE),
        0x2580 => Some(0xDF),
        0x2584 => Some(0xDC),
        0x2588 => Some(0xDB),
        0x258C => Some(0xDD),
        0x2590 => Some(0xDE),
        0x2591 => Some(0xB0),
        0x2592 => Some(0xB1),
        0x2593 => Some(0xB2),
        0x25A0 => Some(0xFE),
        _ => None,
    }
}

fn encode_cp874_byte(code: u32) -> Option<u8> {
    match code {
        0x00A0 => Some(0xA0),
        0x0E01 => Some(0xA1),
        0x0E02 => Some(0xA2),
        0x0E03 => Some(0xA3),
        0x0E04 => Some(0xA4),
        0x0E05 => Some(0xA5),
        0x0E06 => Some(0xA6),
        0x0E07 => Some(0xA7),
        0x0E08 => Some(0xA8),
        0x0E09 => Some(0xA9),
        0x0E0A => Some(0xAA),
        0x0E0B => Some(0xAB),
        0x0E0C => Some(0xAC),
        0x0E0D => Some(0xAD),
        0x0E0E => Some(0xAE),
        0x0E0F => Some(0xAF),
        0x0E10 => Some(0xB0),
        0x0E11 => Some(0xB1),
        0x0E12 => Some(0xB2),
        0x0E13 => Some(0xB3),
        0x0E14 => Some(0xB4),
        0x0E15 => Some(0xB5),
        0x0E16 => Some(0xB6),
        0x0E17 => Some(0xB7),
        0x0E18 => Some(0xB8),
        0x0E19 => Some(0xB9),
        0x0E1A => Some(0xBA),
        0x0E1B => Some(0xBB),
        0x0E1C => Some(0xBC),
        0x0E1D => Some(0xBD),
        0x0E1E => Some(0xBE),
        0x0E1F => Some(0xBF),
        0x0E20 => Some(0xC0),
        0x0E21 => Some(0xC1),
        0x0E22 => Some(0xC2),
        0x0E23 => Some(0xC3),
        0x0E24 => Some(0xC4),
        0x0E25 => Some(0xC5),
        0x0E26 => Some(0xC6),
        0x0E27 => Some(0xC7),
        0x0E28 => Some(0xC8),
        0x0E29 => Some(0xC9),
        0x0E2A => Some(0xCA),
        0x0E2B => Some(0xCB),
        0x0E2C => Some(0xCC),
        0x0E2D => Some(0xCD),
        0x0E2E => Some(0xCE),
        0x0E2F => Some(0xCF),
        0x0E30 => Some(0xD0),
        0x0E31 => Some(0xD1),
        0x0E32 => Some(0xD2),
        0x0E33 => Some(0xD3),
        0x0E34 => Some(0xD4),
        0x0E35 => Some(0xD5),
        0x0E36 => Some(0xD6),
        0x0E37 => Some(0xD7),
        0x0E38 => Some(0xD8),
        0x0E39 => Some(0xD9),
        0x0E3A => Some(0xDA),
        0x0E3F => Some(0xDF),
        0x0E40 => Some(0xE0),
        0x0E41 => Some(0xE1),
        0x0E42 => Some(0xE2),
        0x0E43 => Some(0xE3),
        0x0E44 => Some(0xE4),
        0x0E45 => Some(0xE5),
        0x0E46 => Some(0xE6),
        0x0E47 => Some(0xE7),
        0x0E48 => Some(0xE8),
        0x0E49 => Some(0xE9),
        0x0E4A => Some(0xEA),
        0x0E4B => Some(0xEB),
        0x0E4C => Some(0xEC),
        0x0E4D => Some(0xED),
        0x0E4E => Some(0xEE),
        0x0E4F => Some(0xEF),
        0x0E50 => Some(0xF0),
        0x0E51 => Some(0xF1),
        0x0E52 => Some(0xF2),
        0x0E53 => Some(0xF3),
        0x0E54 => Some(0xF4),
        0x0E55 => Some(0xF5),
        0x0E56 => Some(0xF6),
        0x0E57 => Some(0xF7),
        0x0E58 => Some(0xF8),
        0x0E59 => Some(0xF9),
        0x0E5A => Some(0xFA),
        0x0E5B => Some(0xFB),
        0x2013 => Some(0x96),
        0x2014 => Some(0x97),
        0x2018 => Some(0x91),
        0x2019 => Some(0x92),
        0x201C => Some(0x93),
        0x201D => Some(0x94),
        0x2022 => Some(0x95),
        0x2026 => Some(0x85),
        0x20AC => Some(0x80),
        _ => None,
    }
}

fn encode_cp1250_byte(code: u32) -> Option<u8> {
    match code {
        0x00A0 => Some(0xA0),
        0x00A4 => Some(0xA4),
        0x00A6 => Some(0xA6),
        0x00A7 => Some(0xA7),
        0x00A8 => Some(0xA8),
        0x00A9 => Some(0xA9),
        0x00AB => Some(0xAB),
        0x00AC => Some(0xAC),
        0x00AD => Some(0xAD),
        0x00AE => Some(0xAE),
        0x00B0 => Some(0xB0),
        0x00B1 => Some(0xB1),
        0x00B4 => Some(0xB4),
        0x00B5 => Some(0xB5),
        0x00B6 => Some(0xB6),
        0x00B7 => Some(0xB7),
        0x00B8 => Some(0xB8),
        0x00BB => Some(0xBB),
        0x00C1 => Some(0xC1),
        0x00C2 => Some(0xC2),
        0x00C4 => Some(0xC4),
        0x00C7 => Some(0xC7),
        0x00C9 => Some(0xC9),
        0x00CB => Some(0xCB),
        0x00CD => Some(0xCD),
        0x00CE => Some(0xCE),
        0x00D3 => Some(0xD3),
        0x00D4 => Some(0xD4),
        0x00D6 => Some(0xD6),
        0x00D7 => Some(0xD7),
        0x00DA => Some(0xDA),
        0x00DC => Some(0xDC),
        0x00DD => Some(0xDD),
        0x00DF => Some(0xDF),
        0x00E1 => Some(0xE1),
        0x00E2 => Some(0xE2),
        0x00E4 => Some(0xE4),
        0x00E7 => Some(0xE7),
        0x00E9 => Some(0xE9),
        0x00EB => Some(0xEB),
        0x00ED => Some(0xED),
        0x00EE => Some(0xEE),
        0x00F3 => Some(0xF3),
        0x00F4 => Some(0xF4),
        0x00F6 => Some(0xF6),
        0x00F7 => Some(0xF7),
        0x00FA => Some(0xFA),
        0x00FC => Some(0xFC),
        0x00FD => Some(0xFD),
        0x0102 => Some(0xC3),
        0x0103 => Some(0xE3),
        0x0104 => Some(0xA5),
        0x0105 => Some(0xB9),
        0x0106 => Some(0xC6),
        0x0107 => Some(0xE6),
        0x010C => Some(0xC8),
        0x010D => Some(0xE8),
        0x010E => Some(0xCF),
        0x010F => Some(0xEF),
        0x0110 => Some(0xD0),
        0x0111 => Some(0xF0),
        0x0118 => Some(0xCA),
        0x0119 => Some(0xEA),
        0x011A => Some(0xCC),
        0x011B => Some(0xEC),
        0x0139 => Some(0xC5),
        0x013A => Some(0xE5),
        0x013D => Some(0xBC),
        0x013E => Some(0xBE),
        0x0141 => Some(0xA3),
        0x0142 => Some(0xB3),
        0x0143 => Some(0xD1),
        0x0144 => Some(0xF1),
        0x0147 => Some(0xD2),
        0x0148 => Some(0xF2),
        0x0150 => Some(0xD5),
        0x0151 => Some(0xF5),
        0x0154 => Some(0xC0),
        0x0155 => Some(0xE0),
        0x0158 => Some(0xD8),
        0x0159 => Some(0xF8),
        0x015A => Some(0x8C),
        0x015B => Some(0x9C),
        0x015E => Some(0xAA),
        0x015F => Some(0xBA),
        0x0160 => Some(0x8A),
        0x0161 => Some(0x9A),
        0x0162 => Some(0xDE),
        0x0163 => Some(0xFE),
        0x0164 => Some(0x8D),
        0x0165 => Some(0x9D),
        0x016E => Some(0xD9),
        0x016F => Some(0xF9),
        0x0170 => Some(0xDB),
        0x0171 => Some(0xFB),
        0x0179 => Some(0x8F),
        0x017A => Some(0x9F),
        0x017B => Some(0xAF),
        0x017C => Some(0xBF),
        0x017D => Some(0x8E),
        0x017E => Some(0x9E),
        0x02C7 => Some(0xA1),
        0x02D8 => Some(0xA2),
        0x02D9 => Some(0xFF),
        0x02DB => Some(0xB2),
        0x02DD => Some(0xBD),
        0x2013 => Some(0x96),
        0x2014 => Some(0x97),
        0x2018 => Some(0x91),
        0x2019 => Some(0x92),
        0x201A => Some(0x82),
        0x201C => Some(0x93),
        0x201D => Some(0x94),
        0x201E => Some(0x84),
        0x2020 => Some(0x86),
        0x2021 => Some(0x87),
        0x2022 => Some(0x95),
        0x2026 => Some(0x85),
        0x2030 => Some(0x89),
        0x2039 => Some(0x8B),
        0x203A => Some(0x9B),
        0x20AC => Some(0x80),
        0x2122 => Some(0x99),
        _ => None,
    }
}

fn encode_cp1251_byte(code: u32) -> Option<u8> {
    match code {
        0x00A0 => Some(0xA0),
        0x00A4 => Some(0xA4),
        0x00A6 => Some(0xA6),
        0x00A7 => Some(0xA7),
        0x00A9 => Some(0xA9),
        0x00AB => Some(0xAB),
        0x00AC => Some(0xAC),
        0x00AD => Some(0xAD),
        0x00AE => Some(0xAE),
        0x00B0 => Some(0xB0),
        0x00B1 => Some(0xB1),
        0x00B5 => Some(0xB5),
        0x00B6 => Some(0xB6),
        0x00B7 => Some(0xB7),
        0x00BB => Some(0xBB),
        0x0401 => Some(0xA8),
        0x0402 => Some(0x80),
        0x0403 => Some(0x81),
        0x0404 => Some(0xAA),
        0x0405 => Some(0xBD),
        0x0406 => Some(0xB2),
        0x0407 => Some(0xAF),
        0x0408 => Some(0xA3),
        0x0409 => Some(0x8A),
        0x040A => Some(0x8C),
        0x040B => Some(0x8E),
        0x040C => Some(0x8D),
        0x040E => Some(0xA1),
        0x040F => Some(0x8F),
        0x0410 => Some(0xC0),
        0x0411 => Some(0xC1),
        0x0412 => Some(0xC2),
        0x0413 => Some(0xC3),
        0x0414 => Some(0xC4),
        0x0415 => Some(0xC5),
        0x0416 => Some(0xC6),
        0x0417 => Some(0xC7),
        0x0418 => Some(0xC8),
        0x0419 => Some(0xC9),
        0x041A => Some(0xCA),
        0x041B => Some(0xCB),
        0x041C => Some(0xCC),
        0x041D => Some(0xCD),
        0x041E => Some(0xCE),
        0x041F => Some(0xCF),
        0x0420 => Some(0xD0),
        0x0421 => Some(0xD1),
        0x0422 => Some(0xD2),
        0x0423 => Some(0xD3),
        0x0424 => Some(0xD4),
        0x0425 => Some(0xD5),
        0x0426 => Some(0xD6),
        0x0427 => Some(0xD7),
        0x0428 => Some(0xD8),
        0x0429 => Some(0xD9),
        0x042A => Some(0xDA),
        0x042B => Some(0xDB),
        0x042C => Some(0xDC),
        0x042D => Some(0xDD),
        0x042E => Some(0xDE),
        0x042F => Some(0xDF),
        0x0430 => Some(0xE0),
        0x0431 => Some(0xE1),
        0x0432 => Some(0xE2),
        0x0433 => Some(0xE3),
        0x0434 => Some(0xE4),
        0x0435 => Some(0xE5),
        0x0436 => Some(0xE6),
        0x0437 => Some(0xE7),
        0x0438 => Some(0xE8),
        0x0439 => Some(0xE9),
        0x043A => Some(0xEA),
        0x043B => Some(0xEB),
        0x043C => Some(0xEC),
        0x043D => Some(0xED),
        0x043E => Some(0xEE),
        0x043F => Some(0xEF),
        0x0440 => Some(0xF0),
        0x0441 => Some(0xF1),
        0x0442 => Some(0xF2),
        0x0443 => Some(0xF3),
        0x0444 => Some(0xF4),
        0x0445 => Some(0xF5),
        0x0446 => Some(0xF6),
        0x0447 => Some(0xF7),
        0x0448 => Some(0xF8),
        0x0449 => Some(0xF9),
        0x044A => Some(0xFA),
        0x044B => Some(0xFB),
        0x044C => Some(0xFC),
        0x044D => Some(0xFD),
        0x044E => Some(0xFE),
        0x044F => Some(0xFF),
        0x0451 => Some(0xB8),
        0x0452 => Some(0x90),
        0x0453 => Some(0x83),
        0x0454 => Some(0xBA),
        0x0455 => Some(0xBE),
        0x0456 => Some(0xB3),
        0x0457 => Some(0xBF),
        0x0458 => Some(0xBC),
        0x0459 => Some(0x9A),
        0x045A => Some(0x9C),
        0x045B => Some(0x9E),
        0x045C => Some(0x9D),
        0x045E => Some(0xA2),
        0x045F => Some(0x9F),
        0x0490 => Some(0xA5),
        0x0491 => Some(0xB4),
        0x2013 => Some(0x96),
        0x2014 => Some(0x97),
        0x2018 => Some(0x91),
        0x2019 => Some(0x92),
        0x201A => Some(0x82),
        0x201C => Some(0x93),
        0x201D => Some(0x94),
        0x201E => Some(0x84),
        0x2020 => Some(0x86),
        0x2021 => Some(0x87),
        0x2022 => Some(0x95),
        0x2026 => Some(0x85),
        0x2030 => Some(0x89),
        0x2039 => Some(0x8B),
        0x203A => Some(0x9B),
        0x20AC => Some(0x88),
        0x2116 => Some(0xB9),
        0x2122 => Some(0x99),
        _ => None,
    }
}

fn encode_cp866_byte(code: u32) -> Option<u8> {
    match code {
        0x00A0 => Some(0xFF),
        0x00A4 => Some(0xFD),
        0x00B0 => Some(0xF8),
        0x00B7 => Some(0xFA),
        0x0401 => Some(0xF0),
        0x0404 => Some(0xF2),
        0x0407 => Some(0xF4),
        0x040E => Some(0xF6),
        0x0410 => Some(0x80),
        0x0411 => Some(0x81),
        0x0412 => Some(0x82),
        0x0413 => Some(0x83),
        0x0414 => Some(0x84),
        0x0415 => Some(0x85),
        0x0416 => Some(0x86),
        0x0417 => Some(0x87),
        0x0418 => Some(0x88),
        0x0419 => Some(0x89),
        0x041A => Some(0x8A),
        0x041B => Some(0x8B),
        0x041C => Some(0x8C),
        0x041D => Some(0x8D),
        0x041E => Some(0x8E),
        0x041F => Some(0x8F),
        0x0420 => Some(0x90),
        0x0421 => Some(0x91),
        0x0422 => Some(0x92),
        0x0423 => Some(0x93),
        0x0424 => Some(0x94),
        0x0425 => Some(0x95),
        0x0426 => Some(0x96),
        0x0427 => Some(0x97),
        0x0428 => Some(0x98),
        0x0429 => Some(0x99),
        0x042A => Some(0x9A),
        0x042B => Some(0x9B),
        0x042C => Some(0x9C),
        0x042D => Some(0x9D),
        0x042E => Some(0x9E),
        0x042F => Some(0x9F),
        0x0430 => Some(0xA0),
        0x0431 => Some(0xA1),
        0x0432 => Some(0xA2),
        0x0433 => Some(0xA3),
        0x0434 => Some(0xA4),
        0x0435 => Some(0xA5),
        0x0436 => Some(0xA6),
        0x0437 => Some(0xA7),
        0x0438 => Some(0xA8),
        0x0439 => Some(0xA9),
        0x043A => Some(0xAA),
        0x043B => Some(0xAB),
        0x043C => Some(0xAC),
        0x043D => Some(0xAD),
        0x043E => Some(0xAE),
        0x043F => Some(0xAF),
        0x0440 => Some(0xE0),
        0x0441 => Some(0xE1),
        0x0442 => Some(0xE2),
        0x0443 => Some(0xE3),
        0x0444 => Some(0xE4),
        0x0445 => Some(0xE5),
        0x0446 => Some(0xE6),
        0x0447 => Some(0xE7),
        0x0448 => Some(0xE8),
        0x0449 => Some(0xE9),
        0x044A => Some(0xEA),
        0x044B => Some(0xEB),
        0x044C => Some(0xEC),
        0x044D => Some(0xED),
        0x044E => Some(0xEE),
        0x044F => Some(0xEF),
        0x0451 => Some(0xF1),
        0x0454 => Some(0xF3),
        0x0457 => Some(0xF5),
        0x045E => Some(0xF7),
        0x2116 => Some(0xFC),
        0x2219 => Some(0xF9),
        0x221A => Some(0xFB),
        0x2500 => Some(0xC4),
        0x2502 => Some(0xB3),
        0x250C => Some(0xDA),
        0x2510 => Some(0xBF),
        0x2514 => Some(0xC0),
        0x2518 => Some(0xD9),
        0x251C => Some(0xC3),
        0x2524 => Some(0xB4),
        0x252C => Some(0xC2),
        0x2534 => Some(0xC1),
        0x253C => Some(0xC5),
        0x2550 => Some(0xCD),
        0x2551 => Some(0xBA),
        0x2552 => Some(0xD5),
        0x2553 => Some(0xD6),
        0x2554 => Some(0xC9),
        0x2555 => Some(0xB8),
        0x2556 => Some(0xB7),
        0x2557 => Some(0xBB),
        0x2558 => Some(0xD4),
        0x2559 => Some(0xD3),
        0x255A => Some(0xC8),
        0x255B => Some(0xBE),
        0x255C => Some(0xBD),
        0x255D => Some(0xBC),
        0x255E => Some(0xC6),
        0x255F => Some(0xC7),
        0x2560 => Some(0xCC),
        0x2561 => Some(0xB5),
        0x2562 => Some(0xB6),
        0x2563 => Some(0xB9),
        0x2564 => Some(0xD1),
        0x2565 => Some(0xD2),
        0x2566 => Some(0xCB),
        0x2567 => Some(0xCF),
        0x2568 => Some(0xD0),
        0x2569 => Some(0xCA),
        0x256A => Some(0xD8),
        0x256B => Some(0xD7),
        0x256C => Some(0xCE),
        0x2580 => Some(0xDF),
        0x2584 => Some(0xDC),
        0x2588 => Some(0xDB),
        0x258C => Some(0xDD),
        0x2590 => Some(0xDE),
        0x2591 => Some(0xB0),
        0x2592 => Some(0xB1),
        0x2593 => Some(0xB2),
        0x25A0 => Some(0xFE),
        _ => None,
    }
}

fn encode_cp860_byte(code: u32) -> Option<u8> {
    match code {
        0x00A0 => Some(0xFF),
        0x00A1 => Some(0xAD),
        0x00A2 => Some(0x9B),
        0x00A3 => Some(0x9C),
        0x00AA => Some(0xA6),
        0x00AB => Some(0xAE),
        0x00AC => Some(0xAA),
        0x00B0 => Some(0xF8),
        0x00B1 => Some(0xF1),
        0x00B2 => Some(0xFD),
        0x00B5 => Some(0xE6),
        0x00B7 => Some(0xFA),
        0x00BA => Some(0xA7),
        0x00BB => Some(0xAF),
        0x00BC => Some(0xAC),
        0x00BD => Some(0xAB),
        0x00BF => Some(0xA8),
        0x00C0 => Some(0x91),
        0x00C1 => Some(0x86),
        0x00C2 => Some(0x8F),
        0x00C3 => Some(0x8E),
        0x00C7 => Some(0x80),
        0x00C8 => Some(0x92),
        0x00C9 => Some(0x90),
        0x00CA => Some(0x89),
        0x00CC => Some(0x98),
        0x00CD => Some(0x8B),
        0x00D1 => Some(0xA5),
        0x00D2 => Some(0xA9),
        0x00D3 => Some(0x9F),
        0x00D4 => Some(0x8C),
        0x00D5 => Some(0x99),
        0x00D9 => Some(0x9D),
        0x00DA => Some(0x96),
        0x00DC => Some(0x9A),
        0x00DF => Some(0xE1),
        0x00E0 => Some(0x85),
        0x00E1 => Some(0xA0),
        0x00E2 => Some(0x83),
        0x00E3 => Some(0x84),
        0x00E7 => Some(0x87),
        0x00E8 => Some(0x8A),
        0x00E9 => Some(0x82),
        0x00EA => Some(0x88),
        0x00EC => Some(0x8D),
        0x00ED => Some(0xA1),
        0x00F1 => Some(0xA4),
        0x00F2 => Some(0x95),
        0x00F3 => Some(0xA2),
        0x00F4 => Some(0x93),
        0x00F5 => Some(0x94),
        0x00F7 => Some(0xF6),
        0x00F9 => Some(0x97),
        0x00FA => Some(0xA3),
        0x00FC => Some(0x81),
        0x0393 => Some(0xE2),
        0x0398 => Some(0xE9),
        0x03A3 => Some(0xE4),
        0x03A6 => Some(0xE8),
        0x03A9 => Some(0xEA),
        0x03B1 => Some(0xE0),
        0x03B4 => Some(0xEB),
        0x03B5 => Some(0xEE),
        0x03C0 => Some(0xE3),
        0x03C3 => Some(0xE5),
        0x03C4 => Some(0xE7),
        0x03C6 => Some(0xED),
        0x207F => Some(0xFC),
        0x20A7 => Some(0x9E),
        0x2219 => Some(0xF9),
        0x221A => Some(0xFB),
        0x221E => Some(0xEC),
        0x2229 => Some(0xEF),
        0x2248 => Some(0xF7),
        0x2261 => Some(0xF0),
        0x2264 => Some(0xF3),
        0x2265 => Some(0xF2),
        0x2320 => Some(0xF4),
        0x2321 => Some(0xF5),
        0x2500 => Some(0xC4),
        0x2502 => Some(0xB3),
        0x250C => Some(0xDA),
        0x2510 => Some(0xBF),
        0x2514 => Some(0xC0),
        0x2518 => Some(0xD9),
        0x251C => Some(0xC3),
        0x2524 => Some(0xB4),
        0x252C => Some(0xC2),
        0x2534 => Some(0xC1),
        0x253C => Some(0xC5),
        0x2550 => Some(0xCD),
        0x2551 => Some(0xBA),
        0x2552 => Some(0xD5),
        0x2553 => Some(0xD6),
        0x2554 => Some(0xC9),
        0x2555 => Some(0xB8),
        0x2556 => Some(0xB7),
        0x2557 => Some(0xBB),
        0x2558 => Some(0xD4),
        0x2559 => Some(0xD3),
        0x255A => Some(0xC8),
        0x255B => Some(0xBE),
        0x255C => Some(0xBD),
        0x255D => Some(0xBC),
        0x255E => Some(0xC6),
        0x255F => Some(0xC7),
        0x2560 => Some(0xCC),
        0x2561 => Some(0xB5),
        0x2562 => Some(0xB6),
        0x2563 => Some(0xB9),
        0x2564 => Some(0xD1),
        0x2565 => Some(0xD2),
        0x2566 => Some(0xCB),
        0x2567 => Some(0xCF),
        0x2568 => Some(0xD0),
        0x2569 => Some(0xCA),
        0x256A => Some(0xD8),
        0x256B => Some(0xD7),
        0x256C => Some(0xCE),
        0x2580 => Some(0xDF),
        0x2584 => Some(0xDC),
        0x2588 => Some(0xDB),
        0x258C => Some(0xDD),
        0x2590 => Some(0xDE),
        0x2591 => Some(0xB0),
        0x2592 => Some(0xB1),
        0x2593 => Some(0xB2),
        0x25A0 => Some(0xFE),
        _ => None,
    }
}
fn encode_cp862_byte(code: u32) -> Option<u8> {
    match code {
        0x00A0 => Some(0xFF),
        0x00A1 => Some(0xAD),
        0x00A2 => Some(0x9B),
        0x00A3 => Some(0x9C),
        0x00A5 => Some(0x9D),
        0x00AA => Some(0xA6),
        0x00AB => Some(0xAE),
        0x00AC => Some(0xAA),
        0x00B0 => Some(0xF8),
        0x00B1 => Some(0xF1),
        0x00B2 => Some(0xFD),
        0x00B5 => Some(0xE6),
        0x00B7 => Some(0xFA),
        0x00BA => Some(0xA7),
        0x00BB => Some(0xAF),
        0x00BC => Some(0xAC),
        0x00BD => Some(0xAB),
        0x00BF => Some(0xA8),
        0x00D1 => Some(0xA5),
        0x00DF => Some(0xE1),
        0x00E1 => Some(0xA0),
        0x00ED => Some(0xA1),
        0x00F1 => Some(0xA4),
        0x00F3 => Some(0xA2),
        0x00F7 => Some(0xF6),
        0x00FA => Some(0xA3),
        0x0192 => Some(0x9F),
        0x0393 => Some(0xE2),
        0x0398 => Some(0xE9),
        0x03A3 => Some(0xE4),
        0x03A6 => Some(0xE8),
        0x03A9 => Some(0xEA),
        0x03B1 => Some(0xE0),
        0x03B4 => Some(0xEB),
        0x03B5 => Some(0xEE),
        0x03C0 => Some(0xE3),
        0x03C3 => Some(0xE5),
        0x03C4 => Some(0xE7),
        0x03C6 => Some(0xED),
        0x05D0 => Some(0x80),
        0x05D1 => Some(0x81),
        0x05D2 => Some(0x82),
        0x05D3 => Some(0x83),
        0x05D4 => Some(0x84),
        0x05D5 => Some(0x85),
        0x05D6 => Some(0x86),
        0x05D7 => Some(0x87),
        0x05D8 => Some(0x88),
        0x05D9 => Some(0x89),
        0x05DA => Some(0x8A),
        0x05DB => Some(0x8B),
        0x05DC => Some(0x8C),
        0x05DD => Some(0x8D),
        0x05DE => Some(0x8E),
        0x05DF => Some(0x8F),
        0x05E0 => Some(0x90),
        0x05E1 => Some(0x91),
        0x05E2 => Some(0x92),
        0x05E3 => Some(0x93),
        0x05E4 => Some(0x94),
        0x05E5 => Some(0x95),
        0x05E6 => Some(0x96),
        0x05E7 => Some(0x97),
        0x05E8 => Some(0x98),
        0x05E9 => Some(0x99),
        0x05EA => Some(0x9A),
        0x207F => Some(0xFC),
        0x20A7 => Some(0x9E),
        0x2219 => Some(0xF9),
        0x221A => Some(0xFB),
        0x221E => Some(0xEC),
        0x2229 => Some(0xEF),
        0x2248 => Some(0xF7),
        0x2261 => Some(0xF0),
        0x2264 => Some(0xF3),
        0x2265 => Some(0xF2),
        0x2310 => Some(0xA9),
        0x2320 => Some(0xF4),
        0x2321 => Some(0xF5),
        0x2500 => Some(0xC4),
        0x2502 => Some(0xB3),
        0x250C => Some(0xDA),
        0x2510 => Some(0xBF),
        0x2514 => Some(0xC0),
        0x2518 => Some(0xD9),
        0x251C => Some(0xC3),
        0x2524 => Some(0xB4),
        0x252C => Some(0xC2),
        0x2534 => Some(0xC1),
        0x253C => Some(0xC5),
        0x2550 => Some(0xCD),
        0x2551 => Some(0xBA),
        0x2552 => Some(0xD5),
        0x2553 => Some(0xD6),
        0x2554 => Some(0xC9),
        0x2555 => Some(0xB8),
        0x2556 => Some(0xB7),
        0x2557 => Some(0xBB),
        0x2558 => Some(0xD4),
        0x2559 => Some(0xD3),
        0x255A => Some(0xC8),
        0x255B => Some(0xBE),
        0x255C => Some(0xBD),
        0x255D => Some(0xBC),
        0x255E => Some(0xC6),
        0x255F => Some(0xC7),
        0x2560 => Some(0xCC),
        0x2561 => Some(0xB5),
        0x2562 => Some(0xB6),
        0x2563 => Some(0xB9),
        0x2564 => Some(0xD1),
        0x2565 => Some(0xD2),
        0x2566 => Some(0xCB),
        0x2567 => Some(0xCF),
        0x2568 => Some(0xD0),
        0x2569 => Some(0xCA),
        0x256A => Some(0xD8),
        0x256B => Some(0xD7),
        0x256C => Some(0xCE),
        0x2580 => Some(0xDF),
        0x2584 => Some(0xDC),
        0x2588 => Some(0xDB),
        0x258C => Some(0xDD),
        0x2590 => Some(0xDE),
        0x2591 => Some(0xB0),
        0x2592 => Some(0xB1),
        0x2593 => Some(0xB2),
        0x25A0 => Some(0xFE),
        _ => None,
    }
}
fn encode_cp863_byte(code: u32) -> Option<u8> {
    match code {
        0x00A0 => Some(0xFF),
        0x00A2 => Some(0x9B),
        0x00A3 => Some(0x9C),
        0x00A4 => Some(0x98),
        0x00A6 => Some(0xA0),
        0x00A7 => Some(0x8F),
        0x00A8 => Some(0xA4),
        0x00AB => Some(0xAE),
        0x00AC => Some(0xAA),
        0x00AF => Some(0xA7),
        0x00B0 => Some(0xF8),
        0x00B1 => Some(0xF1),
        0x00B2 => Some(0xFD),
        0x00B3 => Some(0xA6),
        0x00B4 => Some(0xA1),
        0x00B5 => Some(0xE6),
        0x00B6 => Some(0x86),
        0x00B7 => Some(0xFA),
        0x00B8 => Some(0xA5),
        0x00BB => Some(0xAF),
        0x00BC => Some(0xAC),
        0x00BD => Some(0xAB),
        0x00BE => Some(0xAD),
        0x00C0 => Some(0x8E),
        0x00C2 => Some(0x84),
        0x00C7 => Some(0x80),
        0x00C8 => Some(0x91),
        0x00C9 => Some(0x90),
        0x00CA => Some(0x92),
        0x00CB => Some(0x94),
        0x00CE => Some(0xA8),
        0x00CF => Some(0x95),
        0x00D4 => Some(0x99),
        0x00D9 => Some(0x9D),
        0x00DB => Some(0x9E),
        0x00DC => Some(0x9A),
        0x00DF => Some(0xE1),
        0x00E0 => Some(0x85),
        0x00E2 => Some(0x83),
        0x00E7 => Some(0x87),
        0x00E8 => Some(0x8A),
        0x00E9 => Some(0x82),
        0x00EA => Some(0x88),
        0x00EB => Some(0x89),
        0x00EE => Some(0x8C),
        0x00EF => Some(0x8B),
        0x00F3 => Some(0xA2),
        0x00F4 => Some(0x93),
        0x00F7 => Some(0xF6),
        0x00F9 => Some(0x97),
        0x00FA => Some(0xA3),
        0x00FB => Some(0x96),
        0x00FC => Some(0x81),
        0x0192 => Some(0x9F),
        0x0393 => Some(0xE2),
        0x0398 => Some(0xE9),
        0x03A3 => Some(0xE4),
        0x03A6 => Some(0xE8),
        0x03A9 => Some(0xEA),
        0x03B1 => Some(0xE0),
        0x03B4 => Some(0xEB),
        0x03B5 => Some(0xEE),
        0x03C0 => Some(0xE3),
        0x03C3 => Some(0xE5),
        0x03C4 => Some(0xE7),
        0x03C6 => Some(0xED),
        0x2017 => Some(0x8D),
        0x207F => Some(0xFC),
        0x2219 => Some(0xF9),
        0x221A => Some(0xFB),
        0x221E => Some(0xEC),
        0x2229 => Some(0xEF),
        0x2248 => Some(0xF7),
        0x2261 => Some(0xF0),
        0x2264 => Some(0xF3),
        0x2265 => Some(0xF2),
        0x2310 => Some(0xA9),
        0x2320 => Some(0xF4),
        0x2321 => Some(0xF5),
        0x2500 => Some(0xC4),
        0x2502 => Some(0xB3),
        0x250C => Some(0xDA),
        0x2510 => Some(0xBF),
        0x2514 => Some(0xC0),
        0x2518 => Some(0xD9),
        0x251C => Some(0xC3),
        0x2524 => Some(0xB4),
        0x252C => Some(0xC2),
        0x2534 => Some(0xC1),
        0x253C => Some(0xC5),
        0x2550 => Some(0xCD),
        0x2551 => Some(0xBA),
        0x2552 => Some(0xD5),
        0x2553 => Some(0xD6),
        0x2554 => Some(0xC9),
        0x2555 => Some(0xB8),
        0x2556 => Some(0xB7),
        0x2557 => Some(0xBB),
        0x2558 => Some(0xD4),
        0x2559 => Some(0xD3),
        0x255A => Some(0xC8),
        0x255B => Some(0xBE),
        0x255C => Some(0xBD),
        0x255D => Some(0xBC),
        0x255E => Some(0xC6),
        0x255F => Some(0xC7),
        0x2560 => Some(0xCC),
        0x2561 => Some(0xB5),
        0x2562 => Some(0xB6),
        0x2563 => Some(0xB9),
        0x2564 => Some(0xD1),
        0x2565 => Some(0xD2),
        0x2566 => Some(0xCB),
        0x2567 => Some(0xCF),
        0x2568 => Some(0xD0),
        0x2569 => Some(0xCA),
        0x256A => Some(0xD8),
        0x256B => Some(0xD7),
        0x256C => Some(0xCE),
        0x2580 => Some(0xDF),
        0x2584 => Some(0xDC),
        0x2588 => Some(0xDB),
        0x258C => Some(0xDD),
        0x2590 => Some(0xDE),
        0x2591 => Some(0xB0),
        0x2592 => Some(0xB1),
        0x2593 => Some(0xB2),
        0x25A0 => Some(0xFE),
        _ => None,
    }
}
fn encode_cp1253_byte(code: u32) -> Option<u8> {
    match code {
        0x00A0 => Some(0xA0),
        0x00A3 => Some(0xA3),
        0x00A4 => Some(0xA4),
        0x00A5 => Some(0xA5),
        0x00A6 => Some(0xA6),
        0x00A7 => Some(0xA7),
        0x00A8 => Some(0xA8),
        0x00A9 => Some(0xA9),
        0x00AB => Some(0xAB),
        0x00AC => Some(0xAC),
        0x00AD => Some(0xAD),
        0x00AE => Some(0xAE),
        0x00B0 => Some(0xB0),
        0x00B1 => Some(0xB1),
        0x00B2 => Some(0xB2),
        0x00B3 => Some(0xB3),
        0x00B5 => Some(0xB5),
        0x00B6 => Some(0xB6),
        0x00B7 => Some(0xB7),
        0x00BB => Some(0xBB),
        0x00BD => Some(0xBD),
        0x0192 => Some(0x83),
        0x0384 => Some(0xB4),
        0x0385 => Some(0xA1),
        0x0386 => Some(0xA2),
        0x0388 => Some(0xB8),
        0x0389 => Some(0xB9),
        0x038A => Some(0xBA),
        0x038C => Some(0xBC),
        0x038E => Some(0xBE),
        0x038F => Some(0xBF),
        0x0390 => Some(0xC0),
        0x0391 => Some(0xC1),
        0x0392 => Some(0xC2),
        0x0393 => Some(0xC3),
        0x0394 => Some(0xC4),
        0x0395 => Some(0xC5),
        0x0396 => Some(0xC6),
        0x0397 => Some(0xC7),
        0x0398 => Some(0xC8),
        0x0399 => Some(0xC9),
        0x039A => Some(0xCA),
        0x039B => Some(0xCB),
        0x039C => Some(0xCC),
        0x039D => Some(0xCD),
        0x039E => Some(0xCE),
        0x039F => Some(0xCF),
        0x03A0 => Some(0xD0),
        0x03A1 => Some(0xD1),
        0x03A3 => Some(0xD3),
        0x03A4 => Some(0xD4),
        0x03A5 => Some(0xD5),
        0x03A6 => Some(0xD6),
        0x03A7 => Some(0xD7),
        0x03A8 => Some(0xD8),
        0x03A9 => Some(0xD9),
        0x03AA => Some(0xDA),
        0x03AB => Some(0xDB),
        0x03AC => Some(0xDC),
        0x03AD => Some(0xDD),
        0x03AE => Some(0xDE),
        0x03AF => Some(0xDF),
        0x03B0 => Some(0xE0),
        0x03B1 => Some(0xE1),
        0x03B2 => Some(0xE2),
        0x03B3 => Some(0xE3),
        0x03B4 => Some(0xE4),
        0x03B5 => Some(0xE5),
        0x03B6 => Some(0xE6),
        0x03B7 => Some(0xE7),
        0x03B8 => Some(0xE8),
        0x03B9 => Some(0xE9),
        0x03BA => Some(0xEA),
        0x03BB => Some(0xEB),
        0x03BC => Some(0xEC),
        0x03BD => Some(0xED),
        0x03BE => Some(0xEE),
        0x03BF => Some(0xEF),
        0x03C0 => Some(0xF0),
        0x03C1 => Some(0xF1),
        0x03C2 => Some(0xF2),
        0x03C3 => Some(0xF3),
        0x03C4 => Some(0xF4),
        0x03C5 => Some(0xF5),
        0x03C6 => Some(0xF6),
        0x03C7 => Some(0xF7),
        0x03C8 => Some(0xF8),
        0x03C9 => Some(0xF9),
        0x03CA => Some(0xFA),
        0x03CB => Some(0xFB),
        0x03CC => Some(0xFC),
        0x03CD => Some(0xFD),
        0x03CE => Some(0xFE),
        0x2013 => Some(0x96),
        0x2014 => Some(0x97),
        0x2015 => Some(0xAF),
        0x2018 => Some(0x91),
        0x2019 => Some(0x92),
        0x201A => Some(0x82),
        0x201C => Some(0x93),
        0x201D => Some(0x94),
        0x201E => Some(0x84),
        0x2020 => Some(0x86),
        0x2021 => Some(0x87),
        0x2022 => Some(0x95),
        0x2026 => Some(0x85),
        0x2030 => Some(0x89),
        0x2039 => Some(0x8B),
        0x203A => Some(0x9B),
        0x20AC => Some(0x80),
        0x2122 => Some(0x99),
        _ => None,
    }
}
fn encode_cp1254_byte(code: u32) -> Option<u8> {
    match code {
        0x00A0 => Some(0xA0),
        0x00A1 => Some(0xA1),
        0x00A2 => Some(0xA2),
        0x00A3 => Some(0xA3),
        0x00A4 => Some(0xA4),
        0x00A5 => Some(0xA5),
        0x00A6 => Some(0xA6),
        0x00A7 => Some(0xA7),
        0x00A8 => Some(0xA8),
        0x00A9 => Some(0xA9),
        0x00AA => Some(0xAA),
        0x00AB => Some(0xAB),
        0x00AC => Some(0xAC),
        0x00AD => Some(0xAD),
        0x00AE => Some(0xAE),
        0x00AF => Some(0xAF),
        0x00B0 => Some(0xB0),
        0x00B1 => Some(0xB1),
        0x00B2 => Some(0xB2),
        0x00B3 => Some(0xB3),
        0x00B4 => Some(0xB4),
        0x00B5 => Some(0xB5),
        0x00B6 => Some(0xB6),
        0x00B7 => Some(0xB7),
        0x00B8 => Some(0xB8),
        0x00B9 => Some(0xB9),
        0x00BA => Some(0xBA),
        0x00BB => Some(0xBB),
        0x00BC => Some(0xBC),
        0x00BD => Some(0xBD),
        0x00BE => Some(0xBE),
        0x00BF => Some(0xBF),
        0x00C0 => Some(0xC0),
        0x00C1 => Some(0xC1),
        0x00C2 => Some(0xC2),
        0x00C3 => Some(0xC3),
        0x00C4 => Some(0xC4),
        0x00C5 => Some(0xC5),
        0x00C6 => Some(0xC6),
        0x00C7 => Some(0xC7),
        0x00C8 => Some(0xC8),
        0x00C9 => Some(0xC9),
        0x00CA => Some(0xCA),
        0x00CB => Some(0xCB),
        0x00CC => Some(0xCC),
        0x00CD => Some(0xCD),
        0x00CE => Some(0xCE),
        0x00CF => Some(0xCF),
        0x00D1 => Some(0xD1),
        0x00D2 => Some(0xD2),
        0x00D3 => Some(0xD3),
        0x00D4 => Some(0xD4),
        0x00D5 => Some(0xD5),
        0x00D6 => Some(0xD6),
        0x00D7 => Some(0xD7),
        0x00D8 => Some(0xD8),
        0x00D9 => Some(0xD9),
        0x00DA => Some(0xDA),
        0x00DB => Some(0xDB),
        0x00DC => Some(0xDC),
        0x00DF => Some(0xDF),
        0x00E0 => Some(0xE0),
        0x00E1 => Some(0xE1),
        0x00E2 => Some(0xE2),
        0x00E3 => Some(0xE3),
        0x00E4 => Some(0xE4),
        0x00E5 => Some(0xE5),
        0x00E6 => Some(0xE6),
        0x00E7 => Some(0xE7),
        0x00E8 => Some(0xE8),
        0x00E9 => Some(0xE9),
        0x00EA => Some(0xEA),
        0x00EB => Some(0xEB),
        0x00EC => Some(0xEC),
        0x00ED => Some(0xED),
        0x00EE => Some(0xEE),
        0x00EF => Some(0xEF),
        0x00F1 => Some(0xF1),
        0x00F2 => Some(0xF2),
        0x00F3 => Some(0xF3),
        0x00F4 => Some(0xF4),
        0x00F5 => Some(0xF5),
        0x00F6 => Some(0xF6),
        0x00F7 => Some(0xF7),
        0x00F8 => Some(0xF8),
        0x00F9 => Some(0xF9),
        0x00FA => Some(0xFA),
        0x00FB => Some(0xFB),
        0x00FC => Some(0xFC),
        0x00FF => Some(0xFF),
        0x011E => Some(0xD0),
        0x011F => Some(0xF0),
        0x0130 => Some(0xDD),
        0x0131 => Some(0xFD),
        0x0152 => Some(0x8C),
        0x0153 => Some(0x9C),
        0x015E => Some(0xDE),
        0x015F => Some(0xFE),
        0x0160 => Some(0x8A),
        0x0161 => Some(0x9A),
        0x0178 => Some(0x9F),
        0x0192 => Some(0x83),
        0x02C6 => Some(0x88),
        0x02DC => Some(0x98),
        0x2013 => Some(0x96),
        0x2014 => Some(0x97),
        0x2018 => Some(0x91),
        0x2019 => Some(0x92),
        0x201A => Some(0x82),
        0x201C => Some(0x93),
        0x201D => Some(0x94),
        0x201E => Some(0x84),
        0x2020 => Some(0x86),
        0x2021 => Some(0x87),
        0x2022 => Some(0x95),
        0x2026 => Some(0x85),
        0x2030 => Some(0x89),
        0x2039 => Some(0x8B),
        0x203A => Some(0x9B),
        0x20AC => Some(0x80),
        0x2122 => Some(0x99),
        _ => None,
    }
}
fn encode_cp1255_byte(code: u32) -> Option<u8> {
    match code {
        0x00A0 => Some(0xA0),
        0x00A1 => Some(0xA1),
        0x00A2 => Some(0xA2),
        0x00A3 => Some(0xA3),
        0x00A5 => Some(0xA5),
        0x00A6 => Some(0xA6),
        0x00A7 => Some(0xA7),
        0x00A8 => Some(0xA8),
        0x00A9 => Some(0xA9),
        0x00AB => Some(0xAB),
        0x00AC => Some(0xAC),
        0x00AD => Some(0xAD),
        0x00AE => Some(0xAE),
        0x00AF => Some(0xAF),
        0x00B0 => Some(0xB0),
        0x00B1 => Some(0xB1),
        0x00B2 => Some(0xB2),
        0x00B3 => Some(0xB3),
        0x00B4 => Some(0xB4),
        0x00B5 => Some(0xB5),
        0x00B6 => Some(0xB6),
        0x00B7 => Some(0xB7),
        0x00B8 => Some(0xB8),
        0x00B9 => Some(0xB9),
        0x00BB => Some(0xBB),
        0x00BC => Some(0xBC),
        0x00BD => Some(0xBD),
        0x00BE => Some(0xBE),
        0x00BF => Some(0xBF),
        0x00D7 => Some(0xAA),
        0x00F7 => Some(0xBA),
        0x0192 => Some(0x83),
        0x02C6 => Some(0x88),
        0x02DC => Some(0x98),
        0x05B0 => Some(0xC0),
        0x05B1 => Some(0xC1),
        0x05B2 => Some(0xC2),
        0x05B3 => Some(0xC3),
        0x05B4 => Some(0xC4),
        0x05B5 => Some(0xC5),
        0x05B6 => Some(0xC6),
        0x05B7 => Some(0xC7),
        0x05B8 => Some(0xC8),
        0x05B9 => Some(0xC9),
        0x05BB => Some(0xCB),
        0x05BC => Some(0xCC),
        0x05BD => Some(0xCD),
        0x05BE => Some(0xCE),
        0x05BF => Some(0xCF),
        0x05C0 => Some(0xD0),
        0x05C1 => Some(0xD1),
        0x05C2 => Some(0xD2),
        0x05C3 => Some(0xD3),
        0x05D0 => Some(0xE0),
        0x05D1 => Some(0xE1),
        0x05D2 => Some(0xE2),
        0x05D3 => Some(0xE3),
        0x05D4 => Some(0xE4),
        0x05D5 => Some(0xE5),
        0x05D6 => Some(0xE6),
        0x05D7 => Some(0xE7),
        0x05D8 => Some(0xE8),
        0x05D9 => Some(0xE9),
        0x05DA => Some(0xEA),
        0x05DB => Some(0xEB),
        0x05DC => Some(0xEC),
        0x05DD => Some(0xED),
        0x05DE => Some(0xEE),
        0x05DF => Some(0xEF),
        0x05E0 => Some(0xF0),
        0x05E1 => Some(0xF1),
        0x05E2 => Some(0xF2),
        0x05E3 => Some(0xF3),
        0x05E4 => Some(0xF4),
        0x05E5 => Some(0xF5),
        0x05E6 => Some(0xF6),
        0x05E7 => Some(0xF7),
        0x05E8 => Some(0xF8),
        0x05E9 => Some(0xF9),
        0x05EA => Some(0xFA),
        0x05F0 => Some(0xD4),
        0x05F1 => Some(0xD5),
        0x05F2 => Some(0xD6),
        0x05F3 => Some(0xD7),
        0x05F4 => Some(0xD8),
        0x200E => Some(0xFD),
        0x200F => Some(0xFE),
        0x2013 => Some(0x96),
        0x2014 => Some(0x97),
        0x2018 => Some(0x91),
        0x2019 => Some(0x92),
        0x201A => Some(0x82),
        0x201C => Some(0x93),
        0x201D => Some(0x94),
        0x201E => Some(0x84),
        0x2020 => Some(0x86),
        0x2021 => Some(0x87),
        0x2022 => Some(0x95),
        0x2026 => Some(0x85),
        0x2030 => Some(0x89),
        0x2039 => Some(0x8B),
        0x203A => Some(0x9B),
        0x20AA => Some(0xA4),
        0x20AC => Some(0x80),
        0x2122 => Some(0x99),
        _ => None,
    }
}
fn encode_cp1256_byte(code: u32) -> Option<u8> {
    match code {
        0x00A0 => Some(0xA0),
        0x00A2 => Some(0xA2),
        0x00A3 => Some(0xA3),
        0x00A4 => Some(0xA4),
        0x00A5 => Some(0xA5),
        0x00A6 => Some(0xA6),
        0x00A7 => Some(0xA7),
        0x00A8 => Some(0xA8),
        0x00A9 => Some(0xA9),
        0x00AB => Some(0xAB),
        0x00AC => Some(0xAC),
        0x00AD => Some(0xAD),
        0x00AE => Some(0xAE),
        0x00AF => Some(0xAF),
        0x00B0 => Some(0xB0),
        0x00B1 => Some(0xB1),
        0x00B2 => Some(0xB2),
        0x00B3 => Some(0xB3),
        0x00B4 => Some(0xB4),
        0x00B5 => Some(0xB5),
        0x00B6 => Some(0xB6),
        0x00B7 => Some(0xB7),
        0x00B8 => Some(0xB8),
        0x00B9 => Some(0xB9),
        0x00BB => Some(0xBB),
        0x00BC => Some(0xBC),
        0x00BD => Some(0xBD),
        0x00BE => Some(0xBE),
        0x00D7 => Some(0xD7),
        0x00E0 => Some(0xE0),
        0x00E2 => Some(0xE2),
        0x00E7 => Some(0xE7),
        0x00E8 => Some(0xE8),
        0x00E9 => Some(0xE9),
        0x00EA => Some(0xEA),
        0x00EB => Some(0xEB),
        0x00EE => Some(0xEE),
        0x00EF => Some(0xEF),
        0x00F4 => Some(0xF4),
        0x00F7 => Some(0xF7),
        0x00F9 => Some(0xF9),
        0x00FB => Some(0xFB),
        0x00FC => Some(0xFC),
        0x0152 => Some(0x8C),
        0x0153 => Some(0x9C),
        0x0192 => Some(0x83),
        0x02C6 => Some(0x88),
        0x060C => Some(0xA1),
        0x061B => Some(0xBA),
        0x061F => Some(0xBF),
        0x0621 => Some(0xC1),
        0x0622 => Some(0xC2),
        0x0623 => Some(0xC3),
        0x0624 => Some(0xC4),
        0x0625 => Some(0xC5),
        0x0626 => Some(0xC6),
        0x0627 => Some(0xC7),
        0x0628 => Some(0xC8),
        0x0629 => Some(0xC9),
        0x062A => Some(0xCA),
        0x062B => Some(0xCB),
        0x062C => Some(0xCC),
        0x062D => Some(0xCD),
        0x062E => Some(0xCE),
        0x062F => Some(0xCF),
        0x0630 => Some(0xD0),
        0x0631 => Some(0xD1),
        0x0632 => Some(0xD2),
        0x0633 => Some(0xD3),
        0x0634 => Some(0xD4),
        0x0635 => Some(0xD5),
        0x0636 => Some(0xD6),
        0x0637 => Some(0xD8),
        0x0638 => Some(0xD9),
        0x0639 => Some(0xDA),
        0x063A => Some(0xDB),
        0x0640 => Some(0xDC),
        0x0641 => Some(0xDD),
        0x0642 => Some(0xDE),
        0x0643 => Some(0xDF),
        0x0644 => Some(0xE1),
        0x0645 => Some(0xE3),
        0x0646 => Some(0xE4),
        0x0647 => Some(0xE5),
        0x0648 => Some(0xE6),
        0x0649 => Some(0xEC),
        0x064A => Some(0xED),
        0x064B => Some(0xF0),
        0x064C => Some(0xF1),
        0x064D => Some(0xF2),
        0x064E => Some(0xF3),
        0x064F => Some(0xF5),
        0x0650 => Some(0xF6),
        0x0651 => Some(0xF8),
        0x0652 => Some(0xFA),
        0x0679 => Some(0x8A),
        0x067E => Some(0x81),
        0x0686 => Some(0x8D),
        0x0688 => Some(0x8F),
        0x0691 => Some(0x9A),
        0x0698 => Some(0x8E),
        0x06A9 => Some(0x98),
        0x06AF => Some(0x90),
        0x06BA => Some(0x9F),
        0x06BE => Some(0xAA),
        0x06C1 => Some(0xC0),
        0x06D2 => Some(0xFF),
        0x200C => Some(0x9D),
        0x200D => Some(0x9E),
        0x200E => Some(0xFD),
        0x200F => Some(0xFE),
        0x2013 => Some(0x96),
        0x2014 => Some(0x97),
        0x2018 => Some(0x91),
        0x2019 => Some(0x92),
        0x201A => Some(0x82),
        0x201C => Some(0x93),
        0x201D => Some(0x94),
        0x201E => Some(0x84),
        0x2020 => Some(0x86),
        0x2021 => Some(0x87),
        0x2022 => Some(0x95),
        0x2026 => Some(0x85),
        0x2030 => Some(0x89),
        0x2039 => Some(0x8B),
        0x203A => Some(0x9B),
        0x20AC => Some(0x80),
        0x2122 => Some(0x99),
        _ => None,
    }
}
fn encode_cp1257_byte(code: u32) -> Option<u8> {
    match code {
        0x00A0 => Some(0xA0),
        0x00A2 => Some(0xA2),
        0x00A3 => Some(0xA3),
        0x00A4 => Some(0xA4),
        0x00A6 => Some(0xA6),
        0x00A7 => Some(0xA7),
        0x00A8 => Some(0x8D),
        0x00A9 => Some(0xA9),
        0x00AB => Some(0xAB),
        0x00AC => Some(0xAC),
        0x00AD => Some(0xAD),
        0x00AE => Some(0xAE),
        0x00AF => Some(0x9D),
        0x00B0 => Some(0xB0),
        0x00B1 => Some(0xB1),
        0x00B2 => Some(0xB2),
        0x00B3 => Some(0xB3),
        0x00B4 => Some(0xB4),
        0x00B5 => Some(0xB5),
        0x00B6 => Some(0xB6),
        0x00B7 => Some(0xB7),
        0x00B8 => Some(0x8F),
        0x00B9 => Some(0xB9),
        0x00BB => Some(0xBB),
        0x00BC => Some(0xBC),
        0x00BD => Some(0xBD),
        0x00BE => Some(0xBE),
        0x00C4 => Some(0xC4),
        0x00C5 => Some(0xC5),
        0x00C6 => Some(0xAF),
        0x00C9 => Some(0xC9),
        0x00D3 => Some(0xD3),
        0x00D5 => Some(0xD5),
        0x00D6 => Some(0xD6),
        0x00D7 => Some(0xD7),
        0x00D8 => Some(0xA8),
        0x00DC => Some(0xDC),
        0x00DF => Some(0xDF),
        0x00E4 => Some(0xE4),
        0x00E5 => Some(0xE5),
        0x00E6 => Some(0xBF),
        0x00E9 => Some(0xE9),
        0x00F3 => Some(0xF3),
        0x00F5 => Some(0xF5),
        0x00F6 => Some(0xF6),
        0x00F7 => Some(0xF7),
        0x00F8 => Some(0xB8),
        0x00FC => Some(0xFC),
        0x0100 => Some(0xC2),
        0x0101 => Some(0xE2),
        0x0104 => Some(0xC0),
        0x0105 => Some(0xE0),
        0x0106 => Some(0xC3),
        0x0107 => Some(0xE3),
        0x010C => Some(0xC8),
        0x010D => Some(0xE8),
        0x0112 => Some(0xC7),
        0x0113 => Some(0xE7),
        0x0116 => Some(0xCB),
        0x0117 => Some(0xEB),
        0x0118 => Some(0xC6),
        0x0119 => Some(0xE6),
        0x0122 => Some(0xCC),
        0x0123 => Some(0xEC),
        0x012A => Some(0xCE),
        0x012B => Some(0xEE),
        0x012E => Some(0xC1),
        0x012F => Some(0xE1),
        0x0136 => Some(0xCD),
        0x0137 => Some(0xED),
        0x013B => Some(0xCF),
        0x013C => Some(0xEF),
        0x0141 => Some(0xD9),
        0x0142 => Some(0xF9),
        0x0143 => Some(0xD1),
        0x0144 => Some(0xF1),
        0x0145 => Some(0xD2),
        0x0146 => Some(0xF2),
        0x014C => Some(0xD4),
        0x014D => Some(0xF4),
        0x0156 => Some(0xAA),
        0x0157 => Some(0xBA),
        0x015A => Some(0xDA),
        0x015B => Some(0xFA),
        0x0160 => Some(0xD0),
        0x0161 => Some(0xF0),
        0x016A => Some(0xDB),
        0x016B => Some(0xFB),
        0x0172 => Some(0xD8),
        0x0173 => Some(0xF8),
        0x0179 => Some(0xCA),
        0x017A => Some(0xEA),
        0x017B => Some(0xDD),
        0x017C => Some(0xFD),
        0x017D => Some(0xDE),
        0x017E => Some(0xFE),
        0x02C7 => Some(0x8E),
        0x02D9 => Some(0xFF),
        0x02DB => Some(0x9E),
        0x2013 => Some(0x96),
        0x2014 => Some(0x97),
        0x2018 => Some(0x91),
        0x2019 => Some(0x92),
        0x201A => Some(0x82),
        0x201C => Some(0x93),
        0x201D => Some(0x94),
        0x201E => Some(0x84),
        0x2020 => Some(0x86),
        0x2021 => Some(0x87),
        0x2022 => Some(0x95),
        0x2026 => Some(0x85),
        0x2030 => Some(0x89),
        0x2039 => Some(0x8B),
        0x203A => Some(0x9B),
        0x20AC => Some(0x80),
        0x2122 => Some(0x99),
        _ => None,
    }
}
fn encode_koi8_r_byte(code: u32) -> Option<u8> {
    match code {
        0x00A0 => Some(0x9A),
        0x00A9 => Some(0xBF),
        0x00B0 => Some(0x9C),
        0x00B2 => Some(0x9D),
        0x00B7 => Some(0x9E),
        0x00F7 => Some(0x9F),
        0x0401 => Some(0xB3),
        0x0410 => Some(0xE1),
        0x0411 => Some(0xE2),
        0x0412 => Some(0xF7),
        0x0413 => Some(0xE7),
        0x0414 => Some(0xE4),
        0x0415 => Some(0xE5),
        0x0416 => Some(0xF6),
        0x0417 => Some(0xFA),
        0x0418 => Some(0xE9),
        0x0419 => Some(0xEA),
        0x041A => Some(0xEB),
        0x041B => Some(0xEC),
        0x041C => Some(0xED),
        0x041D => Some(0xEE),
        0x041E => Some(0xEF),
        0x041F => Some(0xF0),
        0x0420 => Some(0xF2),
        0x0421 => Some(0xF3),
        0x0422 => Some(0xF4),
        0x0423 => Some(0xF5),
        0x0424 => Some(0xE6),
        0x0425 => Some(0xE8),
        0x0426 => Some(0xE3),
        0x0427 => Some(0xFE),
        0x0428 => Some(0xFB),
        0x0429 => Some(0xFD),
        0x042A => Some(0xFF),
        0x042B => Some(0xF9),
        0x042C => Some(0xF8),
        0x042D => Some(0xFC),
        0x042E => Some(0xE0),
        0x042F => Some(0xF1),
        0x0430 => Some(0xC1),
        0x0431 => Some(0xC2),
        0x0432 => Some(0xD7),
        0x0433 => Some(0xC7),
        0x0434 => Some(0xC4),
        0x0435 => Some(0xC5),
        0x0436 => Some(0xD6),
        0x0437 => Some(0xDA),
        0x0438 => Some(0xC9),
        0x0439 => Some(0xCA),
        0x043A => Some(0xCB),
        0x043B => Some(0xCC),
        0x043C => Some(0xCD),
        0x043D => Some(0xCE),
        0x043E => Some(0xCF),
        0x043F => Some(0xD0),
        0x0440 => Some(0xD2),
        0x0441 => Some(0xD3),
        0x0442 => Some(0xD4),
        0x0443 => Some(0xD5),
        0x0444 => Some(0xC6),
        0x0445 => Some(0xC8),
        0x0446 => Some(0xC3),
        0x0447 => Some(0xDE),
        0x0448 => Some(0xDB),
        0x0449 => Some(0xDD),
        0x044A => Some(0xDF),
        0x044B => Some(0xD9),
        0x044C => Some(0xD8),
        0x044D => Some(0xDC),
        0x044E => Some(0xC0),
        0x044F => Some(0xD1),
        0x0451 => Some(0xA3),
        0x2219 => Some(0x95),
        0x221A => Some(0x96),
        0x2248 => Some(0x97),
        0x2264 => Some(0x98),
        0x2265 => Some(0x99),
        0x2320 => Some(0x93),
        0x2321 => Some(0x9B),
        0x2500 => Some(0x80),
        0x2502 => Some(0x81),
        0x250C => Some(0x82),
        0x2510 => Some(0x83),
        0x2514 => Some(0x84),
        0x2518 => Some(0x85),
        0x251C => Some(0x86),
        0x2524 => Some(0x87),
        0x252C => Some(0x88),
        0x2534 => Some(0x89),
        0x253C => Some(0x8A),
        0x2550 => Some(0xA0),
        0x2551 => Some(0xA1),
        0x2552 => Some(0xA2),
        0x2553 => Some(0xA4),
        0x2554 => Some(0xA5),
        0x2555 => Some(0xA6),
        0x2556 => Some(0xA7),
        0x2557 => Some(0xA8),
        0x2558 => Some(0xA9),
        0x2559 => Some(0xAA),
        0x255A => Some(0xAB),
        0x255B => Some(0xAC),
        0x255C => Some(0xAD),
        0x255D => Some(0xAE),
        0x255E => Some(0xAF),
        0x255F => Some(0xB0),
        0x2560 => Some(0xB1),
        0x2561 => Some(0xB2),
        0x2562 => Some(0xB4),
        0x2563 => Some(0xB5),
        0x2564 => Some(0xB6),
        0x2565 => Some(0xB7),
        0x2566 => Some(0xB8),
        0x2567 => Some(0xB9),
        0x2568 => Some(0xBA),
        0x2569 => Some(0xBB),
        0x256A => Some(0xBC),
        0x256B => Some(0xBD),
        0x256C => Some(0xBE),
        0x2580 => Some(0x8B),
        0x2584 => Some(0x8C),
        0x2588 => Some(0x8D),
        0x258C => Some(0x8E),
        0x2590 => Some(0x8F),
        0x2591 => Some(0x90),
        0x2592 => Some(0x91),
        0x2593 => Some(0x92),
        0x25A0 => Some(0x94),
        _ => None,
    }
}

fn encode_iso8859_2_byte(code: u32) -> Option<u8> {
    match code {
        0x0080 => Some(0x80),
        0x0081 => Some(0x81),
        0x0082 => Some(0x82),
        0x0083 => Some(0x83),
        0x0084 => Some(0x84),
        0x0085 => Some(0x85),
        0x0086 => Some(0x86),
        0x0087 => Some(0x87),
        0x0088 => Some(0x88),
        0x0089 => Some(0x89),
        0x008A => Some(0x8A),
        0x008B => Some(0x8B),
        0x008C => Some(0x8C),
        0x008D => Some(0x8D),
        0x008E => Some(0x8E),
        0x008F => Some(0x8F),
        0x0090 => Some(0x90),
        0x0091 => Some(0x91),
        0x0092 => Some(0x92),
        0x0093 => Some(0x93),
        0x0094 => Some(0x94),
        0x0095 => Some(0x95),
        0x0096 => Some(0x96),
        0x0097 => Some(0x97),
        0x0098 => Some(0x98),
        0x0099 => Some(0x99),
        0x009A => Some(0x9A),
        0x009B => Some(0x9B),
        0x009C => Some(0x9C),
        0x009D => Some(0x9D),
        0x009E => Some(0x9E),
        0x009F => Some(0x9F),
        0x00A0 => Some(0xA0),
        0x00A4 => Some(0xA4),
        0x00A7 => Some(0xA7),
        0x00A8 => Some(0xA8),
        0x00AD => Some(0xAD),
        0x00B0 => Some(0xB0),
        0x00B4 => Some(0xB4),
        0x00B8 => Some(0xB8),
        0x00C1 => Some(0xC1),
        0x00C2 => Some(0xC2),
        0x00C4 => Some(0xC4),
        0x00C7 => Some(0xC7),
        0x00C9 => Some(0xC9),
        0x00CB => Some(0xCB),
        0x00CD => Some(0xCD),
        0x00CE => Some(0xCE),
        0x00D3 => Some(0xD3),
        0x00D4 => Some(0xD4),
        0x00D6 => Some(0xD6),
        0x00D7 => Some(0xD7),
        0x00DA => Some(0xDA),
        0x00DC => Some(0xDC),
        0x00DD => Some(0xDD),
        0x00DF => Some(0xDF),
        0x00E1 => Some(0xE1),
        0x00E2 => Some(0xE2),
        0x00E4 => Some(0xE4),
        0x00E7 => Some(0xE7),
        0x00E9 => Some(0xE9),
        0x00EB => Some(0xEB),
        0x00ED => Some(0xED),
        0x00EE => Some(0xEE),
        0x00F3 => Some(0xF3),
        0x00F4 => Some(0xF4),
        0x00F6 => Some(0xF6),
        0x00F7 => Some(0xF7),
        0x00FA => Some(0xFA),
        0x00FC => Some(0xFC),
        0x00FD => Some(0xFD),
        0x0102 => Some(0xC3),
        0x0103 => Some(0xE3),
        0x0104 => Some(0xA1),
        0x0105 => Some(0xB1),
        0x0106 => Some(0xC6),
        0x0107 => Some(0xE6),
        0x010C => Some(0xC8),
        0x010D => Some(0xE8),
        0x010E => Some(0xCF),
        0x010F => Some(0xEF),
        0x0110 => Some(0xD0),
        0x0111 => Some(0xF0),
        0x0118 => Some(0xCA),
        0x0119 => Some(0xEA),
        0x011A => Some(0xCC),
        0x011B => Some(0xEC),
        0x0139 => Some(0xC5),
        0x013A => Some(0xE5),
        0x013D => Some(0xA5),
        0x013E => Some(0xB5),
        0x0141 => Some(0xA3),
        0x0142 => Some(0xB3),
        0x0143 => Some(0xD1),
        0x0144 => Some(0xF1),
        0x0147 => Some(0xD2),
        0x0148 => Some(0xF2),
        0x0150 => Some(0xD5),
        0x0151 => Some(0xF5),
        0x0154 => Some(0xC0),
        0x0155 => Some(0xE0),
        0x0158 => Some(0xD8),
        0x0159 => Some(0xF8),
        0x015A => Some(0xA6),
        0x015B => Some(0xB6),
        0x015E => Some(0xAA),
        0x015F => Some(0xBA),
        0x0160 => Some(0xA9),
        0x0161 => Some(0xB9),
        0x0162 => Some(0xDE),
        0x0163 => Some(0xFE),
        0x0164 => Some(0xAB),
        0x0165 => Some(0xBB),
        0x016E => Some(0xD9),
        0x016F => Some(0xF9),
        0x0170 => Some(0xDB),
        0x0171 => Some(0xFB),
        0x0179 => Some(0xAC),
        0x017A => Some(0xBC),
        0x017B => Some(0xAF),
        0x017C => Some(0xBF),
        0x017D => Some(0xAE),
        0x017E => Some(0xBE),
        0x02C7 => Some(0xB7),
        0x02D8 => Some(0xA2),
        0x02D9 => Some(0xFF),
        0x02DB => Some(0xB2),
        0x02DD => Some(0xBD),
        _ => None,
    }
}

fn encode_iso8859_3_byte(code: u32) -> Option<u8> {
    match code {
        0x0080 => Some(0x80),
        0x0081 => Some(0x81),
        0x0082 => Some(0x82),
        0x0083 => Some(0x83),
        0x0084 => Some(0x84),
        0x0085 => Some(0x85),
        0x0086 => Some(0x86),
        0x0087 => Some(0x87),
        0x0088 => Some(0x88),
        0x0089 => Some(0x89),
        0x008A => Some(0x8A),
        0x008B => Some(0x8B),
        0x008C => Some(0x8C),
        0x008D => Some(0x8D),
        0x008E => Some(0x8E),
        0x008F => Some(0x8F),
        0x0090 => Some(0x90),
        0x0091 => Some(0x91),
        0x0092 => Some(0x92),
        0x0093 => Some(0x93),
        0x0094 => Some(0x94),
        0x0095 => Some(0x95),
        0x0096 => Some(0x96),
        0x0097 => Some(0x97),
        0x0098 => Some(0x98),
        0x0099 => Some(0x99),
        0x009A => Some(0x9A),
        0x009B => Some(0x9B),
        0x009C => Some(0x9C),
        0x009D => Some(0x9D),
        0x009E => Some(0x9E),
        0x009F => Some(0x9F),
        0x00A0 => Some(0xA0),
        0x00A3 => Some(0xA3),
        0x00A4 => Some(0xA4),
        0x00A7 => Some(0xA7),
        0x00A8 => Some(0xA8),
        0x00AD => Some(0xAD),
        0x00B0 => Some(0xB0),
        0x00B2 => Some(0xB2),
        0x00B3 => Some(0xB3),
        0x00B4 => Some(0xB4),
        0x00B5 => Some(0xB5),
        0x00B7 => Some(0xB7),
        0x00B8 => Some(0xB8),
        0x00BD => Some(0xBD),
        0x00C0 => Some(0xC0),
        0x00C1 => Some(0xC1),
        0x00C2 => Some(0xC2),
        0x00C4 => Some(0xC4),
        0x00C7 => Some(0xC7),
        0x00C8 => Some(0xC8),
        0x00C9 => Some(0xC9),
        0x00CA => Some(0xCA),
        0x00CB => Some(0xCB),
        0x00CC => Some(0xCC),
        0x00CD => Some(0xCD),
        0x00CE => Some(0xCE),
        0x00CF => Some(0xCF),
        0x00D1 => Some(0xD1),
        0x00D2 => Some(0xD2),
        0x00D3 => Some(0xD3),
        0x00D4 => Some(0xD4),
        0x00D6 => Some(0xD6),
        0x00D7 => Some(0xD7),
        0x00D9 => Some(0xD9),
        0x00DA => Some(0xDA),
        0x00DB => Some(0xDB),
        0x00DC => Some(0xDC),
        0x00DF => Some(0xDF),
        0x00E0 => Some(0xE0),
        0x00E1 => Some(0xE1),
        0x00E2 => Some(0xE2),
        0x00E4 => Some(0xE4),
        0x00E7 => Some(0xE7),
        0x00E8 => Some(0xE8),
        0x00E9 => Some(0xE9),
        0x00EA => Some(0xEA),
        0x00EB => Some(0xEB),
        0x00EC => Some(0xEC),
        0x00ED => Some(0xED),
        0x00EE => Some(0xEE),
        0x00EF => Some(0xEF),
        0x00F1 => Some(0xF1),
        0x00F2 => Some(0xF2),
        0x00F3 => Some(0xF3),
        0x00F4 => Some(0xF4),
        0x00F6 => Some(0xF6),
        0x00F7 => Some(0xF7),
        0x00F9 => Some(0xF9),
        0x00FA => Some(0xFA),
        0x00FB => Some(0xFB),
        0x00FC => Some(0xFC),
        0x0108 => Some(0xC6),
        0x0109 => Some(0xE6),
        0x010A => Some(0xC5),
        0x010B => Some(0xE5),
        0x011C => Some(0xD8),
        0x011D => Some(0xF8),
        0x011E => Some(0xAB),
        0x011F => Some(0xBB),
        0x0120 => Some(0xD5),
        0x0121 => Some(0xF5),
        0x0124 => Some(0xA6),
        0x0125 => Some(0xB6),
        0x0126 => Some(0xA1),
        0x0127 => Some(0xB1),
        0x0130 => Some(0xA9),
        0x0131 => Some(0xB9),
        0x0134 => Some(0xAC),
        0x0135 => Some(0xBC),
        0x015C => Some(0xDE),
        0x015D => Some(0xFE),
        0x015E => Some(0xAA),
        0x015F => Some(0xBA),
        0x016C => Some(0xDD),
        0x016D => Some(0xFD),
        0x017B => Some(0xAF),
        0x017C => Some(0xBF),
        0x02D8 => Some(0xA2),
        0x02D9 => Some(0xFF),
        _ => None,
    }
}
fn encode_iso8859_4_byte(code: u32) -> Option<u8> {
    match code {
        0x0080 => Some(0x80),
        0x0081 => Some(0x81),
        0x0082 => Some(0x82),
        0x0083 => Some(0x83),
        0x0084 => Some(0x84),
        0x0085 => Some(0x85),
        0x0086 => Some(0x86),
        0x0087 => Some(0x87),
        0x0088 => Some(0x88),
        0x0089 => Some(0x89),
        0x008A => Some(0x8A),
        0x008B => Some(0x8B),
        0x008C => Some(0x8C),
        0x008D => Some(0x8D),
        0x008E => Some(0x8E),
        0x008F => Some(0x8F),
        0x0090 => Some(0x90),
        0x0091 => Some(0x91),
        0x0092 => Some(0x92),
        0x0093 => Some(0x93),
        0x0094 => Some(0x94),
        0x0095 => Some(0x95),
        0x0096 => Some(0x96),
        0x0097 => Some(0x97),
        0x0098 => Some(0x98),
        0x0099 => Some(0x99),
        0x009A => Some(0x9A),
        0x009B => Some(0x9B),
        0x009C => Some(0x9C),
        0x009D => Some(0x9D),
        0x009E => Some(0x9E),
        0x009F => Some(0x9F),
        0x00A0 => Some(0xA0),
        0x00A4 => Some(0xA4),
        0x00A7 => Some(0xA7),
        0x00A8 => Some(0xA8),
        0x00AD => Some(0xAD),
        0x00AF => Some(0xAF),
        0x00B0 => Some(0xB0),
        0x00B4 => Some(0xB4),
        0x00B8 => Some(0xB8),
        0x00C1 => Some(0xC1),
        0x00C2 => Some(0xC2),
        0x00C3 => Some(0xC3),
        0x00C4 => Some(0xC4),
        0x00C5 => Some(0xC5),
        0x00C6 => Some(0xC6),
        0x00C9 => Some(0xC9),
        0x00CB => Some(0xCB),
        0x00CD => Some(0xCD),
        0x00CE => Some(0xCE),
        0x00D4 => Some(0xD4),
        0x00D5 => Some(0xD5),
        0x00D6 => Some(0xD6),
        0x00D7 => Some(0xD7),
        0x00D8 => Some(0xD8),
        0x00DA => Some(0xDA),
        0x00DB => Some(0xDB),
        0x00DC => Some(0xDC),
        0x00DF => Some(0xDF),
        0x00E1 => Some(0xE1),
        0x00E2 => Some(0xE2),
        0x00E3 => Some(0xE3),
        0x00E4 => Some(0xE4),
        0x00E5 => Some(0xE5),
        0x00E6 => Some(0xE6),
        0x00E9 => Some(0xE9),
        0x00EB => Some(0xEB),
        0x00ED => Some(0xED),
        0x00EE => Some(0xEE),
        0x00F4 => Some(0xF4),
        0x00F5 => Some(0xF5),
        0x00F6 => Some(0xF6),
        0x00F7 => Some(0xF7),
        0x00F8 => Some(0xF8),
        0x00FA => Some(0xFA),
        0x00FB => Some(0xFB),
        0x00FC => Some(0xFC),
        0x0100 => Some(0xC0),
        0x0101 => Some(0xE0),
        0x0104 => Some(0xA1),
        0x0105 => Some(0xB1),
        0x010C => Some(0xC8),
        0x010D => Some(0xE8),
        0x0110 => Some(0xD0),
        0x0111 => Some(0xF0),
        0x0112 => Some(0xAA),
        0x0113 => Some(0xBA),
        0x0116 => Some(0xCC),
        0x0117 => Some(0xEC),
        0x0118 => Some(0xCA),
        0x0119 => Some(0xEA),
        0x0122 => Some(0xAB),
        0x0123 => Some(0xBB),
        0x0128 => Some(0xA5),
        0x0129 => Some(0xB5),
        0x012A => Some(0xCF),
        0x012B => Some(0xEF),
        0x012E => Some(0xC7),
        0x012F => Some(0xE7),
        0x0136 => Some(0xD3),
        0x0137 => Some(0xF3),
        0x0138 => Some(0xA2),
        0x013B => Some(0xA6),
        0x013C => Some(0xB6),
        0x0145 => Some(0xD1),
        0x0146 => Some(0xF1),
        0x014A => Some(0xBD),
        0x014B => Some(0xBF),
        0x014C => Some(0xD2),
        0x014D => Some(0xF2),
        0x0156 => Some(0xA3),
        0x0157 => Some(0xB3),
        0x0160 => Some(0xA9),
        0x0161 => Some(0xB9),
        0x0166 => Some(0xAC),
        0x0167 => Some(0xBC),
        0x0168 => Some(0xDD),
        0x0169 => Some(0xFD),
        0x016A => Some(0xDE),
        0x016B => Some(0xFE),
        0x0172 => Some(0xD9),
        0x0173 => Some(0xF9),
        0x017D => Some(0xAE),
        0x017E => Some(0xBE),
        0x02C7 => Some(0xB7),
        0x02D9 => Some(0xFF),
        0x02DB => Some(0xB2),
        _ => None,
    }
}
fn encode_iso8859_5_byte(code: u32) -> Option<u8> {
    match code {
        0x0080 => Some(0x80),
        0x0081 => Some(0x81),
        0x0082 => Some(0x82),
        0x0083 => Some(0x83),
        0x0084 => Some(0x84),
        0x0085 => Some(0x85),
        0x0086 => Some(0x86),
        0x0087 => Some(0x87),
        0x0088 => Some(0x88),
        0x0089 => Some(0x89),
        0x008A => Some(0x8A),
        0x008B => Some(0x8B),
        0x008C => Some(0x8C),
        0x008D => Some(0x8D),
        0x008E => Some(0x8E),
        0x008F => Some(0x8F),
        0x0090 => Some(0x90),
        0x0091 => Some(0x91),
        0x0092 => Some(0x92),
        0x0093 => Some(0x93),
        0x0094 => Some(0x94),
        0x0095 => Some(0x95),
        0x0096 => Some(0x96),
        0x0097 => Some(0x97),
        0x0098 => Some(0x98),
        0x0099 => Some(0x99),
        0x009A => Some(0x9A),
        0x009B => Some(0x9B),
        0x009C => Some(0x9C),
        0x009D => Some(0x9D),
        0x009E => Some(0x9E),
        0x009F => Some(0x9F),
        0x00A0 => Some(0xA0),
        0x00A7 => Some(0xFD),
        0x00AD => Some(0xAD),
        0x0401 => Some(0xA1),
        0x0402 => Some(0xA2),
        0x0403 => Some(0xA3),
        0x0404 => Some(0xA4),
        0x0405 => Some(0xA5),
        0x0406 => Some(0xA6),
        0x0407 => Some(0xA7),
        0x0408 => Some(0xA8),
        0x0409 => Some(0xA9),
        0x040A => Some(0xAA),
        0x040B => Some(0xAB),
        0x040C => Some(0xAC),
        0x040E => Some(0xAE),
        0x040F => Some(0xAF),
        0x0410 => Some(0xB0),
        0x0411 => Some(0xB1),
        0x0412 => Some(0xB2),
        0x0413 => Some(0xB3),
        0x0414 => Some(0xB4),
        0x0415 => Some(0xB5),
        0x0416 => Some(0xB6),
        0x0417 => Some(0xB7),
        0x0418 => Some(0xB8),
        0x0419 => Some(0xB9),
        0x041A => Some(0xBA),
        0x041B => Some(0xBB),
        0x041C => Some(0xBC),
        0x041D => Some(0xBD),
        0x041E => Some(0xBE),
        0x041F => Some(0xBF),
        0x0420 => Some(0xC0),
        0x0421 => Some(0xC1),
        0x0422 => Some(0xC2),
        0x0423 => Some(0xC3),
        0x0424 => Some(0xC4),
        0x0425 => Some(0xC5),
        0x0426 => Some(0xC6),
        0x0427 => Some(0xC7),
        0x0428 => Some(0xC8),
        0x0429 => Some(0xC9),
        0x042A => Some(0xCA),
        0x042B => Some(0xCB),
        0x042C => Some(0xCC),
        0x042D => Some(0xCD),
        0x042E => Some(0xCE),
        0x042F => Some(0xCF),
        0x0430 => Some(0xD0),
        0x0431 => Some(0xD1),
        0x0432 => Some(0xD2),
        0x0433 => Some(0xD3),
        0x0434 => Some(0xD4),
        0x0435 => Some(0xD5),
        0x0436 => Some(0xD6),
        0x0437 => Some(0xD7),
        0x0438 => Some(0xD8),
        0x0439 => Some(0xD9),
        0x043A => Some(0xDA),
        0x043B => Some(0xDB),
        0x043C => Some(0xDC),
        0x043D => Some(0xDD),
        0x043E => Some(0xDE),
        0x043F => Some(0xDF),
        0x0440 => Some(0xE0),
        0x0441 => Some(0xE1),
        0x0442 => Some(0xE2),
        0x0443 => Some(0xE3),
        0x0444 => Some(0xE4),
        0x0445 => Some(0xE5),
        0x0446 => Some(0xE6),
        0x0447 => Some(0xE7),
        0x0448 => Some(0xE8),
        0x0449 => Some(0xE9),
        0x044A => Some(0xEA),
        0x044B => Some(0xEB),
        0x044C => Some(0xEC),
        0x044D => Some(0xED),
        0x044E => Some(0xEE),
        0x044F => Some(0xEF),
        0x0451 => Some(0xF1),
        0x0452 => Some(0xF2),
        0x0453 => Some(0xF3),
        0x0454 => Some(0xF4),
        0x0455 => Some(0xF5),
        0x0456 => Some(0xF6),
        0x0457 => Some(0xF7),
        0x0458 => Some(0xF8),
        0x0459 => Some(0xF9),
        0x045A => Some(0xFA),
        0x045B => Some(0xFB),
        0x045C => Some(0xFC),
        0x045E => Some(0xFE),
        0x045F => Some(0xFF),
        0x2116 => Some(0xF0),
        _ => None,
    }
}

fn encode_iso8859_6_byte(code: u32) -> Option<u8> {
    match code {
        0x0080 => Some(0x80),
        0x0081 => Some(0x81),
        0x0082 => Some(0x82),
        0x0083 => Some(0x83),
        0x0084 => Some(0x84),
        0x0085 => Some(0x85),
        0x0086 => Some(0x86),
        0x0087 => Some(0x87),
        0x0088 => Some(0x88),
        0x0089 => Some(0x89),
        0x008A => Some(0x8A),
        0x008B => Some(0x8B),
        0x008C => Some(0x8C),
        0x008D => Some(0x8D),
        0x008E => Some(0x8E),
        0x008F => Some(0x8F),
        0x0090 => Some(0x90),
        0x0091 => Some(0x91),
        0x0092 => Some(0x92),
        0x0093 => Some(0x93),
        0x0094 => Some(0x94),
        0x0095 => Some(0x95),
        0x0096 => Some(0x96),
        0x0097 => Some(0x97),
        0x0098 => Some(0x98),
        0x0099 => Some(0x99),
        0x009A => Some(0x9A),
        0x009B => Some(0x9B),
        0x009C => Some(0x9C),
        0x009D => Some(0x9D),
        0x009E => Some(0x9E),
        0x009F => Some(0x9F),
        0x00A0 => Some(0xA0),
        0x00A4 => Some(0xA4),
        0x00AD => Some(0xAD),
        0x060C => Some(0xAC),
        0x061B => Some(0xBB),
        0x061F => Some(0xBF),
        0x0621 => Some(0xC1),
        0x0622 => Some(0xC2),
        0x0623 => Some(0xC3),
        0x0624 => Some(0xC4),
        0x0625 => Some(0xC5),
        0x0626 => Some(0xC6),
        0x0627 => Some(0xC7),
        0x0628 => Some(0xC8),
        0x0629 => Some(0xC9),
        0x062A => Some(0xCA),
        0x062B => Some(0xCB),
        0x062C => Some(0xCC),
        0x062D => Some(0xCD),
        0x062E => Some(0xCE),
        0x062F => Some(0xCF),
        0x0630 => Some(0xD0),
        0x0631 => Some(0xD1),
        0x0632 => Some(0xD2),
        0x0633 => Some(0xD3),
        0x0634 => Some(0xD4),
        0x0635 => Some(0xD5),
        0x0636 => Some(0xD6),
        0x0637 => Some(0xD7),
        0x0638 => Some(0xD8),
        0x0639 => Some(0xD9),
        0x063A => Some(0xDA),
        0x0640 => Some(0xE0),
        0x0641 => Some(0xE1),
        0x0642 => Some(0xE2),
        0x0643 => Some(0xE3),
        0x0644 => Some(0xE4),
        0x0645 => Some(0xE5),
        0x0646 => Some(0xE6),
        0x0647 => Some(0xE7),
        0x0648 => Some(0xE8),
        0x0649 => Some(0xE9),
        0x064A => Some(0xEA),
        0x064B => Some(0xEB),
        0x064C => Some(0xEC),
        0x064D => Some(0xED),
        0x064E => Some(0xEE),
        0x064F => Some(0xEF),
        0x0650 => Some(0xF0),
        0x0651 => Some(0xF1),
        0x0652 => Some(0xF2),
        _ => None,
    }
}
fn encode_iso8859_7_byte(code: u32) -> Option<u8> {
    match code {
        0x0080 => Some(0x80),
        0x0081 => Some(0x81),
        0x0082 => Some(0x82),
        0x0083 => Some(0x83),
        0x0084 => Some(0x84),
        0x0085 => Some(0x85),
        0x0086 => Some(0x86),
        0x0087 => Some(0x87),
        0x0088 => Some(0x88),
        0x0089 => Some(0x89),
        0x008A => Some(0x8A),
        0x008B => Some(0x8B),
        0x008C => Some(0x8C),
        0x008D => Some(0x8D),
        0x008E => Some(0x8E),
        0x008F => Some(0x8F),
        0x0090 => Some(0x90),
        0x0091 => Some(0x91),
        0x0092 => Some(0x92),
        0x0093 => Some(0x93),
        0x0094 => Some(0x94),
        0x0095 => Some(0x95),
        0x0096 => Some(0x96),
        0x0097 => Some(0x97),
        0x0098 => Some(0x98),
        0x0099 => Some(0x99),
        0x009A => Some(0x9A),
        0x009B => Some(0x9B),
        0x009C => Some(0x9C),
        0x009D => Some(0x9D),
        0x009E => Some(0x9E),
        0x009F => Some(0x9F),
        0x00A0 => Some(0xA0),
        0x00A3 => Some(0xA3),
        0x00A6 => Some(0xA6),
        0x00A7 => Some(0xA7),
        0x00A8 => Some(0xA8),
        0x00A9 => Some(0xA9),
        0x00AB => Some(0xAB),
        0x00AC => Some(0xAC),
        0x00AD => Some(0xAD),
        0x00B0 => Some(0xB0),
        0x00B1 => Some(0xB1),
        0x00B2 => Some(0xB2),
        0x00B3 => Some(0xB3),
        0x00B7 => Some(0xB7),
        0x00BB => Some(0xBB),
        0x00BD => Some(0xBD),
        0x037A => Some(0xAA),
        0x0384 => Some(0xB4),
        0x0385 => Some(0xB5),
        0x0386 => Some(0xB6),
        0x0388 => Some(0xB8),
        0x0389 => Some(0xB9),
        0x038A => Some(0xBA),
        0x038C => Some(0xBC),
        0x038E => Some(0xBE),
        0x038F => Some(0xBF),
        0x0390 => Some(0xC0),
        0x0391 => Some(0xC1),
        0x0392 => Some(0xC2),
        0x0393 => Some(0xC3),
        0x0394 => Some(0xC4),
        0x0395 => Some(0xC5),
        0x0396 => Some(0xC6),
        0x0397 => Some(0xC7),
        0x0398 => Some(0xC8),
        0x0399 => Some(0xC9),
        0x039A => Some(0xCA),
        0x039B => Some(0xCB),
        0x039C => Some(0xCC),
        0x039D => Some(0xCD),
        0x039E => Some(0xCE),
        0x039F => Some(0xCF),
        0x03A0 => Some(0xD0),
        0x03A1 => Some(0xD1),
        0x03A3 => Some(0xD3),
        0x03A4 => Some(0xD4),
        0x03A5 => Some(0xD5),
        0x03A6 => Some(0xD6),
        0x03A7 => Some(0xD7),
        0x03A8 => Some(0xD8),
        0x03A9 => Some(0xD9),
        0x03AA => Some(0xDA),
        0x03AB => Some(0xDB),
        0x03AC => Some(0xDC),
        0x03AD => Some(0xDD),
        0x03AE => Some(0xDE),
        0x03AF => Some(0xDF),
        0x03B0 => Some(0xE0),
        0x03B1 => Some(0xE1),
        0x03B2 => Some(0xE2),
        0x03B3 => Some(0xE3),
        0x03B4 => Some(0xE4),
        0x03B5 => Some(0xE5),
        0x03B6 => Some(0xE6),
        0x03B7 => Some(0xE7),
        0x03B8 => Some(0xE8),
        0x03B9 => Some(0xE9),
        0x03BA => Some(0xEA),
        0x03BB => Some(0xEB),
        0x03BC => Some(0xEC),
        0x03BD => Some(0xED),
        0x03BE => Some(0xEE),
        0x03BF => Some(0xEF),
        0x03C0 => Some(0xF0),
        0x03C1 => Some(0xF1),
        0x03C2 => Some(0xF2),
        0x03C3 => Some(0xF3),
        0x03C4 => Some(0xF4),
        0x03C5 => Some(0xF5),
        0x03C6 => Some(0xF6),
        0x03C7 => Some(0xF7),
        0x03C8 => Some(0xF8),
        0x03C9 => Some(0xF9),
        0x03CA => Some(0xFA),
        0x03CB => Some(0xFB),
        0x03CC => Some(0xFC),
        0x03CD => Some(0xFD),
        0x03CE => Some(0xFE),
        0x2015 => Some(0xAF),
        0x2018 => Some(0xA1),
        0x2019 => Some(0xA2),
        0x20AC => Some(0xA4),
        0x20AF => Some(0xA5),
        _ => None,
    }
}

fn encode_koi8_u_byte(code: u32) -> Option<u8> {
    match code {
        0x00A0 => Some(0x9A),
        0x00A9 => Some(0xBF),
        0x00B0 => Some(0x9C),
        0x00B2 => Some(0x9D),
        0x00B7 => Some(0x9E),
        0x00F7 => Some(0x9F),
        0x0401 => Some(0xB3),
        0x0404 => Some(0xB4),
        0x0406 => Some(0xB6),
        0x0407 => Some(0xB7),
        0x0410 => Some(0xE1),
        0x0411 => Some(0xE2),
        0x0412 => Some(0xF7),
        0x0413 => Some(0xE7),
        0x0414 => Some(0xE4),
        0x0415 => Some(0xE5),
        0x0416 => Some(0xF6),
        0x0417 => Some(0xFA),
        0x0418 => Some(0xE9),
        0x0419 => Some(0xEA),
        0x041A => Some(0xEB),
        0x041B => Some(0xEC),
        0x041C => Some(0xED),
        0x041D => Some(0xEE),
        0x041E => Some(0xEF),
        0x041F => Some(0xF0),
        0x0420 => Some(0xF2),
        0x0421 => Some(0xF3),
        0x0422 => Some(0xF4),
        0x0423 => Some(0xF5),
        0x0424 => Some(0xE6),
        0x0425 => Some(0xE8),
        0x0426 => Some(0xE3),
        0x0427 => Some(0xFE),
        0x0428 => Some(0xFB),
        0x0429 => Some(0xFD),
        0x042A => Some(0xFF),
        0x042B => Some(0xF9),
        0x042C => Some(0xF8),
        0x042D => Some(0xFC),
        0x042E => Some(0xE0),
        0x042F => Some(0xF1),
        0x0430 => Some(0xC1),
        0x0431 => Some(0xC2),
        0x0432 => Some(0xD7),
        0x0433 => Some(0xC7),
        0x0434 => Some(0xC4),
        0x0435 => Some(0xC5),
        0x0436 => Some(0xD6),
        0x0437 => Some(0xDA),
        0x0438 => Some(0xC9),
        0x0439 => Some(0xCA),
        0x043A => Some(0xCB),
        0x043B => Some(0xCC),
        0x043C => Some(0xCD),
        0x043D => Some(0xCE),
        0x043E => Some(0xCF),
        0x043F => Some(0xD0),
        0x0440 => Some(0xD2),
        0x0441 => Some(0xD3),
        0x0442 => Some(0xD4),
        0x0443 => Some(0xD5),
        0x0444 => Some(0xC6),
        0x0445 => Some(0xC8),
        0x0446 => Some(0xC3),
        0x0447 => Some(0xDE),
        0x0448 => Some(0xDB),
        0x0449 => Some(0xDD),
        0x044A => Some(0xDF),
        0x044B => Some(0xD9),
        0x044C => Some(0xD8),
        0x044D => Some(0xDC),
        0x044E => Some(0xC0),
        0x044F => Some(0xD1),
        0x0451 => Some(0xA3),
        0x0454 => Some(0xA4),
        0x0456 => Some(0xA6),
        0x0457 => Some(0xA7),
        0x0490 => Some(0xBD),
        0x0491 => Some(0xAD),
        0x2219 => Some(0x95),
        0x221A => Some(0x96),
        0x2248 => Some(0x97),
        0x2264 => Some(0x98),
        0x2265 => Some(0x99),
        0x2320 => Some(0x93),
        0x2321 => Some(0x9B),
        0x2500 => Some(0x80),
        0x2502 => Some(0x81),
        0x250C => Some(0x82),
        0x2510 => Some(0x83),
        0x2514 => Some(0x84),
        0x2518 => Some(0x85),
        0x251C => Some(0x86),
        0x2524 => Some(0x87),
        0x252C => Some(0x88),
        0x2534 => Some(0x89),
        0x253C => Some(0x8A),
        0x2550 => Some(0xA0),
        0x2551 => Some(0xA1),
        0x2552 => Some(0xA2),
        0x2554 => Some(0xA5),
        0x2557 => Some(0xA8),
        0x2558 => Some(0xA9),
        0x2559 => Some(0xAA),
        0x255A => Some(0xAB),
        0x255B => Some(0xAC),
        0x255D => Some(0xAE),
        0x255E => Some(0xAF),
        0x255F => Some(0xB0),
        0x2560 => Some(0xB1),
        0x2561 => Some(0xB2),
        0x2563 => Some(0xB5),
        0x2566 => Some(0xB8),
        0x2567 => Some(0xB9),
        0x2568 => Some(0xBA),
        0x2569 => Some(0xBB),
        0x256A => Some(0xBC),
        0x256C => Some(0xBE),
        0x2580 => Some(0x8B),
        0x2584 => Some(0x8C),
        0x2588 => Some(0x8D),
        0x258C => Some(0x8E),
        0x2590 => Some(0x8F),
        0x2591 => Some(0x90),
        0x2592 => Some(0x91),
        0x2593 => Some(0x92),
        0x25A0 => Some(0x94),
        _ => None,
    }
}

fn encode_iso8859_8_byte(code: u32) -> Option<u8> {
    match code {
        0x0080 => Some(0x80),
        0x0081 => Some(0x81),
        0x0082 => Some(0x82),
        0x0083 => Some(0x83),
        0x0084 => Some(0x84),
        0x0085 => Some(0x85),
        0x0086 => Some(0x86),
        0x0087 => Some(0x87),
        0x0088 => Some(0x88),
        0x0089 => Some(0x89),
        0x008A => Some(0x8A),
        0x008B => Some(0x8B),
        0x008C => Some(0x8C),
        0x008D => Some(0x8D),
        0x008E => Some(0x8E),
        0x008F => Some(0x8F),
        0x0090 => Some(0x90),
        0x0091 => Some(0x91),
        0x0092 => Some(0x92),
        0x0093 => Some(0x93),
        0x0094 => Some(0x94),
        0x0095 => Some(0x95),
        0x0096 => Some(0x96),
        0x0097 => Some(0x97),
        0x0098 => Some(0x98),
        0x0099 => Some(0x99),
        0x009A => Some(0x9A),
        0x009B => Some(0x9B),
        0x009C => Some(0x9C),
        0x009D => Some(0x9D),
        0x009E => Some(0x9E),
        0x009F => Some(0x9F),
        0x00A0 => Some(0xA0),
        0x00A2 => Some(0xA2),
        0x00A3 => Some(0xA3),
        0x00A4 => Some(0xA4),
        0x00A5 => Some(0xA5),
        0x00A6 => Some(0xA6),
        0x00A7 => Some(0xA7),
        0x00A8 => Some(0xA8),
        0x00A9 => Some(0xA9),
        0x00AB => Some(0xAB),
        0x00AC => Some(0xAC),
        0x00AD => Some(0xAD),
        0x00AE => Some(0xAE),
        0x00AF => Some(0xAF),
        0x00B0 => Some(0xB0),
        0x00B1 => Some(0xB1),
        0x00B2 => Some(0xB2),
        0x00B3 => Some(0xB3),
        0x00B4 => Some(0xB4),
        0x00B5 => Some(0xB5),
        0x00B6 => Some(0xB6),
        0x00B7 => Some(0xB7),
        0x00B8 => Some(0xB8),
        0x00B9 => Some(0xB9),
        0x00BB => Some(0xBB),
        0x00BC => Some(0xBC),
        0x00BD => Some(0xBD),
        0x00BE => Some(0xBE),
        0x00D7 => Some(0xAA),
        0x00F7 => Some(0xBA),
        0x05D0 => Some(0xE0),
        0x05D1 => Some(0xE1),
        0x05D2 => Some(0xE2),
        0x05D3 => Some(0xE3),
        0x05D4 => Some(0xE4),
        0x05D5 => Some(0xE5),
        0x05D6 => Some(0xE6),
        0x05D7 => Some(0xE7),
        0x05D8 => Some(0xE8),
        0x05D9 => Some(0xE9),
        0x05DA => Some(0xEA),
        0x05DB => Some(0xEB),
        0x05DC => Some(0xEC),
        0x05DD => Some(0xED),
        0x05DE => Some(0xEE),
        0x05DF => Some(0xEF),
        0x05E0 => Some(0xF0),
        0x05E1 => Some(0xF1),
        0x05E2 => Some(0xF2),
        0x05E3 => Some(0xF3),
        0x05E4 => Some(0xF4),
        0x05E5 => Some(0xF5),
        0x05E6 => Some(0xF6),
        0x05E7 => Some(0xF7),
        0x05E8 => Some(0xF8),
        0x05E9 => Some(0xF9),
        0x05EA => Some(0xFA),
        0x200E => Some(0xFD),
        0x200F => Some(0xFE),
        0x2017 => Some(0xDF),
        _ => None,
    }
}
fn encode_iso8859_10_byte(code: u32) -> Option<u8> {
    match code {
        0x0080 => Some(0x80),
        0x0081 => Some(0x81),
        0x0082 => Some(0x82),
        0x0083 => Some(0x83),
        0x0084 => Some(0x84),
        0x0085 => Some(0x85),
        0x0086 => Some(0x86),
        0x0087 => Some(0x87),
        0x0088 => Some(0x88),
        0x0089 => Some(0x89),
        0x008A => Some(0x8A),
        0x008B => Some(0x8B),
        0x008C => Some(0x8C),
        0x008D => Some(0x8D),
        0x008E => Some(0x8E),
        0x008F => Some(0x8F),
        0x0090 => Some(0x90),
        0x0091 => Some(0x91),
        0x0092 => Some(0x92),
        0x0093 => Some(0x93),
        0x0094 => Some(0x94),
        0x0095 => Some(0x95),
        0x0096 => Some(0x96),
        0x0097 => Some(0x97),
        0x0098 => Some(0x98),
        0x0099 => Some(0x99),
        0x009A => Some(0x9A),
        0x009B => Some(0x9B),
        0x009C => Some(0x9C),
        0x009D => Some(0x9D),
        0x009E => Some(0x9E),
        0x009F => Some(0x9F),
        0x00A0 => Some(0xA0),
        0x00A7 => Some(0xA7),
        0x00AD => Some(0xAD),
        0x00B0 => Some(0xB0),
        0x00B7 => Some(0xB7),
        0x00C1 => Some(0xC1),
        0x00C2 => Some(0xC2),
        0x00C3 => Some(0xC3),
        0x00C4 => Some(0xC4),
        0x00C5 => Some(0xC5),
        0x00C6 => Some(0xC6),
        0x00C9 => Some(0xC9),
        0x00CB => Some(0xCB),
        0x00CD => Some(0xCD),
        0x00CE => Some(0xCE),
        0x00CF => Some(0xCF),
        0x00D0 => Some(0xD0),
        0x00D3 => Some(0xD3),
        0x00D4 => Some(0xD4),
        0x00D5 => Some(0xD5),
        0x00D6 => Some(0xD6),
        0x00D8 => Some(0xD8),
        0x00DA => Some(0xDA),
        0x00DB => Some(0xDB),
        0x00DC => Some(0xDC),
        0x00DD => Some(0xDD),
        0x00DE => Some(0xDE),
        0x00DF => Some(0xDF),
        0x00E1 => Some(0xE1),
        0x00E2 => Some(0xE2),
        0x00E3 => Some(0xE3),
        0x00E4 => Some(0xE4),
        0x00E5 => Some(0xE5),
        0x00E6 => Some(0xE6),
        0x00E9 => Some(0xE9),
        0x00EB => Some(0xEB),
        0x00ED => Some(0xED),
        0x00EE => Some(0xEE),
        0x00EF => Some(0xEF),
        0x00F0 => Some(0xF0),
        0x00F3 => Some(0xF3),
        0x00F4 => Some(0xF4),
        0x00F5 => Some(0xF5),
        0x00F6 => Some(0xF6),
        0x00F8 => Some(0xF8),
        0x00FA => Some(0xFA),
        0x00FB => Some(0xFB),
        0x00FC => Some(0xFC),
        0x00FD => Some(0xFD),
        0x00FE => Some(0xFE),
        0x0100 => Some(0xC0),
        0x0101 => Some(0xE0),
        0x0104 => Some(0xA1),
        0x0105 => Some(0xB1),
        0x010C => Some(0xC8),
        0x010D => Some(0xE8),
        0x0110 => Some(0xA9),
        0x0111 => Some(0xB9),
        0x0112 => Some(0xA2),
        0x0113 => Some(0xB2),
        0x0116 => Some(0xCC),
        0x0117 => Some(0xEC),
        0x0118 => Some(0xCA),
        0x0119 => Some(0xEA),
        0x0122 => Some(0xA3),
        0x0123 => Some(0xB3),
        0x0128 => Some(0xA5),
        0x0129 => Some(0xB5),
        0x012A => Some(0xA4),
        0x012B => Some(0xB4),
        0x012E => Some(0xC7),
        0x012F => Some(0xE7),
        0x0136 => Some(0xA6),
        0x0137 => Some(0xB6),
        0x0138 => Some(0xFF),
        0x013B => Some(0xA8),
        0x013C => Some(0xB8),
        0x0145 => Some(0xD1),
        0x0146 => Some(0xF1),
        0x014A => Some(0xAF),
        0x014B => Some(0xBF),
        0x014C => Some(0xD2),
        0x014D => Some(0xF2),
        0x0160 => Some(0xAA),
        0x0161 => Some(0xBA),
        0x0166 => Some(0xAB),
        0x0167 => Some(0xBB),
        0x0168 => Some(0xD7),
        0x0169 => Some(0xF7),
        0x016A => Some(0xAE),
        0x016B => Some(0xBE),
        0x0172 => Some(0xD9),
        0x0173 => Some(0xF9),
        0x017D => Some(0xAC),
        0x017E => Some(0xBC),
        0x2015 => Some(0xBD),
        _ => None,
    }
}
fn encode_iso8859_15_byte(code: u32) -> Option<u8> {
    match code {
        0x0080 => Some(0x80),
        0x0081 => Some(0x81),
        0x0082 => Some(0x82),
        0x0083 => Some(0x83),
        0x0084 => Some(0x84),
        0x0085 => Some(0x85),
        0x0086 => Some(0x86),
        0x0087 => Some(0x87),
        0x0088 => Some(0x88),
        0x0089 => Some(0x89),
        0x008A => Some(0x8A),
        0x008B => Some(0x8B),
        0x008C => Some(0x8C),
        0x008D => Some(0x8D),
        0x008E => Some(0x8E),
        0x008F => Some(0x8F),
        0x0090 => Some(0x90),
        0x0091 => Some(0x91),
        0x0092 => Some(0x92),
        0x0093 => Some(0x93),
        0x0094 => Some(0x94),
        0x0095 => Some(0x95),
        0x0096 => Some(0x96),
        0x0097 => Some(0x97),
        0x0098 => Some(0x98),
        0x0099 => Some(0x99),
        0x009A => Some(0x9A),
        0x009B => Some(0x9B),
        0x009C => Some(0x9C),
        0x009D => Some(0x9D),
        0x009E => Some(0x9E),
        0x009F => Some(0x9F),
        0x00A0 => Some(0xA0),
        0x00A1 => Some(0xA1),
        0x00A2 => Some(0xA2),
        0x00A3 => Some(0xA3),
        0x00A5 => Some(0xA5),
        0x00A7 => Some(0xA7),
        0x00A9 => Some(0xA9),
        0x00AA => Some(0xAA),
        0x00AB => Some(0xAB),
        0x00AC => Some(0xAC),
        0x00AD => Some(0xAD),
        0x00AE => Some(0xAE),
        0x00AF => Some(0xAF),
        0x00B0 => Some(0xB0),
        0x00B1 => Some(0xB1),
        0x00B2 => Some(0xB2),
        0x00B3 => Some(0xB3),
        0x00B5 => Some(0xB5),
        0x00B6 => Some(0xB6),
        0x00B7 => Some(0xB7),
        0x00B9 => Some(0xB9),
        0x00BA => Some(0xBA),
        0x00BB => Some(0xBB),
        0x00BF => Some(0xBF),
        0x00C0 => Some(0xC0),
        0x00C1 => Some(0xC1),
        0x00C2 => Some(0xC2),
        0x00C3 => Some(0xC3),
        0x00C4 => Some(0xC4),
        0x00C5 => Some(0xC5),
        0x00C6 => Some(0xC6),
        0x00C7 => Some(0xC7),
        0x00C8 => Some(0xC8),
        0x00C9 => Some(0xC9),
        0x00CA => Some(0xCA),
        0x00CB => Some(0xCB),
        0x00CC => Some(0xCC),
        0x00CD => Some(0xCD),
        0x00CE => Some(0xCE),
        0x00CF => Some(0xCF),
        0x00D0 => Some(0xD0),
        0x00D1 => Some(0xD1),
        0x00D2 => Some(0xD2),
        0x00D3 => Some(0xD3),
        0x00D4 => Some(0xD4),
        0x00D5 => Some(0xD5),
        0x00D6 => Some(0xD6),
        0x00D7 => Some(0xD7),
        0x00D8 => Some(0xD8),
        0x00D9 => Some(0xD9),
        0x00DA => Some(0xDA),
        0x00DB => Some(0xDB),
        0x00DC => Some(0xDC),
        0x00DD => Some(0xDD),
        0x00DE => Some(0xDE),
        0x00DF => Some(0xDF),
        0x00E0 => Some(0xE0),
        0x00E1 => Some(0xE1),
        0x00E2 => Some(0xE2),
        0x00E3 => Some(0xE3),
        0x00E4 => Some(0xE4),
        0x00E5 => Some(0xE5),
        0x00E6 => Some(0xE6),
        0x00E7 => Some(0xE7),
        0x00E8 => Some(0xE8),
        0x00E9 => Some(0xE9),
        0x00EA => Some(0xEA),
        0x00EB => Some(0xEB),
        0x00EC => Some(0xEC),
        0x00ED => Some(0xED),
        0x00EE => Some(0xEE),
        0x00EF => Some(0xEF),
        0x00F0 => Some(0xF0),
        0x00F1 => Some(0xF1),
        0x00F2 => Some(0xF2),
        0x00F3 => Some(0xF3),
        0x00F4 => Some(0xF4),
        0x00F5 => Some(0xF5),
        0x00F6 => Some(0xF6),
        0x00F7 => Some(0xF7),
        0x00F8 => Some(0xF8),
        0x00F9 => Some(0xF9),
        0x00FA => Some(0xFA),
        0x00FB => Some(0xFB),
        0x00FC => Some(0xFC),
        0x00FD => Some(0xFD),
        0x00FE => Some(0xFE),
        0x00FF => Some(0xFF),
        0x0152 => Some(0xBC),
        0x0153 => Some(0xBD),
        0x0160 => Some(0xA6),
        0x0161 => Some(0xA8),
        0x0178 => Some(0xBE),
        0x017D => Some(0xB4),
        0x017E => Some(0xB8),
        0x20AC => Some(0xA4),
        _ => None,
    }
}

fn encode_mac_roman_byte(code: u32) -> Option<u8> {
    match code {
        0x00A0 => Some(0xCA),
        0x00A1 => Some(0xC1),
        0x00A2 => Some(0xA2),
        0x00A3 => Some(0xA3),
        0x00A5 => Some(0xB4),
        0x00A7 => Some(0xA4),
        0x00A8 => Some(0xAC),
        0x00A9 => Some(0xA9),
        0x00AA => Some(0xBB),
        0x00AB => Some(0xC7),
        0x00AC => Some(0xC2),
        0x00AE => Some(0xA8),
        0x00AF => Some(0xF8),
        0x00B0 => Some(0xA1),
        0x00B1 => Some(0xB1),
        0x00B4 => Some(0xAB),
        0x00B5 => Some(0xB5),
        0x00B6 => Some(0xA6),
        0x00B7 => Some(0xE1),
        0x00B8 => Some(0xFC),
        0x00BA => Some(0xBC),
        0x00BB => Some(0xC8),
        0x00BF => Some(0xC0),
        0x00C0 => Some(0xCB),
        0x00C1 => Some(0xE7),
        0x00C2 => Some(0xE5),
        0x00C3 => Some(0xCC),
        0x00C4 => Some(0x80),
        0x00C5 => Some(0x81),
        0x00C6 => Some(0xAE),
        0x00C7 => Some(0x82),
        0x00C8 => Some(0xE9),
        0x00C9 => Some(0x83),
        0x00CA => Some(0xE6),
        0x00CB => Some(0xE8),
        0x00CC => Some(0xED),
        0x00CD => Some(0xEA),
        0x00CE => Some(0xEB),
        0x00CF => Some(0xEC),
        0x00D1 => Some(0x84),
        0x00D2 => Some(0xF1),
        0x00D3 => Some(0xEE),
        0x00D4 => Some(0xEF),
        0x00D5 => Some(0xCD),
        0x00D6 => Some(0x85),
        0x00D8 => Some(0xAF),
        0x00D9 => Some(0xF4),
        0x00DA => Some(0xF2),
        0x00DB => Some(0xF3),
        0x00DC => Some(0x86),
        0x00DF => Some(0xA7),
        0x00E0 => Some(0x88),
        0x00E1 => Some(0x87),
        0x00E2 => Some(0x89),
        0x00E3 => Some(0x8B),
        0x00E4 => Some(0x8A),
        0x00E5 => Some(0x8C),
        0x00E6 => Some(0xBE),
        0x00E7 => Some(0x8D),
        0x00E8 => Some(0x8F),
        0x00E9 => Some(0x8E),
        0x00EA => Some(0x90),
        0x00EB => Some(0x91),
        0x00EC => Some(0x93),
        0x00ED => Some(0x92),
        0x00EE => Some(0x94),
        0x00EF => Some(0x95),
        0x00F1 => Some(0x96),
        0x00F2 => Some(0x98),
        0x00F3 => Some(0x97),
        0x00F4 => Some(0x99),
        0x00F5 => Some(0x9B),
        0x00F6 => Some(0x9A),
        0x00F7 => Some(0xD6),
        0x00F8 => Some(0xBF),
        0x00F9 => Some(0x9D),
        0x00FA => Some(0x9C),
        0x00FB => Some(0x9E),
        0x00FC => Some(0x9F),
        0x00FF => Some(0xD8),
        0x0131 => Some(0xF5),
        0x0152 => Some(0xCE),
        0x0153 => Some(0xCF),
        0x0178 => Some(0xD9),
        0x0192 => Some(0xC4),
        0x02C6 => Some(0xF6),
        0x02C7 => Some(0xFF),
        0x02D8 => Some(0xF9),
        0x02D9 => Some(0xFA),
        0x02DA => Some(0xFB),
        0x02DB => Some(0xFE),
        0x02DC => Some(0xF7),
        0x02DD => Some(0xFD),
        0x03A9 => Some(0xBD),
        0x03C0 => Some(0xB9),
        0x2013 => Some(0xD0),
        0x2014 => Some(0xD1),
        0x2018 => Some(0xD4),
        0x2019 => Some(0xD5),
        0x201A => Some(0xE2),
        0x201C => Some(0xD2),
        0x201D => Some(0xD3),
        0x201E => Some(0xE3),
        0x2020 => Some(0xA0),
        0x2021 => Some(0xE0),
        0x2022 => Some(0xA5),
        0x2026 => Some(0xC9),
        0x2030 => Some(0xE4),
        0x2039 => Some(0xDC),
        0x203A => Some(0xDD),
        0x2044 => Some(0xDA),
        0x20AC => Some(0xDB),
        0x2122 => Some(0xAA),
        0x2202 => Some(0xB6),
        0x2206 => Some(0xC6),
        0x220F => Some(0xB8),
        0x2211 => Some(0xB7),
        0x221A => Some(0xC3),
        0x221E => Some(0xB0),
        0x222B => Some(0xBA),
        0x2248 => Some(0xC5),
        0x2260 => Some(0xAD),
        0x2264 => Some(0xB2),
        0x2265 => Some(0xB3),
        0x25CA => Some(0xD7),
        0xF8FF => Some(0xF0),
        0xFB01 => Some(0xDE),
        0xFB02 => Some(0xDF),
        _ => None,
    }
}

pub(crate) fn encode_string_with_errors(
    bytes: &[u8],
    encoding: &str,
    errors: Option<&str>,
) -> Result<Vec<u8>, EncodeError> {
    let Some(kind) = normalize_encoding(encoding) else {
        return Err(EncodeError::UnknownEncoding(encoding.to_string()));
    };
    let handler = errors.unwrap_or("strict");
    let mut unknown_handler: Option<String> = None;
    let handler = match handler {
        "surrogatepass" | "strict" | "surrogateescape" | "ignore" | "replace"
        | "backslashreplace" | "namereplace" | "xmlcharrefreplace" => handler,
        other => {
            unknown_handler = Some(other.to_string());
            "strict"
        }
    };
    let error_encoding = match kind {
        EncodingKind::Utf8Sig => "utf-8",
        EncodingKind::Cp1252
        | EncodingKind::Cp437
        | EncodingKind::Cp850
        | EncodingKind::Cp860
        | EncodingKind::Cp862
        | EncodingKind::Cp863
        | EncodingKind::Cp865
        | EncodingKind::Cp866
        | EncodingKind::Cp874
        | EncodingKind::Cp1250
        | EncodingKind::Cp1251
        | EncodingKind::Cp1253
        | EncodingKind::Cp1254
        | EncodingKind::Cp1255
        | EncodingKind::Cp1256
        | EncodingKind::Cp1257
        | EncodingKind::Koi8R
        | EncodingKind::Koi8U
        | EncodingKind::Iso8859_2
        | EncodingKind::Iso8859_3
        | EncodingKind::Iso8859_4
        | EncodingKind::Iso8859_5
        | EncodingKind::Iso8859_6
        | EncodingKind::Iso8859_7
        | EncodingKind::Iso8859_8
        | EncodingKind::Iso8859_10
        | EncodingKind::Iso8859_15
        | EncodingKind::MacRoman => "charmap",
        _ => kind.name(),
    };
    let invalid_char_err =
        |encoding: &'static str, code: u32, pos: usize, limit: u32| -> EncodeError {
            if let Some(name) = unknown_handler.as_ref() {
                EncodeError::UnknownErrorHandler(name.clone())
            } else {
                EncodeError::InvalidChar {
                    encoding,
                    code,
                    pos,
                    limit,
                }
            }
        };
    let encode_charmap = |map: fn(u32) -> Option<u8>| -> Result<Vec<u8>, EncodeError> {
        let mut out = Vec::new();
        for (idx, cp) in wtf8_from_bytes(bytes).code_points().enumerate() {
            let code = cp.to_u32();
            if code <= 0x7F {
                out.push(code as u8);
                continue;
            }
            if let Some(byte) = map(code) {
                out.push(byte);
                continue;
            }
            match handler {
                "ignore" => {}
                "replace" => out.push(b'?'),
                "backslashreplace" => {
                    out.extend_from_slice(unicode_escape_codepoint(code).as_bytes());
                }
                "namereplace" => {
                    out.extend_from_slice(unicode_name_escape(code).as_bytes());
                }
                "xmlcharrefreplace" => {
                    push_xmlcharref_ascii(&mut out, code);
                }
                "surrogateescape" => {
                    if (0xDC80..=0xDCFF).contains(&code) {
                        out.push((code - 0xDC00) as u8);
                    } else {
                        return Err(invalid_char_err(error_encoding, code, idx, 0));
                    }
                }
                "surrogatepass" | "strict" => {
                    return Err(invalid_char_err(error_encoding, code, idx, 0));
                }
                other => {
                    return Err(EncodeError::UnknownErrorHandler(other.to_string()));
                }
            }
        }
        Ok(out)
    };
    let mut out = Vec::new();
    let encode_utf8 =
        |handler: &str, bytes: &[u8], out: &mut Vec<u8>| -> Result<Vec<u8>, EncodeError> {
            match handler {
                "surrogatepass" => Ok(bytes.to_vec()),
                "strict" => {
                    if !wtf8_has_surrogates(bytes) {
                        return Ok(bytes.to_vec());
                    }
                    for (idx, cp) in wtf8_from_bytes(bytes).code_points().enumerate() {
                        let code = cp.to_u32();
                        if is_surrogate(code) {
                            return Err(invalid_char_err(error_encoding, code, idx, 0x110000));
                        }
                    }
                    Ok(bytes.to_vec())
                }
                "surrogateescape" => {
                    for (idx, cp) in wtf8_from_bytes(bytes).code_points().enumerate() {
                        let code = cp.to_u32();
                        if (0xDC80..=0xDCFF).contains(&code) {
                            out.push((code - 0xDC00) as u8);
                        } else if is_surrogate(code) {
                            return Err(invalid_char_err(error_encoding, code, idx, 0x110000));
                        } else {
                            push_wtf8_codepoint(out, code);
                        }
                    }
                    Ok(std::mem::take(out))
                }
                "ignore" | "replace" | "backslashreplace" | "namereplace" | "xmlcharrefreplace" => {
                    for cp in wtf8_from_bytes(bytes).code_points() {
                        let code = cp.to_u32();
                        if is_surrogate(code) {
                            match handler {
                                "ignore" => {}
                                "replace" => out.push(b'?'),
                                "backslashreplace" => {
                                    out.extend_from_slice(unicode_escape_codepoint(code).as_bytes())
                                }
                                "namereplace" => {
                                    out.extend_from_slice(unicode_name_escape(code).as_bytes())
                                }
                                "xmlcharrefreplace" => {
                                    push_xmlcharref_ascii(out, code);
                                }
                                _ => {}
                            }
                            continue;
                        }
                        push_wtf8_codepoint(out, code);
                    }
                    Ok(std::mem::take(out))
                }
                other => Err(EncodeError::UnknownErrorHandler(other.to_string())),
            }
        };
    match kind {
        EncodingKind::Utf8 => encode_utf8(handler, bytes, &mut out),
        EncodingKind::Utf8Sig => {
            let encoded = encode_utf8(handler, bytes, &mut out)?;
            let mut with_bom = Vec::with_capacity(encoded.len() + 3);
            with_bom.extend_from_slice(&[0xEF, 0xBB, 0xBF]);
            with_bom.extend_from_slice(&encoded);
            Ok(with_bom)
        }
        EncodingKind::Cp1252 => encode_charmap(encode_cp1252_byte),
        EncodingKind::Cp437 => encode_charmap(encode_cp437_byte),
        EncodingKind::Cp850 => encode_charmap(encode_cp850_byte),
        EncodingKind::Cp860 => encode_charmap(encode_cp860_byte),
        EncodingKind::Cp862 => encode_charmap(encode_cp862_byte),
        EncodingKind::Cp863 => encode_charmap(encode_cp863_byte),
        EncodingKind::Cp865 => encode_charmap(encode_cp865_byte),
        EncodingKind::Cp866 => encode_charmap(encode_cp866_byte),
        EncodingKind::Cp874 => encode_charmap(encode_cp874_byte),
        EncodingKind::Cp1250 => encode_charmap(encode_cp1250_byte),
        EncodingKind::Cp1251 => encode_charmap(encode_cp1251_byte),
        EncodingKind::Cp1253 => encode_charmap(encode_cp1253_byte),
        EncodingKind::Cp1254 => encode_charmap(encode_cp1254_byte),
        EncodingKind::Cp1255 => encode_charmap(encode_cp1255_byte),
        EncodingKind::Cp1256 => encode_charmap(encode_cp1256_byte),
        EncodingKind::Cp1257 => encode_charmap(encode_cp1257_byte),
        EncodingKind::Koi8R => encode_charmap(encode_koi8_r_byte),
        EncodingKind::Koi8U => encode_charmap(encode_koi8_u_byte),
        EncodingKind::Iso8859_2 => encode_charmap(encode_iso8859_2_byte),
        EncodingKind::Iso8859_3 => encode_charmap(encode_iso8859_3_byte),
        EncodingKind::Iso8859_4 => encode_charmap(encode_iso8859_4_byte),
        EncodingKind::Iso8859_5 => encode_charmap(encode_iso8859_5_byte),
        EncodingKind::Iso8859_6 => encode_charmap(encode_iso8859_6_byte),
        EncodingKind::Iso8859_7 => encode_charmap(encode_iso8859_7_byte),
        EncodingKind::Iso8859_8 => encode_charmap(encode_iso8859_8_byte),
        EncodingKind::Iso8859_10 => encode_charmap(encode_iso8859_10_byte),
        EncodingKind::Iso8859_15 => encode_charmap(encode_iso8859_15_byte),
        EncodingKind::MacRoman => encode_charmap(encode_mac_roman_byte),
        EncodingKind::Latin1 | EncodingKind::Ascii => {
            let limit = kind.ordinal_limit();
            for (idx, cp) in wtf8_from_bytes(bytes).code_points().enumerate() {
                let code = cp.to_u32();
                if code < limit {
                    out.push(code as u8);
                    continue;
                }
                match handler {
                    "ignore" => {}
                    "replace" => out.push(b'?'),
                    "backslashreplace" => {
                        out.extend_from_slice(unicode_escape_codepoint(code).as_bytes());
                    }
                    "namereplace" => {
                        out.extend_from_slice(unicode_name_escape(code).as_bytes());
                    }
                    "xmlcharrefreplace" => {
                        push_xmlcharref_ascii(&mut out, code);
                    }
                    "surrogateescape" => {
                        if (0xDC80..=0xDCFF).contains(&code) {
                            out.push((code - 0xDC00) as u8);
                        } else {
                            return Err(invalid_char_err(error_encoding, code, idx, limit));
                        }
                    }
                    "surrogatepass" | "strict" => {
                        return Err(invalid_char_err(error_encoding, code, idx, limit));
                    }
                    other => {
                        return Err(EncodeError::UnknownErrorHandler(other.to_string()));
                    }
                }
            }
            Ok(out)
        }
        EncodingKind::UnicodeEscape => {
            for cp in wtf8_from_bytes(bytes).code_points() {
                let code = cp.to_u32();
                match code {
                    0x5C => out.extend_from_slice(b"\\\\"),
                    0x09 => out.extend_from_slice(b"\\t"),
                    0x0A => out.extend_from_slice(b"\\n"),
                    0x0D => out.extend_from_slice(b"\\r"),
                    0x20..=0x7E => out.push(code as u8),
                    _ if code <= 0xFF => push_hex_escape(&mut out, b'x', code, 2),
                    _ if code <= 0xFFFF => push_hex_escape(&mut out, b'u', code, 4),
                    _ => push_hex_escape(&mut out, b'U', code, 8),
                }
            }
            Ok(out)
        }
        EncodingKind::Utf16 | EncodingKind::Utf16LE | EncodingKind::Utf16BE => {
            let (endian, with_bom) = match kind {
                EncodingKind::Utf16 => (native_endian(), true),
                EncodingKind::Utf16LE => (Endian::Little, false),
                EncodingKind::Utf16BE => (Endian::Big, false),
                _ => (native_endian(), false),
            };
            if with_bom {
                push_u16(&mut out, 0xFEFF, endian);
            }
            for (idx, cp) in wtf8_from_bytes(bytes).code_points().enumerate() {
                let code = cp.to_u32();
                if is_surrogate(code) {
                    match handler {
                        "surrogatepass" | "surrogateescape" => {
                            push_u16(&mut out, code as u16, endian);
                            continue;
                        }
                        "ignore" => continue,
                        "replace" => {
                            push_u16(&mut out, 0xFFFD, endian);
                            continue;
                        }
                        "backslashreplace" => {
                            for ch in unicode_escape_codepoint(code).chars() {
                                push_u16(&mut out, ch as u16, endian);
                            }
                            continue;
                        }
                        "namereplace" => {
                            for ch in unicode_name_escape(code).chars() {
                                push_u16(&mut out, ch as u16, endian);
                            }
                            continue;
                        }
                        "xmlcharrefreplace" => {
                            push_xmlcharref_utf16(&mut out, code, endian);
                            continue;
                        }
                        "strict" => {
                            return Err(invalid_char_err(error_encoding, code, idx, 0x110000));
                        }
                        other => {
                            return Err(EncodeError::UnknownErrorHandler(other.to_string()));
                        }
                    }
                }
                if code <= 0xFFFF {
                    push_u16(&mut out, code as u16, endian);
                } else {
                    let val = code - 0x10000;
                    let high = 0xD800 | ((val >> 10) as u16);
                    let low = 0xDC00 | ((val & 0x3FF) as u16);
                    push_u16(&mut out, high, endian);
                    push_u16(&mut out, low, endian);
                }
            }
            Ok(out)
        }
        EncodingKind::Utf32 | EncodingKind::Utf32LE | EncodingKind::Utf32BE => {
            let (endian, with_bom) = match kind {
                EncodingKind::Utf32 => (native_endian(), true),
                EncodingKind::Utf32LE => (Endian::Little, false),
                EncodingKind::Utf32BE => (Endian::Big, false),
                _ => (native_endian(), false),
            };
            if with_bom {
                push_u32(&mut out, 0x0000_FEFF, endian);
            }
            for (idx, cp) in wtf8_from_bytes(bytes).code_points().enumerate() {
                let code = cp.to_u32();
                if is_surrogate(code) {
                    match handler {
                        "surrogatepass" | "surrogateescape" => {
                            push_u32(&mut out, code, endian);
                            continue;
                        }
                        "ignore" => continue,
                        "replace" => {
                            push_u32(&mut out, 0xFFFD, endian);
                            continue;
                        }
                        "backslashreplace" => {
                            for ch in unicode_escape_codepoint(code).chars() {
                                push_u32(&mut out, ch as u32, endian);
                            }
                            continue;
                        }
                        "namereplace" => {
                            for ch in unicode_name_escape(code).chars() {
                                push_u32(&mut out, ch as u32, endian);
                            }
                            continue;
                        }
                        "xmlcharrefreplace" => {
                            push_xmlcharref_utf32(&mut out, code, endian);
                            continue;
                        }
                        "strict" => {
                            return Err(invalid_char_err(kind.name(), code, idx, 0x110000));
                        }
                        other => {
                            return Err(EncodeError::UnknownErrorHandler(other.to_string()));
                        }
                    }
                }
                push_u32(&mut out, code, endian);
            }
            Ok(out)
        }
    }
}

fn decode_error_byte(label: &str, byte: u8, pos: usize, message: &str) -> String {
    format!("'{label}' codec can't decode byte 0x{byte:02x} in position {pos}: {message}")
}

fn decode_error_range(label: &str, start: usize, end: usize, message: &str) -> String {
    format!("'{label}' codec can't decode bytes in position {start}-{end}: {message}")
}

fn read_u16(bytes: &[u8], idx: usize, endian: Endian) -> u16 {
    match endian {
        Endian::Little => u16::from_le_bytes([bytes[idx], bytes[idx + 1]]),
        Endian::Big => u16::from_be_bytes([bytes[idx], bytes[idx + 1]]),
    }
}

fn read_u32(bytes: &[u8], idx: usize, endian: Endian) -> u32 {
    match endian {
        Endian::Little => {
            u32::from_le_bytes([bytes[idx], bytes[idx + 1], bytes[idx + 2], bytes[idx + 3]])
        }
        Endian::Big => {
            u32::from_be_bytes([bytes[idx], bytes[idx + 1], bytes[idx + 2], bytes[idx + 3]])
        }
    }
}

fn decode_ascii_with_errors(bytes: &[u8], errors: &str) -> Result<Vec<u8>, DecodeFailure> {
    let mut out = Vec::with_capacity(bytes.len());
    for (idx, &byte) in bytes.iter().enumerate() {
        if byte <= 0x7f {
            out.push(byte);
            continue;
        }
        match errors {
            "ignore" => {}
            "replace" => push_wtf8_codepoint(&mut out, 0xFFFD),
            "backslashreplace" => push_backslash_bytes_vec(&mut out, &[byte]),
            "surrogateescape" => push_wtf8_codepoint(&mut out, 0xDC00 + byte as u32),
            "strict" | "surrogatepass" => {
                return Err(DecodeFailure::Byte {
                    pos: idx,
                    byte,
                    message: "ordinal not in range(128)",
                });
            }
            other => {
                return Err(DecodeFailure::UnknownErrorHandler(other.to_string()));
            }
        }
    }
    Ok(out)
}

const CP1252_DECODE_TABLE: [u16; 32] = [
    0x20AC, 0xFFFF, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021, 0x02C6, 0x2030, 0x0160, 0x2039,
    0x0152, 0xFFFF, 0x017D, 0xFFFF, 0xFFFF, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
    0x02DC, 0x2122, 0x0161, 0x203A, 0x0153, 0xFFFF, 0x017E, 0x0178,
];

const CP437_DECODE_TABLE: [u16; 128] = [
    0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7, 0x00EA, 0x00EB, 0x00E8, 0x00EF,
    0x00EE, 0x00EC, 0x00C4, 0x00C5, 0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9,
    0x00FF, 0x00D6, 0x00DC, 0x00A2, 0x00A3, 0x00A5, 0x20A7, 0x0192, 0x00E1, 0x00ED, 0x00F3, 0x00FA,
    0x00F1, 0x00D1, 0x00AA, 0x00BA, 0x00BF, 0x2310, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
    0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,
    0x255D, 0x255C, 0x255B, 0x2510, 0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F,
    0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,
    0x2558, 0x2552, 0x2553, 0x256B, 0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
    0x03B1, 0x00DF, 0x0393, 0x03C0, 0x03A3, 0x03C3, 0x00B5, 0x03C4, 0x03A6, 0x0398, 0x03A9, 0x03B4,
    0x221E, 0x03C6, 0x03B5, 0x2229, 0x2261, 0x00B1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00F7, 0x2248,
    0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0,
];

const CP850_DECODE_TABLE: [u16; 128] = [
    0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7, 0x00EA, 0x00EB, 0x00E8, 0x00EF,
    0x00EE, 0x00EC, 0x00C4, 0x00C5, 0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9,
    0x00FF, 0x00D6, 0x00DC, 0x00F8, 0x00A3, 0x00D8, 0x00D7, 0x0192, 0x00E1, 0x00ED, 0x00F3, 0x00FA,
    0x00F1, 0x00D1, 0x00AA, 0x00BA, 0x00BF, 0x00AE, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
    0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00C1, 0x00C2, 0x00C0, 0x00A9, 0x2563, 0x2551, 0x2557,
    0x255D, 0x00A2, 0x00A5, 0x2510, 0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x00E3, 0x00C3,
    0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x00A4, 0x00F0, 0x00D0, 0x00CA, 0x00CB,
    0x00C8, 0x0131, 0x00CD, 0x00CE, 0x00CF, 0x2518, 0x250C, 0x2588, 0x2584, 0x00A6, 0x00CC, 0x2580,
    0x00D3, 0x00DF, 0x00D4, 0x00D2, 0x00F5, 0x00D5, 0x00B5, 0x00FE, 0x00DE, 0x00DA, 0x00DB, 0x00D9,
    0x00FD, 0x00DD, 0x00AF, 0x00B4, 0x00AD, 0x00B1, 0x2017, 0x00BE, 0x00B6, 0x00A7, 0x00F7, 0x00B8,
    0x00B0, 0x00A8, 0x00B7, 0x00B9, 0x00B3, 0x00B2, 0x25A0, 0x00A0,
];

const CP865_DECODE_TABLE: [u16; 128] = [
    0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7, 0x00EA, 0x00EB, 0x00E8, 0x00EF,
    0x00EE, 0x00EC, 0x00C4, 0x00C5, 0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9,
    0x00FF, 0x00D6, 0x00DC, 0x00F8, 0x00A3, 0x00D8, 0x20A7, 0x0192, 0x00E1, 0x00ED, 0x00F3, 0x00FA,
    0x00F1, 0x00D1, 0x00AA, 0x00BA, 0x00BF, 0x2310, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00A4,
    0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,
    0x255D, 0x255C, 0x255B, 0x2510, 0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F,
    0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,
    0x2558, 0x2552, 0x2553, 0x256B, 0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
    0x03B1, 0x00DF, 0x0393, 0x03C0, 0x03A3, 0x03C3, 0x00B5, 0x03C4, 0x03A6, 0x0398, 0x03A9, 0x03B4,
    0x221E, 0x03C6, 0x03B5, 0x2229, 0x2261, 0x00B1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00F7, 0x2248,
    0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0,
];

const CP866_DECODE_TABLE: [u16; 128] = [
    0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417, 0x0418, 0x0419, 0x041A, 0x041B,
    0x041C, 0x041D, 0x041E, 0x041F, 0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427,
    0x0428, 0x0429, 0x042A, 0x042B, 0x042C, 0x042D, 0x042E, 0x042F, 0x0430, 0x0431, 0x0432, 0x0433,
    0x0434, 0x0435, 0x0436, 0x0437, 0x0438, 0x0439, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F,
    0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,
    0x255D, 0x255C, 0x255B, 0x2510, 0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F,
    0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,
    0x2558, 0x2552, 0x2553, 0x256B, 0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
    0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447, 0x0448, 0x0449, 0x044A, 0x044B,
    0x044C, 0x044D, 0x044E, 0x044F, 0x0401, 0x0451, 0x0404, 0x0454, 0x0407, 0x0457, 0x040E, 0x045E,
    0x00B0, 0x2219, 0x00B7, 0x221A, 0x2116, 0x00A4, 0x25A0, 0x00A0,
];

const CP874_DECODE_TABLE: [u16; 128] = [
    0x20AC, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x2026, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
    0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
    0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x00A0, 0x0E01, 0x0E02, 0x0E03,
    0x0E04, 0x0E05, 0x0E06, 0x0E07, 0x0E08, 0x0E09, 0x0E0A, 0x0E0B, 0x0E0C, 0x0E0D, 0x0E0E, 0x0E0F,
    0x0E10, 0x0E11, 0x0E12, 0x0E13, 0x0E14, 0x0E15, 0x0E16, 0x0E17, 0x0E18, 0x0E19, 0x0E1A, 0x0E1B,
    0x0E1C, 0x0E1D, 0x0E1E, 0x0E1F, 0x0E20, 0x0E21, 0x0E22, 0x0E23, 0x0E24, 0x0E25, 0x0E26, 0x0E27,
    0x0E28, 0x0E29, 0x0E2A, 0x0E2B, 0x0E2C, 0x0E2D, 0x0E2E, 0x0E2F, 0x0E30, 0x0E31, 0x0E32, 0x0E33,
    0x0E34, 0x0E35, 0x0E36, 0x0E37, 0x0E38, 0x0E39, 0x0E3A, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0E3F,
    0x0E40, 0x0E41, 0x0E42, 0x0E43, 0x0E44, 0x0E45, 0x0E46, 0x0E47, 0x0E48, 0x0E49, 0x0E4A, 0x0E4B,
    0x0E4C, 0x0E4D, 0x0E4E, 0x0E4F, 0x0E50, 0x0E51, 0x0E52, 0x0E53, 0x0E54, 0x0E55, 0x0E56, 0x0E57,
    0x0E58, 0x0E59, 0x0E5A, 0x0E5B, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
];

const CP1250_DECODE_TABLE: [u16; 128] = [
    0x20AC, 0xFFFF, 0x201A, 0xFFFF, 0x201E, 0x2026, 0x2020, 0x2021, 0xFFFF, 0x2030, 0x0160, 0x2039,
    0x015A, 0x0164, 0x017D, 0x0179, 0xFFFF, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
    0xFFFF, 0x2122, 0x0161, 0x203A, 0x015B, 0x0165, 0x017E, 0x017A, 0x00A0, 0x02C7, 0x02D8, 0x0141,
    0x00A4, 0x0104, 0x00A6, 0x00A7, 0x00A8, 0x00A9, 0x015E, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x017B,
    0x00B0, 0x00B1, 0x02DB, 0x0142, 0x00B4, 0x00B5, 0x00B6, 0x00B7, 0x00B8, 0x0105, 0x015F, 0x00BB,
    0x013D, 0x02DD, 0x013E, 0x017C, 0x0154, 0x00C1, 0x00C2, 0x0102, 0x00C4, 0x0139, 0x0106, 0x00C7,
    0x010C, 0x00C9, 0x0118, 0x00CB, 0x011A, 0x00CD, 0x00CE, 0x010E, 0x0110, 0x0143, 0x0147, 0x00D3,
    0x00D4, 0x0150, 0x00D6, 0x00D7, 0x0158, 0x016E, 0x00DA, 0x0170, 0x00DC, 0x00DD, 0x0162, 0x00DF,
    0x0155, 0x00E1, 0x00E2, 0x0103, 0x00E4, 0x013A, 0x0107, 0x00E7, 0x010D, 0x00E9, 0x0119, 0x00EB,
    0x011B, 0x00ED, 0x00EE, 0x010F, 0x0111, 0x0144, 0x0148, 0x00F3, 0x00F4, 0x0151, 0x00F6, 0x00F7,
    0x0159, 0x016F, 0x00FA, 0x0171, 0x00FC, 0x00FD, 0x0163, 0x02D9,
];

const CP1251_DECODE_TABLE: [u16; 128] = [
    0x0402, 0x0403, 0x201A, 0x0453, 0x201E, 0x2026, 0x2020, 0x2021, 0x20AC, 0x2030, 0x0409, 0x2039,
    0x040A, 0x040C, 0x040B, 0x040F, 0x0452, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
    0xFFFF, 0x2122, 0x0459, 0x203A, 0x045A, 0x045C, 0x045B, 0x045F, 0x00A0, 0x040E, 0x045E, 0x0408,
    0x00A4, 0x0490, 0x00A6, 0x00A7, 0x0401, 0x00A9, 0x0404, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x0407,
    0x00B0, 0x00B1, 0x0406, 0x0456, 0x0491, 0x00B5, 0x00B6, 0x00B7, 0x0451, 0x2116, 0x0454, 0x00BB,
    0x0458, 0x0405, 0x0455, 0x0457, 0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417,
    0x0418, 0x0419, 0x041A, 0x041B, 0x041C, 0x041D, 0x041E, 0x041F, 0x0420, 0x0421, 0x0422, 0x0423,
    0x0424, 0x0425, 0x0426, 0x0427, 0x0428, 0x0429, 0x042A, 0x042B, 0x042C, 0x042D, 0x042E, 0x042F,
    0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437, 0x0438, 0x0439, 0x043A, 0x043B,
    0x043C, 0x043D, 0x043E, 0x043F, 0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447,
    0x0448, 0x0449, 0x044A, 0x044B, 0x044C, 0x044D, 0x044E, 0x044F,
];

const CP860_DECODE_TABLE: [u16; 128] = [
    0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E3, 0x00E0, 0x00C1, 0x00E7, 0x00EA, 0x00CA, 0x00E8, 0x00CD,
    0x00D4, 0x00EC, 0x00C3, 0x00C2, 0x00C9, 0x00C0, 0x00C8, 0x00F4, 0x00F5, 0x00F2, 0x00DA, 0x00F9,
    0x00CC, 0x00D5, 0x00DC, 0x00A2, 0x00A3, 0x00D9, 0x20A7, 0x00D3, 0x00E1, 0x00ED, 0x00F3, 0x00FA,
    0x00F1, 0x00D1, 0x00AA, 0x00BA, 0x00BF, 0x00D2, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
    0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,
    0x255D, 0x255C, 0x255B, 0x2510, 0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F,
    0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,
    0x2558, 0x2552, 0x2553, 0x256B, 0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
    0x03B1, 0x00DF, 0x0393, 0x03C0, 0x03A3, 0x03C3, 0x00B5, 0x03C4, 0x03A6, 0x0398, 0x03A9, 0x03B4,
    0x221E, 0x03C6, 0x03B5, 0x2229, 0x2261, 0x00B1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00F7, 0x2248,
    0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0,
];
const CP862_DECODE_TABLE: [u16; 128] = [
    0x05D0, 0x05D1, 0x05D2, 0x05D3, 0x05D4, 0x05D5, 0x05D6, 0x05D7, 0x05D8, 0x05D9, 0x05DA, 0x05DB,
    0x05DC, 0x05DD, 0x05DE, 0x05DF, 0x05E0, 0x05E1, 0x05E2, 0x05E3, 0x05E4, 0x05E5, 0x05E6, 0x05E7,
    0x05E8, 0x05E9, 0x05EA, 0x00A2, 0x00A3, 0x00A5, 0x20A7, 0x0192, 0x00E1, 0x00ED, 0x00F3, 0x00FA,
    0x00F1, 0x00D1, 0x00AA, 0x00BA, 0x00BF, 0x2310, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
    0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,
    0x255D, 0x255C, 0x255B, 0x2510, 0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F,
    0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,
    0x2558, 0x2552, 0x2553, 0x256B, 0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
    0x03B1, 0x00DF, 0x0393, 0x03C0, 0x03A3, 0x03C3, 0x00B5, 0x03C4, 0x03A6, 0x0398, 0x03A9, 0x03B4,
    0x221E, 0x03C6, 0x03B5, 0x2229, 0x2261, 0x00B1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00F7, 0x2248,
    0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0,
];
const CP863_DECODE_TABLE: [u16; 128] = [
    0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00C2, 0x00E0, 0x00B6, 0x00E7, 0x00EA, 0x00EB, 0x00E8, 0x00EF,
    0x00EE, 0x2017, 0x00C0, 0x00A7, 0x00C9, 0x00C8, 0x00CA, 0x00F4, 0x00CB, 0x00CF, 0x00FB, 0x00F9,
    0x00A4, 0x00D4, 0x00DC, 0x00A2, 0x00A3, 0x00D9, 0x00DB, 0x0192, 0x00A6, 0x00B4, 0x00F3, 0x00FA,
    0x00A8, 0x00B8, 0x00B3, 0x00AF, 0x00CE, 0x2310, 0x00AC, 0x00BD, 0x00BC, 0x00BE, 0x00AB, 0x00BB,
    0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,
    0x255D, 0x255C, 0x255B, 0x2510, 0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F,
    0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,
    0x2558, 0x2552, 0x2553, 0x256B, 0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
    0x03B1, 0x00DF, 0x0393, 0x03C0, 0x03A3, 0x03C3, 0x00B5, 0x03C4, 0x03A6, 0x0398, 0x03A9, 0x03B4,
    0x221E, 0x03C6, 0x03B5, 0x2229, 0x2261, 0x00B1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00F7, 0x2248,
    0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0,
];
const CP1253_DECODE_TABLE: [u16; 128] = [
    0x20AC, 0xFFFF, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021, 0xFFFF, 0x2030, 0xFFFF, 0x2039,
    0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
    0xFFFF, 0x2122, 0xFFFF, 0x203A, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x00A0, 0x0385, 0x0386, 0x00A3,
    0x00A4, 0x00A5, 0x00A6, 0x00A7, 0x00A8, 0x00A9, 0xFFFF, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x2015,
    0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x0384, 0x00B5, 0x00B6, 0x00B7, 0x0388, 0x0389, 0x038A, 0x00BB,
    0x038C, 0x00BD, 0x038E, 0x038F, 0x0390, 0x0391, 0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397,
    0x0398, 0x0399, 0x039A, 0x039B, 0x039C, 0x039D, 0x039E, 0x039F, 0x03A0, 0x03A1, 0xFFFF, 0x03A3,
    0x03A4, 0x03A5, 0x03A6, 0x03A7, 0x03A8, 0x03A9, 0x03AA, 0x03AB, 0x03AC, 0x03AD, 0x03AE, 0x03AF,
    0x03B0, 0x03B1, 0x03B2, 0x03B3, 0x03B4, 0x03B5, 0x03B6, 0x03B7, 0x03B8, 0x03B9, 0x03BA, 0x03BB,
    0x03BC, 0x03BD, 0x03BE, 0x03BF, 0x03C0, 0x03C1, 0x03C2, 0x03C3, 0x03C4, 0x03C5, 0x03C6, 0x03C7,
    0x03C8, 0x03C9, 0x03CA, 0x03CB, 0x03CC, 0x03CD, 0x03CE, 0xFFFF,
];
const CP1254_DECODE_TABLE: [u16; 128] = [
    0x20AC, 0xFFFF, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021, 0x02C6, 0x2030, 0x0160, 0x2039,
    0x0152, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
    0x02DC, 0x2122, 0x0161, 0x203A, 0x0153, 0xFFFF, 0xFFFF, 0x0178, 0x00A0, 0x00A1, 0x00A2, 0x00A3,
    0x00A4, 0x00A5, 0x00A6, 0x00A7, 0x00A8, 0x00A9, 0x00AA, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF,
    0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7, 0x00B8, 0x00B9, 0x00BA, 0x00BB,
    0x00BC, 0x00BD, 0x00BE, 0x00BF, 0x00C0, 0x00C1, 0x00C2, 0x00C3, 0x00C4, 0x00C5, 0x00C6, 0x00C7,
    0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x00CC, 0x00CD, 0x00CE, 0x00CF, 0x011E, 0x00D1, 0x00D2, 0x00D3,
    0x00D4, 0x00D5, 0x00D6, 0x00D7, 0x00D8, 0x00D9, 0x00DA, 0x00DB, 0x00DC, 0x0130, 0x015E, 0x00DF,
    0x00E0, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x00E7, 0x00E8, 0x00E9, 0x00EA, 0x00EB,
    0x00EC, 0x00ED, 0x00EE, 0x00EF, 0x011F, 0x00F1, 0x00F2, 0x00F3, 0x00F4, 0x00F5, 0x00F6, 0x00F7,
    0x00F8, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x0131, 0x015F, 0x00FF,
];
const CP1255_DECODE_TABLE: [u16; 128] = [
    0x20AC, 0xFFFF, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021, 0x02C6, 0x2030, 0xFFFF, 0x2039,
    0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
    0x02DC, 0x2122, 0xFFFF, 0x203A, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x00A0, 0x00A1, 0x00A2, 0x00A3,
    0x20AA, 0x00A5, 0x00A6, 0x00A7, 0x00A8, 0x00A9, 0x00D7, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF,
    0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7, 0x00B8, 0x00B9, 0x00F7, 0x00BB,
    0x00BC, 0x00BD, 0x00BE, 0x00BF, 0x05B0, 0x05B1, 0x05B2, 0x05B3, 0x05B4, 0x05B5, 0x05B6, 0x05B7,
    0x05B8, 0x05B9, 0xFFFF, 0x05BB, 0x05BC, 0x05BD, 0x05BE, 0x05BF, 0x05C0, 0x05C1, 0x05C2, 0x05C3,
    0x05F0, 0x05F1, 0x05F2, 0x05F3, 0x05F4, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
    0x05D0, 0x05D1, 0x05D2, 0x05D3, 0x05D4, 0x05D5, 0x05D6, 0x05D7, 0x05D8, 0x05D9, 0x05DA, 0x05DB,
    0x05DC, 0x05DD, 0x05DE, 0x05DF, 0x05E0, 0x05E1, 0x05E2, 0x05E3, 0x05E4, 0x05E5, 0x05E6, 0x05E7,
    0x05E8, 0x05E9, 0x05EA, 0xFFFF, 0xFFFF, 0x200E, 0x200F, 0xFFFF,
];
const CP1256_DECODE_TABLE: [u16; 128] = [
    0x20AC, 0x067E, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021, 0x02C6, 0x2030, 0x0679, 0x2039,
    0x0152, 0x0686, 0x0698, 0x0688, 0x06AF, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
    0x06A9, 0x2122, 0x0691, 0x203A, 0x0153, 0x200C, 0x200D, 0x06BA, 0x00A0, 0x060C, 0x00A2, 0x00A3,
    0x00A4, 0x00A5, 0x00A6, 0x00A7, 0x00A8, 0x00A9, 0x06BE, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF,
    0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7, 0x00B8, 0x00B9, 0x061B, 0x00BB,
    0x00BC, 0x00BD, 0x00BE, 0x061F, 0x06C1, 0x0621, 0x0622, 0x0623, 0x0624, 0x0625, 0x0626, 0x0627,
    0x0628, 0x0629, 0x062A, 0x062B, 0x062C, 0x062D, 0x062E, 0x062F, 0x0630, 0x0631, 0x0632, 0x0633,
    0x0634, 0x0635, 0x0636, 0x00D7, 0x0637, 0x0638, 0x0639, 0x063A, 0x0640, 0x0641, 0x0642, 0x0643,
    0x00E0, 0x0644, 0x00E2, 0x0645, 0x0646, 0x0647, 0x0648, 0x00E7, 0x00E8, 0x00E9, 0x00EA, 0x00EB,
    0x0649, 0x064A, 0x00EE, 0x00EF, 0x064B, 0x064C, 0x064D, 0x064E, 0x00F4, 0x064F, 0x0650, 0x00F7,
    0x0651, 0x00F9, 0x0652, 0x00FB, 0x00FC, 0x200E, 0x200F, 0x06D2,
];
const CP1257_DECODE_TABLE: [u16; 128] = [
    0x20AC, 0xFFFF, 0x201A, 0xFFFF, 0x201E, 0x2026, 0x2020, 0x2021, 0xFFFF, 0x2030, 0xFFFF, 0x2039,
    0xFFFF, 0x00A8, 0x02C7, 0x00B8, 0xFFFF, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
    0xFFFF, 0x2122, 0xFFFF, 0x203A, 0xFFFF, 0x00AF, 0x02DB, 0xFFFF, 0x00A0, 0xFFFF, 0x00A2, 0x00A3,
    0x00A4, 0xFFFF, 0x00A6, 0x00A7, 0x00D8, 0x00A9, 0x0156, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00C6,
    0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7, 0x00F8, 0x00B9, 0x0157, 0x00BB,
    0x00BC, 0x00BD, 0x00BE, 0x00E6, 0x0104, 0x012E, 0x0100, 0x0106, 0x00C4, 0x00C5, 0x0118, 0x0112,
    0x010C, 0x00C9, 0x0179, 0x0116, 0x0122, 0x0136, 0x012A, 0x013B, 0x0160, 0x0143, 0x0145, 0x00D3,
    0x014C, 0x00D5, 0x00D6, 0x00D7, 0x0172, 0x0141, 0x015A, 0x016A, 0x00DC, 0x017B, 0x017D, 0x00DF,
    0x0105, 0x012F, 0x0101, 0x0107, 0x00E4, 0x00E5, 0x0119, 0x0113, 0x010D, 0x00E9, 0x017A, 0x0117,
    0x0123, 0x0137, 0x012B, 0x013C, 0x0161, 0x0144, 0x0146, 0x00F3, 0x014D, 0x00F5, 0x00F6, 0x00F7,
    0x0173, 0x0142, 0x015B, 0x016B, 0x00FC, 0x017C, 0x017E, 0x02D9,
];
const KOI8_R_DECODE_TABLE: [u16; 128] = [
    0x2500, 0x2502, 0x250C, 0x2510, 0x2514, 0x2518, 0x251C, 0x2524, 0x252C, 0x2534, 0x253C, 0x2580,
    0x2584, 0x2588, 0x258C, 0x2590, 0x2591, 0x2592, 0x2593, 0x2320, 0x25A0, 0x2219, 0x221A, 0x2248,
    0x2264, 0x2265, 0x00A0, 0x2321, 0x00B0, 0x00B2, 0x00B7, 0x00F7, 0x2550, 0x2551, 0x2552, 0x0451,
    0x2553, 0x2554, 0x2555, 0x2556, 0x2557, 0x2558, 0x2559, 0x255A, 0x255B, 0x255C, 0x255D, 0x255E,
    0x255F, 0x2560, 0x2561, 0x0401, 0x2562, 0x2563, 0x2564, 0x2565, 0x2566, 0x2567, 0x2568, 0x2569,
    0x256A, 0x256B, 0x256C, 0x00A9, 0x044E, 0x0430, 0x0431, 0x0446, 0x0434, 0x0435, 0x0444, 0x0433,
    0x0445, 0x0438, 0x0439, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F, 0x044F, 0x0440, 0x0441,
    0x0442, 0x0443, 0x0436, 0x0432, 0x044C, 0x044B, 0x0437, 0x0448, 0x044D, 0x0449, 0x0447, 0x044A,
    0x042E, 0x0410, 0x0411, 0x0426, 0x0414, 0x0415, 0x0424, 0x0413, 0x0425, 0x0418, 0x0419, 0x041A,
    0x041B, 0x041C, 0x041D, 0x041E, 0x041F, 0x042F, 0x0420, 0x0421, 0x0422, 0x0423, 0x0416, 0x0412,
    0x042C, 0x042B, 0x0417, 0x0428, 0x042D, 0x0429, 0x0427, 0x042A,
];

const KOI8_U_DECODE_TABLE: [u16; 128] = [
    0x2500, 0x2502, 0x250C, 0x2510, 0x2514, 0x2518, 0x251C, 0x2524, 0x252C, 0x2534, 0x253C, 0x2580,
    0x2584, 0x2588, 0x258C, 0x2590, 0x2591, 0x2592, 0x2593, 0x2320, 0x25A0, 0x2219, 0x221A, 0x2248,
    0x2264, 0x2265, 0x00A0, 0x2321, 0x00B0, 0x00B2, 0x00B7, 0x00F7, 0x2550, 0x2551, 0x2552, 0x0451,
    0x0454, 0x2554, 0x0456, 0x0457, 0x2557, 0x2558, 0x2559, 0x255A, 0x255B, 0x0491, 0x255D, 0x255E,
    0x255F, 0x2560, 0x2561, 0x0401, 0x0404, 0x2563, 0x0406, 0x0407, 0x2566, 0x2567, 0x2568, 0x2569,
    0x256A, 0x0490, 0x256C, 0x00A9, 0x044E, 0x0430, 0x0431, 0x0446, 0x0434, 0x0435, 0x0444, 0x0433,
    0x0445, 0x0438, 0x0439, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F, 0x044F, 0x0440, 0x0441,
    0x0442, 0x0443, 0x0436, 0x0432, 0x044C, 0x044B, 0x0437, 0x0448, 0x044D, 0x0449, 0x0447, 0x044A,
    0x042E, 0x0410, 0x0411, 0x0426, 0x0414, 0x0415, 0x0424, 0x0413, 0x0425, 0x0418, 0x0419, 0x041A,
    0x041B, 0x041C, 0x041D, 0x041E, 0x041F, 0x042F, 0x0420, 0x0421, 0x0422, 0x0423, 0x0416, 0x0412,
    0x042C, 0x042B, 0x0417, 0x0428, 0x042D, 0x0429, 0x0427, 0x042A,
];

const ISO8859_2_DECODE_TABLE: [u16; 128] = [
    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008A, 0x008B,
    0x008C, 0x008D, 0x008E, 0x008F, 0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
    0x0098, 0x0099, 0x009A, 0x009B, 0x009C, 0x009D, 0x009E, 0x009F, 0x00A0, 0x0104, 0x02D8, 0x0141,
    0x00A4, 0x013D, 0x015A, 0x00A7, 0x00A8, 0x0160, 0x015E, 0x0164, 0x0179, 0x00AD, 0x017D, 0x017B,
    0x00B0, 0x0105, 0x02DB, 0x0142, 0x00B4, 0x013E, 0x015B, 0x02C7, 0x00B8, 0x0161, 0x015F, 0x0165,
    0x017A, 0x02DD, 0x017E, 0x017C, 0x0154, 0x00C1, 0x00C2, 0x0102, 0x00C4, 0x0139, 0x0106, 0x00C7,
    0x010C, 0x00C9, 0x0118, 0x00CB, 0x011A, 0x00CD, 0x00CE, 0x010E, 0x0110, 0x0143, 0x0147, 0x00D3,
    0x00D4, 0x0150, 0x00D6, 0x00D7, 0x0158, 0x016E, 0x00DA, 0x0170, 0x00DC, 0x00DD, 0x0162, 0x00DF,
    0x0155, 0x00E1, 0x00E2, 0x0103, 0x00E4, 0x013A, 0x0107, 0x00E7, 0x010D, 0x00E9, 0x0119, 0x00EB,
    0x011B, 0x00ED, 0x00EE, 0x010F, 0x0111, 0x0144, 0x0148, 0x00F3, 0x00F4, 0x0151, 0x00F6, 0x00F7,
    0x0159, 0x016F, 0x00FA, 0x0171, 0x00FC, 0x00FD, 0x0163, 0x02D9,
];

const ISO8859_3_DECODE_TABLE: [u16; 128] = [
    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008A, 0x008B,
    0x008C, 0x008D, 0x008E, 0x008F, 0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
    0x0098, 0x0099, 0x009A, 0x009B, 0x009C, 0x009D, 0x009E, 0x009F, 0x00A0, 0x0126, 0x02D8, 0x00A3,
    0x00A4, 0xFFFF, 0x0124, 0x00A7, 0x00A8, 0x0130, 0x015E, 0x011E, 0x0134, 0x00AD, 0xFFFF, 0x017B,
    0x00B0, 0x0127, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x0125, 0x00B7, 0x00B8, 0x0131, 0x015F, 0x011F,
    0x0135, 0x00BD, 0xFFFF, 0x017C, 0x00C0, 0x00C1, 0x00C2, 0xFFFF, 0x00C4, 0x010A, 0x0108, 0x00C7,
    0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x00CC, 0x00CD, 0x00CE, 0x00CF, 0xFFFF, 0x00D1, 0x00D2, 0x00D3,
    0x00D4, 0x0120, 0x00D6, 0x00D7, 0x011C, 0x00D9, 0x00DA, 0x00DB, 0x00DC, 0x016C, 0x015C, 0x00DF,
    0x00E0, 0x00E1, 0x00E2, 0xFFFF, 0x00E4, 0x010B, 0x0109, 0x00E7, 0x00E8, 0x00E9, 0x00EA, 0x00EB,
    0x00EC, 0x00ED, 0x00EE, 0x00EF, 0xFFFF, 0x00F1, 0x00F2, 0x00F3, 0x00F4, 0x0121, 0x00F6, 0x00F7,
    0x011D, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x016D, 0x015D, 0x02D9,
];
const ISO8859_4_DECODE_TABLE: [u16; 128] = [
    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008A, 0x008B,
    0x008C, 0x008D, 0x008E, 0x008F, 0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
    0x0098, 0x0099, 0x009A, 0x009B, 0x009C, 0x009D, 0x009E, 0x009F, 0x00A0, 0x0104, 0x0138, 0x0156,
    0x00A4, 0x0128, 0x013B, 0x00A7, 0x00A8, 0x0160, 0x0112, 0x0122, 0x0166, 0x00AD, 0x017D, 0x00AF,
    0x00B0, 0x0105, 0x02DB, 0x0157, 0x00B4, 0x0129, 0x013C, 0x02C7, 0x00B8, 0x0161, 0x0113, 0x0123,
    0x0167, 0x014A, 0x017E, 0x014B, 0x0100, 0x00C1, 0x00C2, 0x00C3, 0x00C4, 0x00C5, 0x00C6, 0x012E,
    0x010C, 0x00C9, 0x0118, 0x00CB, 0x0116, 0x00CD, 0x00CE, 0x012A, 0x0110, 0x0145, 0x014C, 0x0136,
    0x00D4, 0x00D5, 0x00D6, 0x00D7, 0x00D8, 0x0172, 0x00DA, 0x00DB, 0x00DC, 0x0168, 0x016A, 0x00DF,
    0x0101, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x012F, 0x010D, 0x00E9, 0x0119, 0x00EB,
    0x0117, 0x00ED, 0x00EE, 0x012B, 0x0111, 0x0146, 0x014D, 0x0137, 0x00F4, 0x00F5, 0x00F6, 0x00F7,
    0x00F8, 0x0173, 0x00FA, 0x00FB, 0x00FC, 0x0169, 0x016B, 0x02D9,
];
const ISO8859_5_DECODE_TABLE: [u16; 128] = [
    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008A, 0x008B,
    0x008C, 0x008D, 0x008E, 0x008F, 0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
    0x0098, 0x0099, 0x009A, 0x009B, 0x009C, 0x009D, 0x009E, 0x009F, 0x00A0, 0x0401, 0x0402, 0x0403,
    0x0404, 0x0405, 0x0406, 0x0407, 0x0408, 0x0409, 0x040A, 0x040B, 0x040C, 0x00AD, 0x040E, 0x040F,
    0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417, 0x0418, 0x0419, 0x041A, 0x041B,
    0x041C, 0x041D, 0x041E, 0x041F, 0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427,
    0x0428, 0x0429, 0x042A, 0x042B, 0x042C, 0x042D, 0x042E, 0x042F, 0x0430, 0x0431, 0x0432, 0x0433,
    0x0434, 0x0435, 0x0436, 0x0437, 0x0438, 0x0439, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F,
    0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447, 0x0448, 0x0449, 0x044A, 0x044B,
    0x044C, 0x044D, 0x044E, 0x044F, 0x2116, 0x0451, 0x0452, 0x0453, 0x0454, 0x0455, 0x0456, 0x0457,
    0x0458, 0x0459, 0x045A, 0x045B, 0x045C, 0x00A7, 0x045E, 0x045F,
];

const ISO8859_6_DECODE_TABLE: [u16; 128] = [
    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008A, 0x008B,
    0x008C, 0x008D, 0x008E, 0x008F, 0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
    0x0098, 0x0099, 0x009A, 0x009B, 0x009C, 0x009D, 0x009E, 0x009F, 0x00A0, 0xFFFF, 0xFFFF, 0xFFFF,
    0x00A4, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x060C, 0x00AD, 0xFFFF, 0xFFFF,
    0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x061B,
    0xFFFF, 0xFFFF, 0xFFFF, 0x061F, 0xFFFF, 0x0621, 0x0622, 0x0623, 0x0624, 0x0625, 0x0626, 0x0627,
    0x0628, 0x0629, 0x062A, 0x062B, 0x062C, 0x062D, 0x062E, 0x062F, 0x0630, 0x0631, 0x0632, 0x0633,
    0x0634, 0x0635, 0x0636, 0x0637, 0x0638, 0x0639, 0x063A, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
    0x0640, 0x0641, 0x0642, 0x0643, 0x0644, 0x0645, 0x0646, 0x0647, 0x0648, 0x0649, 0x064A, 0x064B,
    0x064C, 0x064D, 0x064E, 0x064F, 0x0650, 0x0651, 0x0652, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
    0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
];
const ISO8859_7_DECODE_TABLE: [u16; 128] = [
    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008A, 0x008B,
    0x008C, 0x008D, 0x008E, 0x008F, 0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
    0x0098, 0x0099, 0x009A, 0x009B, 0x009C, 0x009D, 0x009E, 0x009F, 0x00A0, 0x2018, 0x2019, 0x00A3,
    0x20AC, 0x20AF, 0x00A6, 0x00A7, 0x00A8, 0x00A9, 0x037A, 0x00AB, 0x00AC, 0x00AD, 0xFFFF, 0x2015,
    0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x0384, 0x0385, 0x0386, 0x00B7, 0x0388, 0x0389, 0x038A, 0x00BB,
    0x038C, 0x00BD, 0x038E, 0x038F, 0x0390, 0x0391, 0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397,
    0x0398, 0x0399, 0x039A, 0x039B, 0x039C, 0x039D, 0x039E, 0x039F, 0x03A0, 0x03A1, 0xFFFF, 0x03A3,
    0x03A4, 0x03A5, 0x03A6, 0x03A7, 0x03A8, 0x03A9, 0x03AA, 0x03AB, 0x03AC, 0x03AD, 0x03AE, 0x03AF,
    0x03B0, 0x03B1, 0x03B2, 0x03B3, 0x03B4, 0x03B5, 0x03B6, 0x03B7, 0x03B8, 0x03B9, 0x03BA, 0x03BB,
    0x03BC, 0x03BD, 0x03BE, 0x03BF, 0x03C0, 0x03C1, 0x03C2, 0x03C3, 0x03C4, 0x03C5, 0x03C6, 0x03C7,
    0x03C8, 0x03C9, 0x03CA, 0x03CB, 0x03CC, 0x03CD, 0x03CE, 0xFFFF,
];

const ISO8859_8_DECODE_TABLE: [u16; 128] = [
    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008A, 0x008B,
    0x008C, 0x008D, 0x008E, 0x008F, 0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
    0x0098, 0x0099, 0x009A, 0x009B, 0x009C, 0x009D, 0x009E, 0x009F, 0x00A0, 0xFFFF, 0x00A2, 0x00A3,
    0x00A4, 0x00A5, 0x00A6, 0x00A7, 0x00A8, 0x00A9, 0x00D7, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF,
    0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7, 0x00B8, 0x00B9, 0x00F7, 0x00BB,
    0x00BC, 0x00BD, 0x00BE, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
    0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
    0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x2017,
    0x05D0, 0x05D1, 0x05D2, 0x05D3, 0x05D4, 0x05D5, 0x05D6, 0x05D7, 0x05D8, 0x05D9, 0x05DA, 0x05DB,
    0x05DC, 0x05DD, 0x05DE, 0x05DF, 0x05E0, 0x05E1, 0x05E2, 0x05E3, 0x05E4, 0x05E5, 0x05E6, 0x05E7,
    0x05E8, 0x05E9, 0x05EA, 0xFFFF, 0xFFFF, 0x200E, 0x200F, 0xFFFF,
];
const ISO8859_10_DECODE_TABLE: [u16; 128] = [
    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008A, 0x008B,
    0x008C, 0x008D, 0x008E, 0x008F, 0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
    0x0098, 0x0099, 0x009A, 0x009B, 0x009C, 0x009D, 0x009E, 0x009F, 0x00A0, 0x0104, 0x0112, 0x0122,
    0x012A, 0x0128, 0x0136, 0x00A7, 0x013B, 0x0110, 0x0160, 0x0166, 0x017D, 0x00AD, 0x016A, 0x014A,
    0x00B0, 0x0105, 0x0113, 0x0123, 0x012B, 0x0129, 0x0137, 0x00B7, 0x013C, 0x0111, 0x0161, 0x0167,
    0x017E, 0x2015, 0x016B, 0x014B, 0x0100, 0x00C1, 0x00C2, 0x00C3, 0x00C4, 0x00C5, 0x00C6, 0x012E,
    0x010C, 0x00C9, 0x0118, 0x00CB, 0x0116, 0x00CD, 0x00CE, 0x00CF, 0x00D0, 0x0145, 0x014C, 0x00D3,
    0x00D4, 0x00D5, 0x00D6, 0x0168, 0x00D8, 0x0172, 0x00DA, 0x00DB, 0x00DC, 0x00DD, 0x00DE, 0x00DF,
    0x0101, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x012F, 0x010D, 0x00E9, 0x0119, 0x00EB,
    0x0117, 0x00ED, 0x00EE, 0x00EF, 0x00F0, 0x0146, 0x014D, 0x00F3, 0x00F4, 0x00F5, 0x00F6, 0x0169,
    0x00F8, 0x0173, 0x00FA, 0x00FB, 0x00FC, 0x00FD, 0x00FE, 0x0138,
];
const ISO8859_15_DECODE_TABLE: [u16; 128] = [
    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087, 0x0088, 0x0089, 0x008A, 0x008B,
    0x008C, 0x008D, 0x008E, 0x008F, 0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
    0x0098, 0x0099, 0x009A, 0x009B, 0x009C, 0x009D, 0x009E, 0x009F, 0x00A0, 0x00A1, 0x00A2, 0x00A3,
    0x20AC, 0x00A5, 0x0160, 0x00A7, 0x0161, 0x00A9, 0x00AA, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF,
    0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x017D, 0x00B5, 0x00B6, 0x00B7, 0x017E, 0x00B9, 0x00BA, 0x00BB,
    0x0152, 0x0153, 0x0178, 0x00BF, 0x00C0, 0x00C1, 0x00C2, 0x00C3, 0x00C4, 0x00C5, 0x00C6, 0x00C7,
    0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x00CC, 0x00CD, 0x00CE, 0x00CF, 0x00D0, 0x00D1, 0x00D2, 0x00D3,
    0x00D4, 0x00D5, 0x00D6, 0x00D7, 0x00D8, 0x00D9, 0x00DA, 0x00DB, 0x00DC, 0x00DD, 0x00DE, 0x00DF,
    0x00E0, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x00E7, 0x00E8, 0x00E9, 0x00EA, 0x00EB,
    0x00EC, 0x00ED, 0x00EE, 0x00EF, 0x00F0, 0x00F1, 0x00F2, 0x00F3, 0x00F4, 0x00F5, 0x00F6, 0x00F7,
    0x00F8, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x00FD, 0x00FE, 0x00FF,
];

const MAC_ROMAN_DECODE_TABLE: [u16; 128] = [
    0x00C4, 0x00C5, 0x00C7, 0x00C9, 0x00D1, 0x00D6, 0x00DC, 0x00E1, 0x00E0, 0x00E2, 0x00E4, 0x00E3,
    0x00E5, 0x00E7, 0x00E9, 0x00E8, 0x00EA, 0x00EB, 0x00ED, 0x00EC, 0x00EE, 0x00EF, 0x00F1, 0x00F3,
    0x00F2, 0x00F4, 0x00F6, 0x00F5, 0x00FA, 0x00F9, 0x00FB, 0x00FC, 0x2020, 0x00B0, 0x00A2, 0x00A3,
    0x00A7, 0x2022, 0x00B6, 0x00DF, 0x00AE, 0x00A9, 0x2122, 0x00B4, 0x00A8, 0x2260, 0x00C6, 0x00D8,
    0x221E, 0x00B1, 0x2264, 0x2265, 0x00A5, 0x00B5, 0x2202, 0x2211, 0x220F, 0x03C0, 0x222B, 0x00AA,
    0x00BA, 0x03A9, 0x00E6, 0x00F8, 0x00BF, 0x00A1, 0x00AC, 0x221A, 0x0192, 0x2248, 0x2206, 0x00AB,
    0x00BB, 0x2026, 0x00A0, 0x00C0, 0x00C3, 0x00D5, 0x0152, 0x0153, 0x2013, 0x2014, 0x201C, 0x201D,
    0x2018, 0x2019, 0x00F7, 0x25CA, 0x00FF, 0x0178, 0x2044, 0x20AC, 0x2039, 0x203A, 0xFB01, 0xFB02,
    0x2021, 0x00B7, 0x201A, 0x201E, 0x2030, 0x00C2, 0x00CA, 0x00C1, 0x00CB, 0x00C8, 0x00CD, 0x00CE,
    0x00CF, 0x00CC, 0x00D3, 0x00D4, 0xF8FF, 0x00D2, 0x00DA, 0x00DB, 0x00D9, 0x0131, 0x02C6, 0x02DC,
    0x00AF, 0x02D8, 0x02D9, 0x02DA, 0x00B8, 0x02DD, 0x02DB, 0x02C7,
];

fn cp1252_decode_byte(byte: u8) -> Option<u32> {
    if byte <= 0x7F || byte >= 0xA0 {
        return Some(byte as u32);
    }
    let idx = (byte - 0x80) as usize;
    let code = CP1252_DECODE_TABLE[idx];
    if code == 0xFFFF {
        None
    } else {
        Some(code as u32)
    }
}

fn decode_cp1252_with_errors(bytes: &[u8], errors: &str) -> Result<Vec<u8>, DecodeFailure> {
    let mut out = Vec::with_capacity(bytes.len());
    for (idx, &byte) in bytes.iter().enumerate() {
        if let Some(code) = cp1252_decode_byte(byte) {
            push_wtf8_codepoint(&mut out, code);
            continue;
        }
        match errors {
            "ignore" => {}
            "replace" => push_wtf8_codepoint(&mut out, 0xFFFD),
            "backslashreplace" => push_backslash_bytes_vec(&mut out, &[byte]),
            "surrogateescape" => push_wtf8_codepoint(&mut out, 0xDC00 + byte as u32),
            "strict" | "surrogatepass" => {
                return Err(DecodeFailure::Byte {
                    pos: idx,
                    byte,
                    message: "character maps to <undefined>",
                });
            }
            other => {
                return Err(DecodeFailure::UnknownErrorHandler(other.to_string()));
            }
        }
    }
    Ok(out)
}

fn decode_charmap_with_errors(
    bytes: &[u8],
    errors: &str,
    table: &[u16; 128],
) -> Result<Vec<u8>, DecodeFailure> {
    let mut out = Vec::with_capacity(bytes.len());
    for (idx, &byte) in bytes.iter().enumerate() {
        if byte <= 0x7F {
            out.push(byte);
            continue;
        }
        let code = table[(byte - 0x80) as usize];
        if code != 0xFFFF {
            push_wtf8_codepoint(&mut out, code as u32);
            continue;
        }
        match errors {
            "ignore" => {}
            "replace" => push_wtf8_codepoint(&mut out, 0xFFFD),
            "backslashreplace" => push_backslash_bytes_vec(&mut out, &[byte]),
            "surrogateescape" => push_wtf8_codepoint(&mut out, 0xDC00 + byte as u32),
            "strict" | "surrogatepass" => {
                return Err(DecodeFailure::Byte {
                    pos: idx,
                    byte,
                    message: "character maps to <undefined>",
                });
            }
            other => {
                return Err(DecodeFailure::UnknownErrorHandler(other.to_string()));
            }
        }
    }
    Ok(out)
}

fn decode_utf8_bytes_with_errors(bytes: &[u8], errors: &str) -> Result<Vec<u8>, DecodeFailure> {
    let mut out = Vec::with_capacity(bytes.len());
    let mut idx = 0usize;
    let allow_surrogates = errors == "surrogatepass";
    while idx < bytes.len() {
        let first = bytes[idx];
        if first < 0x80 {
            out.push(first);
            idx += 1;
            continue;
        }
        if first < 0xC0 {
            decode_utf8_invalid_byte(errors, &mut out, idx, first)?;
            idx += 1;
            continue;
        }
        let (needed, min_code) = if first < 0xE0 {
            (1usize, 0x80u32)
        } else if first < 0xF0 {
            (2usize, 0x800u32)
        } else if first < 0xF8 {
            (3usize, 0x10000u32)
        } else {
            decode_utf8_invalid_byte(errors, &mut out, idx, first)?;
            idx += 1;
            continue;
        };
        if idx + needed >= bytes.len() {
            decode_utf8_invalid_byte(errors, &mut out, idx, first)?;
            idx += 1;
            continue;
        }
        let mut code: u32 = (first & (0x7F >> needed)) as u32;
        let mut ok = true;
        for off in 1..=needed {
            let byte = bytes[idx + off];
            if (byte & 0xC0) != 0x80 {
                ok = false;
                break;
            }
            code = (code << 6) | (byte & 0x3F) as u32;
        }
        if !ok || code < min_code || code > 0x10FFFF {
            decode_utf8_invalid_byte(errors, &mut out, idx, first)?;
            idx += 1;
            continue;
        }
        if is_surrogate(code) && !allow_surrogates {
            decode_utf8_invalid_byte(errors, &mut out, idx, first)?;
            idx += 1;
            continue;
        }
        push_wtf8_codepoint(&mut out, code);
        idx += needed + 1;
    }
    Ok(out)
}

fn decode_utf8_invalid_byte(
    errors: &str,
    out: &mut Vec<u8>,
    pos: usize,
    byte: u8,
) -> Result<(), DecodeFailure> {
    match errors {
        "ignore" => Ok(()),
        "replace" => {
            push_wtf8_codepoint(out, 0xFFFD);
            Ok(())
        }
        "backslashreplace" => {
            push_backslash_bytes_vec(out, &[byte]);
            Ok(())
        }
        "surrogateescape" => {
            push_wtf8_codepoint(out, 0xDC00 + byte as u32);
            Ok(())
        }
        "strict" | "surrogatepass" => Err(DecodeFailure::Byte {
            pos,
            byte,
            message: "invalid start byte",
        }),
        other => Err(DecodeFailure::UnknownErrorHandler(other.to_string())),
    }
}

fn hex_value(byte: u8) -> Option<u32> {
    match byte {
        b'0'..=b'9' => Some((byte - b'0') as u32),
        b'a'..=b'f' => Some((byte - b'a' + 10) as u32),
        b'A'..=b'F' => Some((byte - b'A' + 10) as u32),
        _ => None,
    }
}

fn parse_hex_prefix(bytes: &[u8], max: usize) -> (u32, usize) {
    let mut value = 0u32;
    let mut count = 0usize;
    for &byte in bytes.iter().take(max) {
        let Some(digit) = hex_value(byte) else {
            break;
        };
        value = (value << 4) | digit;
        count += 1;
    }
    (value, count)
}

fn parse_octal_prefix(bytes: &[u8], max: usize) -> (u32, usize) {
    let mut value = 0u32;
    let mut count = 0usize;
    for &byte in bytes.iter().take(max) {
        if !(b'0'..=b'7').contains(&byte) {
            break;
        }
        value = (value << 3) | (byte - b'0') as u32;
        count += 1;
    }
    (value, count)
}

fn handle_unicode_escape_failure(
    errors: &str,
    out: &mut Vec<u8>,
    bytes: &[u8],
    start: usize,
    end: usize,
    failure: DecodeFailure,
) -> Result<usize, DecodeFailure> {
    match errors {
        "ignore" => Ok(end + 1),
        "replace" => {
            push_wtf8_codepoint(out, 0xFFFD);
            Ok(end + 1)
        }
        "backslashreplace" => {
            if start <= end && end < bytes.len() {
                push_backslash_bytes_vec(out, &bytes[start..=end]);
            }
            Ok(end + 1)
        }
        "strict" | "surrogatepass" | "surrogateescape" => Err(failure),
        other => Err(DecodeFailure::UnknownErrorHandler(other.to_string())),
    }
}

fn decode_unicode_escape_with_errors(bytes: &[u8], errors: &str) -> Result<Vec<u8>, DecodeFailure> {
    const TRUNC_X: &str = "truncated \\xXX escape";
    const TRUNC_U: &str = "truncated \\uXXXX escape";
    const TRUNC_U8: &str = "truncated \\UXXXXXXXX escape";
    const MALFORMED_N: &str = "malformed \\N character escape";
    const UNKNOWN_NAME: &str = "unknown Unicode character name";
    const ILLEGAL_UNICODE: &str = "illegal Unicode character";
    const TRAILING_SLASH: &str = "\\ at end of string";

    let mut out = Vec::with_capacity(bytes.len());
    let mut idx = 0usize;
    while idx < bytes.len() {
        let byte = bytes[idx];
        if byte != b'\\' {
            push_wtf8_codepoint(&mut out, byte as u32);
            idx += 1;
            continue;
        }
        if idx + 1 >= bytes.len() {
            let failure = DecodeFailure::Byte {
                pos: idx,
                byte,
                message: TRAILING_SLASH,
            };
            idx = handle_unicode_escape_failure(errors, &mut out, bytes, idx, idx, failure)?;
            continue;
        }
        let esc = bytes[idx + 1];
        match esc {
            b'\\' => {
                push_wtf8_codepoint(&mut out, b'\\' as u32);
                idx += 2;
            }
            b'\'' => {
                push_wtf8_codepoint(&mut out, b'\'' as u32);
                idx += 2;
            }
            b'"' => {
                push_wtf8_codepoint(&mut out, b'"' as u32);
                idx += 2;
            }
            b'a' => {
                push_wtf8_codepoint(&mut out, 0x07);
                idx += 2;
            }
            b'b' => {
                push_wtf8_codepoint(&mut out, 0x08);
                idx += 2;
            }
            b't' => {
                push_wtf8_codepoint(&mut out, 0x09);
                idx += 2;
            }
            b'n' => {
                push_wtf8_codepoint(&mut out, 0x0A);
                idx += 2;
            }
            b'v' => {
                push_wtf8_codepoint(&mut out, 0x0B);
                idx += 2;
            }
            b'f' => {
                push_wtf8_codepoint(&mut out, 0x0C);
                idx += 2;
            }
            b'r' => {
                push_wtf8_codepoint(&mut out, 0x0D);
                idx += 2;
            }
            b'\n' => {
                idx += 2;
            }
            b'x' => {
                let (value, count) = parse_hex_prefix(&bytes[idx + 2..], 2);
                if count < 2 {
                    let end = idx + 1 + count;
                    let failure = DecodeFailure::Range {
                        start: idx,
                        end,
                        message: TRUNC_X,
                    };
                    idx =
                        handle_unicode_escape_failure(errors, &mut out, bytes, idx, end, failure)?;
                    continue;
                }
                push_wtf8_codepoint(&mut out, value);
                idx += 4;
            }
            b'u' => {
                let (value, count) = parse_hex_prefix(&bytes[idx + 2..], 4);
                if count < 4 {
                    let end = idx + 1 + count;
                    let failure = DecodeFailure::Range {
                        start: idx,
                        end,
                        message: TRUNC_U,
                    };
                    idx =
                        handle_unicode_escape_failure(errors, &mut out, bytes, idx, end, failure)?;
                    continue;
                }
                push_wtf8_codepoint(&mut out, value);
                idx += 6;
            }
            b'U' => {
                let (value, count) = parse_hex_prefix(&bytes[idx + 2..], 8);
                if count < 8 {
                    let end = idx + 1 + count;
                    let failure = DecodeFailure::Range {
                        start: idx,
                        end,
                        message: TRUNC_U8,
                    };
                    idx =
                        handle_unicode_escape_failure(errors, &mut out, bytes, idx, end, failure)?;
                    continue;
                }
                if value > 0x10FFFF {
                    let end = idx + 9;
                    let failure = DecodeFailure::Range {
                        start: idx,
                        end,
                        message: ILLEGAL_UNICODE,
                    };
                    idx =
                        handle_unicode_escape_failure(errors, &mut out, bytes, idx, end, failure)?;
                    continue;
                }
                push_wtf8_codepoint(&mut out, value);
                idx += 10;
            }
            b'N' => {
                if idx + 2 >= bytes.len() || bytes[idx + 2] != b'{' {
                    let end = usize::min(idx + 1, bytes.len() - 1);
                    let failure = DecodeFailure::Range {
                        start: idx,
                        end,
                        message: MALFORMED_N,
                    };
                    idx =
                        handle_unicode_escape_failure(errors, &mut out, bytes, idx, end, failure)?;
                    continue;
                }
                let close = bytes[idx + 3..]
                    .iter()
                    .position(|&ch| ch == b'}')
                    .map(|offset| idx + 3 + offset);
                let Some(close_idx) = close else {
                    let end = bytes.len() - 1;
                    let failure = DecodeFailure::Range {
                        start: idx,
                        end,
                        message: MALFORMED_N,
                    };
                    idx =
                        handle_unicode_escape_failure(errors, &mut out, bytes, idx, end, failure)?;
                    continue;
                };
                let name_bytes = &bytes[idx + 3..close_idx];
                let name = std::str::from_utf8(name_bytes).unwrap_or("");
                if let Some(ch) = unicode_names2::character(name) {
                    push_wtf8_codepoint(&mut out, ch as u32);
                    idx = close_idx + 1;
                } else {
                    let failure = DecodeFailure::Range {
                        start: idx,
                        end: close_idx,
                        message: UNKNOWN_NAME,
                    };
                    idx = handle_unicode_escape_failure(
                        errors, &mut out, bytes, idx, close_idx, failure,
                    )?;
                }
            }
            b'0'..=b'7' => {
                let (value, count) = parse_octal_prefix(&bytes[idx + 1..], 3);
                push_wtf8_codepoint(&mut out, value);
                idx += 1 + count;
            }
            _ => {
                push_wtf8_codepoint(&mut out, b'\\' as u32);
                push_wtf8_codepoint(&mut out, esc as u32);
                idx += 2;
            }
        }
    }
    Ok(out)
}

fn utf16_decode_config(bytes: &[u8], kind: EncodingKind) -> (Endian, String, usize) {
    match kind {
        EncodingKind::Utf16 => {
            if bytes.len() >= 2 {
                if bytes[0] == 0xFF && bytes[1] == 0xFE {
                    return (Endian::Little, "utf-16-le".to_string(), 2);
                }
                if bytes[0] == 0xFE && bytes[1] == 0xFF {
                    return (Endian::Big, "utf-16-be".to_string(), 2);
                }
            }
            let endian = native_endian();
            let label = match endian {
                Endian::Little => "utf-16-le".to_string(),
                Endian::Big => "utf-16-be".to_string(),
            };
            (endian, label, 0)
        }
        EncodingKind::Utf16LE => (Endian::Little, "utf-16-le".to_string(), 0),
        EncodingKind::Utf16BE => (Endian::Big, "utf-16-be".to_string(), 0),
        _ => (native_endian(), "utf-16-le".to_string(), 0),
    }
}

fn decode_utf16_with_errors(
    bytes: &[u8],
    errors: &str,
    endian: Endian,
    offset: usize,
) -> Result<Vec<u8>, DecodeFailure> {
    let data = if offset > 0 { &bytes[offset..] } else { bytes };
    let mut out = Vec::new();
    let mut idx = 0usize;
    while idx + 1 < data.len() {
        let unit = read_u16(data, idx, endian);
        if (0xD800..=0xDBFF).contains(&unit) {
            if idx + 3 >= data.len() {
                match errors {
                    "surrogatepass" | "surrogateescape" => {
                        push_wtf8_codepoint(&mut out, unit as u32);
                    }
                    "ignore" => {}
                    "replace" => push_wtf8_codepoint(&mut out, 0xFFFD),
                    "backslashreplace" => {
                        push_backslash_bytes_vec(&mut out, &data[idx..]);
                    }
                    "strict" => {
                        return Err(DecodeFailure::Range {
                            start: offset + idx,
                            end: offset + data.len() - 1,
                            message: "unexpected end of data",
                        });
                    }
                    other => {
                        return Err(DecodeFailure::UnknownErrorHandler(other.to_string()));
                    }
                }
                // Avoid double-applying trailing bytes in the post-loop remainder handler.
                idx = data.len();
                break;
            }
            let next = read_u16(data, idx + 2, endian);
            if (0xDC00..=0xDFFF).contains(&next) {
                let high = (unit as u32) - 0xD800;
                let low = (next as u32) - 0xDC00;
                let code = 0x10000 + ((high << 10) | low);
                push_wtf8_codepoint(&mut out, code);
                idx += 4;
                continue;
            }
            match errors {
                "surrogatepass" | "surrogateescape" => {
                    push_wtf8_codepoint(&mut out, unit as u32);
                }
                "ignore" => {}
                "replace" => push_wtf8_codepoint(&mut out, 0xFFFD),
                "backslashreplace" => {
                    push_backslash_bytes_vec(&mut out, &data[idx..idx + 2]);
                }
                "strict" => {
                    return Err(DecodeFailure::Range {
                        start: offset + idx,
                        end: offset + idx + 1,
                        message: "illegal UTF-16 surrogate",
                    });
                }
                other => {
                    return Err(DecodeFailure::UnknownErrorHandler(other.to_string()));
                }
            }
            idx += 2;
            continue;
        }
        if (0xDC00..=0xDFFF).contains(&unit) {
            match errors {
                "surrogatepass" | "surrogateescape" => {
                    push_wtf8_codepoint(&mut out, unit as u32);
                }
                "ignore" => {}
                "replace" => push_wtf8_codepoint(&mut out, 0xFFFD),
                "backslashreplace" => {
                    push_backslash_bytes_vec(&mut out, &data[idx..idx + 2]);
                }
                "strict" => {
                    return Err(DecodeFailure::Range {
                        start: offset + idx,
                        end: offset + idx + 1,
                        message: "illegal encoding",
                    });
                }
                other => {
                    return Err(DecodeFailure::UnknownErrorHandler(other.to_string()));
                }
            }
            idx += 2;
            continue;
        }
        push_wtf8_codepoint(&mut out, unit as u32);
        idx += 2;
    }
    if idx < data.len() {
        match errors {
            "surrogatepass" | "surrogateescape" => {
                push_wtf8_codepoint(&mut out, data[idx] as u32);
            }
            "ignore" => {}
            "replace" => push_wtf8_codepoint(&mut out, 0xFFFD),
            "backslashreplace" => {
                push_backslash_bytes_vec(&mut out, &data[idx..]);
            }
            "strict" => {
                let pos = offset + data.len() - 1;
                let byte = data[data.len() - 1];
                return Err(DecodeFailure::Byte {
                    pos,
                    byte,
                    message: "truncated data",
                });
            }
            other => {
                return Err(DecodeFailure::UnknownErrorHandler(other.to_string()));
            }
        }
    }
    Ok(out)
}

fn utf32_decode_config(bytes: &[u8], kind: EncodingKind) -> (Endian, String, usize) {
    match kind {
        EncodingKind::Utf32 => {
            if bytes.len() >= 4 {
                if bytes[0] == 0xFF && bytes[1] == 0xFE && bytes[2] == 0x00 && bytes[3] == 0x00 {
                    return (Endian::Little, "utf-32-le".to_string(), 4);
                }
                if bytes[0] == 0x00 && bytes[1] == 0x00 && bytes[2] == 0xFE && bytes[3] == 0xFF {
                    return (Endian::Big, "utf-32-be".to_string(), 4);
                }
            }
            let endian = native_endian();
            let label = match endian {
                Endian::Little => "utf-32-le".to_string(),
                Endian::Big => "utf-32-be".to_string(),
            };
            (endian, label, 0)
        }
        EncodingKind::Utf32LE => (Endian::Little, "utf-32-le".to_string(), 0),
        EncodingKind::Utf32BE => (Endian::Big, "utf-32-be".to_string(), 0),
        _ => (native_endian(), "utf-32-le".to_string(), 0),
    }
}

fn decode_utf32_with_errors(
    bytes: &[u8],
    errors: &str,
    endian: Endian,
    offset: usize,
) -> Result<Vec<u8>, DecodeFailure> {
    let data = if offset > 0 { &bytes[offset..] } else { bytes };
    let mut out = Vec::new();
    let mut idx = 0usize;
    while idx + 3 < data.len() {
        let code = read_u32(data, idx, endian);
        if is_surrogate(code) {
            match errors {
                "surrogatepass" | "surrogateescape" => {
                    push_wtf8_codepoint(&mut out, code);
                }
                "ignore" => {}
                "replace" => push_wtf8_codepoint(&mut out, 0xFFFD),
                "backslashreplace" => {
                    push_backslash_bytes_vec(&mut out, &data[idx..idx + 4]);
                }
                "strict" => {
                    return Err(DecodeFailure::Range {
                        start: offset + idx,
                        end: offset + idx + 3,
                        message: "code point in surrogate code point range(0xd800, 0xe000)",
                    });
                }
                other => {
                    return Err(DecodeFailure::UnknownErrorHandler(other.to_string()));
                }
            }
            idx += 4;
            continue;
        }
        if code > 0x10FFFF {
            match errors {
                "ignore" => {}
                "replace" => push_wtf8_codepoint(&mut out, 0xFFFD),
                "backslashreplace" => {
                    push_backslash_bytes_vec(&mut out, &data[idx..idx + 4]);
                }
                "strict" | "surrogatepass" | "surrogateescape" => {
                    return Err(DecodeFailure::Range {
                        start: offset + idx,
                        end: offset + idx + 3,
                        message: "code point not in range(0x110000)",
                    });
                }
                other => {
                    return Err(DecodeFailure::UnknownErrorHandler(other.to_string()));
                }
            }
            idx += 4;
            continue;
        }
        push_wtf8_codepoint(&mut out, code);
        idx += 4;
    }
    if idx < data.len() {
        match errors {
            "surrogatepass" | "surrogateescape" => {
                for &byte in &data[idx..] {
                    push_wtf8_codepoint(&mut out, 0xDC00 + byte as u32);
                }
            }
            "ignore" => {}
            "replace" => push_wtf8_codepoint(&mut out, 0xFFFD),
            "backslashreplace" => {
                push_backslash_bytes_vec(&mut out, &data[idx..]);
            }
            "strict" => {
                return Err(DecodeFailure::Range {
                    start: offset + idx,
                    end: offset + data.len() - 1,
                    message: "truncated data",
                });
            }
            other => {
                return Err(DecodeFailure::UnknownErrorHandler(other.to_string()));
            }
        }
    }
    Ok(out)
}

fn decode_bytes_with_errors(
    bytes: &[u8],
    kind: EncodingKind,
    errors: &str,
) -> Result<(Vec<u8>, String), (DecodeFailure, String)> {
    match kind {
        EncodingKind::Utf8 => match decode_utf8_bytes_with_errors(bytes, errors) {
            Ok(text) => Ok((text, "utf-8".to_string())),
            Err(err) => Err((err, "utf-8".to_string())),
        },
        EncodingKind::Utf8Sig => {
            let data =
                if bytes.len() >= 3 && bytes[0] == 0xEF && bytes[1] == 0xBB && bytes[2] == 0xBF {
                    &bytes[3..]
                } else {
                    bytes
                };
            match decode_utf8_bytes_with_errors(data, errors) {
                Ok(text) => Ok((text, "utf-8".to_string())),
                Err(err) => Err((err, "utf-8".to_string())),
            }
        }
        EncodingKind::Cp1252 => match decode_cp1252_with_errors(bytes, errors) {
            Ok(text) => Ok((text, "charmap".to_string())),
            Err(err) => Err((err, "charmap".to_string())),
        },
        EncodingKind::Cp437 => match decode_charmap_with_errors(bytes, errors, &CP437_DECODE_TABLE)
        {
            Ok(text) => Ok((text, "charmap".to_string())),
            Err(err) => Err((err, "charmap".to_string())),
        },
        EncodingKind::Cp850 => match decode_charmap_with_errors(bytes, errors, &CP850_DECODE_TABLE)
        {
            Ok(text) => Ok((text, "charmap".to_string())),
            Err(err) => Err((err, "charmap".to_string())),
        },
        EncodingKind::Cp860 => match decode_charmap_with_errors(bytes, errors, &CP860_DECODE_TABLE)
        {
            Ok(text) => Ok((text, "charmap".to_string())),
            Err(err) => Err((err, "charmap".to_string())),
        },
        EncodingKind::Cp862 => match decode_charmap_with_errors(bytes, errors, &CP862_DECODE_TABLE)
        {
            Ok(text) => Ok((text, "charmap".to_string())),
            Err(err) => Err((err, "charmap".to_string())),
        },
        EncodingKind::Cp863 => match decode_charmap_with_errors(bytes, errors, &CP863_DECODE_TABLE)
        {
            Ok(text) => Ok((text, "charmap".to_string())),
            Err(err) => Err((err, "charmap".to_string())),
        },
        EncodingKind::Cp865 => match decode_charmap_with_errors(bytes, errors, &CP865_DECODE_TABLE)
        {
            Ok(text) => Ok((text, "charmap".to_string())),
            Err(err) => Err((err, "charmap".to_string())),
        },
        EncodingKind::Cp866 => match decode_charmap_with_errors(bytes, errors, &CP866_DECODE_TABLE)
        {
            Ok(text) => Ok((text, "charmap".to_string())),
            Err(err) => Err((err, "charmap".to_string())),
        },
        EncodingKind::Cp874 => match decode_charmap_with_errors(bytes, errors, &CP874_DECODE_TABLE)
        {
            Ok(text) => Ok((text, "charmap".to_string())),
            Err(err) => Err((err, "charmap".to_string())),
        },
        EncodingKind::Cp1250 => {
            match decode_charmap_with_errors(bytes, errors, &CP1250_DECODE_TABLE) {
                Ok(text) => Ok((text, "charmap".to_string())),
                Err(err) => Err((err, "charmap".to_string())),
            }
        }
        EncodingKind::Cp1251 => {
            match decode_charmap_with_errors(bytes, errors, &CP1251_DECODE_TABLE) {
                Ok(text) => Ok((text, "charmap".to_string())),
                Err(err) => Err((err, "charmap".to_string())),
            }
        }
        EncodingKind::Cp1253 => {
            match decode_charmap_with_errors(bytes, errors, &CP1253_DECODE_TABLE) {
                Ok(text) => Ok((text, "charmap".to_string())),
                Err(err) => Err((err, "charmap".to_string())),
            }
        }
        EncodingKind::Cp1254 => {
            match decode_charmap_with_errors(bytes, errors, &CP1254_DECODE_TABLE) {
                Ok(text) => Ok((text, "charmap".to_string())),
                Err(err) => Err((err, "charmap".to_string())),
            }
        }
        EncodingKind::Cp1255 => {
            match decode_charmap_with_errors(bytes, errors, &CP1255_DECODE_TABLE) {
                Ok(text) => Ok((text, "charmap".to_string())),
                Err(err) => Err((err, "charmap".to_string())),
            }
        }
        EncodingKind::Cp1256 => {
            match decode_charmap_with_errors(bytes, errors, &CP1256_DECODE_TABLE) {
                Ok(text) => Ok((text, "charmap".to_string())),
                Err(err) => Err((err, "charmap".to_string())),
            }
        }
        EncodingKind::Cp1257 => {
            match decode_charmap_with_errors(bytes, errors, &CP1257_DECODE_TABLE) {
                Ok(text) => Ok((text, "charmap".to_string())),
                Err(err) => Err((err, "charmap".to_string())),
            }
        }
        EncodingKind::Koi8R => {
            match decode_charmap_with_errors(bytes, errors, &KOI8_R_DECODE_TABLE) {
                Ok(text) => Ok((text, "charmap".to_string())),
                Err(err) => Err((err, "charmap".to_string())),
            }
        }
        EncodingKind::Koi8U => {
            match decode_charmap_with_errors(bytes, errors, &KOI8_U_DECODE_TABLE) {
                Ok(text) => Ok((text, "charmap".to_string())),
                Err(err) => Err((err, "charmap".to_string())),
            }
        }
        EncodingKind::Iso8859_2 => {
            match decode_charmap_with_errors(bytes, errors, &ISO8859_2_DECODE_TABLE) {
                Ok(text) => Ok((text, "charmap".to_string())),
                Err(err) => Err((err, "charmap".to_string())),
            }
        }
        EncodingKind::Iso8859_3 => {
            match decode_charmap_with_errors(bytes, errors, &ISO8859_3_DECODE_TABLE) {
                Ok(text) => Ok((text, "charmap".to_string())),
                Err(err) => Err((err, "charmap".to_string())),
            }
        }
        EncodingKind::Iso8859_4 => {
            match decode_charmap_with_errors(bytes, errors, &ISO8859_4_DECODE_TABLE) {
                Ok(text) => Ok((text, "charmap".to_string())),
                Err(err) => Err((err, "charmap".to_string())),
            }
        }
        EncodingKind::Iso8859_5 => {
            match decode_charmap_with_errors(bytes, errors, &ISO8859_5_DECODE_TABLE) {
                Ok(text) => Ok((text, "charmap".to_string())),
                Err(err) => Err((err, "charmap".to_string())),
            }
        }
        EncodingKind::Iso8859_6 => {
            match decode_charmap_with_errors(bytes, errors, &ISO8859_6_DECODE_TABLE) {
                Ok(text) => Ok((text, "charmap".to_string())),
                Err(err) => Err((err, "charmap".to_string())),
            }
        }
        EncodingKind::Iso8859_7 => {
            match decode_charmap_with_errors(bytes, errors, &ISO8859_7_DECODE_TABLE) {
                Ok(text) => Ok((text, "charmap".to_string())),
                Err(err) => Err((err, "charmap".to_string())),
            }
        }
        EncodingKind::Iso8859_8 => {
            match decode_charmap_with_errors(bytes, errors, &ISO8859_8_DECODE_TABLE) {
                Ok(text) => Ok((text, "charmap".to_string())),
                Err(err) => Err((err, "charmap".to_string())),
            }
        }
        EncodingKind::Iso8859_10 => {
            match decode_charmap_with_errors(bytes, errors, &ISO8859_10_DECODE_TABLE) {
                Ok(text) => Ok((text, "charmap".to_string())),
                Err(err) => Err((err, "charmap".to_string())),
            }
        }
        EncodingKind::Iso8859_15 => {
            match decode_charmap_with_errors(bytes, errors, &ISO8859_15_DECODE_TABLE) {
                Ok(text) => Ok((text, "charmap".to_string())),
                Err(err) => Err((err, "charmap".to_string())),
            }
        }
        EncodingKind::MacRoman => {
            match decode_charmap_with_errors(bytes, errors, &MAC_ROMAN_DECODE_TABLE) {
                Ok(text) => Ok((text, "charmap".to_string())),
                Err(err) => Err((err, "charmap".to_string())),
            }
        }
        EncodingKind::Ascii => match decode_ascii_with_errors(bytes, errors) {
            Ok(text) => Ok((text, "ascii".to_string())),
            Err(err) => Err((err, "ascii".to_string())),
        },
        EncodingKind::Latin1 => {
            let mut out = Vec::with_capacity(bytes.len());
            for &byte in bytes {
                push_wtf8_codepoint(&mut out, byte as u32);
            }
            Ok((out, "latin-1".to_string()))
        }
        EncodingKind::UnicodeEscape => match decode_unicode_escape_with_errors(bytes, errors) {
            Ok(text) => Ok((text, "unicodeescape".to_string())),
            Err(err) => Err((err, "unicodeescape".to_string())),
        },
        EncodingKind::Utf16 | EncodingKind::Utf16LE | EncodingKind::Utf16BE => {
            let (endian, label, offset) = utf16_decode_config(bytes, kind);
            match decode_utf16_with_errors(bytes, errors, endian, offset) {
                Ok(text) => Ok((text, label)),
                Err(err) => Err((err, label)),
            }
        }
        EncodingKind::Utf32 | EncodingKind::Utf32LE | EncodingKind::Utf32BE => {
            let (endian, label, offset) = utf32_decode_config(bytes, kind);
            match decode_utf32_with_errors(bytes, errors, endian, offset) {
                Ok(text) => Ok((text, label)),
                Err(err) => Err((err, label)),
            }
        }
    }
}

#[derive(Debug)]
pub(crate) enum DecodeTextError {
    UnknownEncoding(String),
    UnknownErrorHandler(String),
    Failure(DecodeFailure, String),
}

pub(crate) fn decode_bytes_text(
    encoding: &str,
    errors: &str,
    bytes: &[u8],
) -> Result<(Vec<u8>, String), DecodeTextError> {
    let Some(kind) = normalize_encoding(encoding) else {
        return Err(DecodeTextError::UnknownEncoding(encoding.to_string()));
    };
    let errors_known = matches!(
        errors,
        "strict" | "ignore" | "replace" | "backslashreplace" | "surrogateescape" | "surrogatepass"
    );
    let result = if errors_known {
        decode_bytes_with_errors(bytes, kind, errors)
    } else {
        match decode_bytes_with_errors(bytes, kind, "strict") {
            Ok((text, label)) => return Ok((text, label)),
            Err((_failure, _label)) => {
                return Err(DecodeTextError::UnknownErrorHandler(errors.to_string()));
            }
        }
    };
    match result {
        Ok((text, label)) => Ok((text, label)),
        Err((failure, label)) => Err(DecodeTextError::Failure(failure, label)),
    }
}

fn parse_codec_arg(
    _py: &PyToken<'_>,
    bits: u64,
    func_name: &str,
    arg_name: &str,
    default: &str,
) -> Option<String> {
    if bits == missing_bits(_py) {
        return Some(default.to_string());
    }
    let obj = obj_from_bits(bits);
    if obj.is_none() {
        let msg = format!("{func_name}() argument '{arg_name}' must be str, not None");
        return raise_exception::<_>(_py, "TypeError", &msg);
    }
    let Some(text) = string_obj_to_owned(obj) else {
        let type_name = class_name_for_error(type_of_bits(_py, bits));
        let msg = format!("{func_name}() argument '{arg_name}' must be str, not '{type_name}'");
        return raise_exception::<_>(_py, "TypeError", &msg);
    };
    Some(text)
}

fn bytes_from_count(_py: &PyToken<'_>, len: usize, type_id: u32) -> u64 {
    if type_id == TYPE_ID_BYTEARRAY {
        let ptr = alloc_bytearray_with_len(_py, len);
        if ptr.is_null() {
            return MoltObject::none().bits();
        }
        return MoltObject::from_ptr(ptr).bits();
    }
    let ptr = alloc_bytes_like_with_len(_py, len, type_id);
    if ptr.is_null() {
        return MoltObject::none().bits();
    }
    unsafe {
        let data_ptr = ptr.add(std::mem::size_of::<usize>());
        std::ptr::write_bytes(data_ptr, 0, len);
    }
    MoltObject::from_ptr(ptr).bits()
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_int_to_bytes(
    int_bits: u64,
    length_bits: u64,
    byteorder_bits: u64,
    signed_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let length_type = class_name_for_error(type_of_bits(_py, length_bits));
        let length_msg = format!(
            "'{}' object cannot be interpreted as an integer",
            length_type
        );
        let length = index_i64_from_obj(_py, length_bits, &length_msg);
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        if length < 0 {
            return raise_exception::<_>(_py, "ValueError", "length argument must be non-negative");
        }
        let len = match usize::try_from(length) {
            Ok(val) => val,
            Err(_) => {
                return raise_exception::<_>(_py, "OverflowError", "length too large");
            }
        };
        let byteorder_obj = obj_from_bits(byteorder_bits);
        let Some(byteorder) = string_obj_to_owned(byteorder_obj) else {
            let type_name = class_name_for_error(type_of_bits(_py, byteorder_bits));
            let msg = format!(
                "to_bytes() argument 'byteorder' must be str, not {}",
                type_name
            );
            return raise_exception::<_>(_py, "TypeError", &msg);
        };
        let byteorder_norm = byteorder.to_ascii_lowercase();
        let is_little = match byteorder_norm.as_str() {
            "little" => true,
            "big" => false,
            _ => {
                return raise_exception::<_>(
                    _py,
                    "ValueError",
                    "byteorder must be either 'little' or 'big'",
                );
            }
        };
        let signed = is_truthy(_py, obj_from_bits(signed_bits));
        let value_obj = obj_from_bits(int_bits);
        let Some(value) = to_bigint(value_obj) else {
            let type_name = class_name_for_error(type_of_bits(_py, int_bits));
            let msg = format!(
                "descriptor 'to_bytes' requires a 'int' object but received '{}'",
                type_name
            );
            return raise_exception::<_>(_py, "TypeError", &msg);
        };
        if !signed && value.sign() == Sign::Minus {
            return raise_exception::<_>(
                _py,
                "OverflowError",
                "can't convert negative int to unsigned",
            );
        }
        let mut bytes = if signed {
            value.to_signed_bytes_be()
        } else {
            value.to_bytes_be().1
        };
        if bytes.len() > len {
            return raise_exception::<_>(_py, "OverflowError", "int too big to convert");
        }
        if bytes.len() < len {
            let pad = if signed && value.sign() == Sign::Minus {
                0xFF
            } else {
                0x00
            };
            let mut out = vec![pad; len - bytes.len()];
            out.extend_from_slice(&bytes);
            bytes = out;
        }
        if is_little {
            bytes.reverse();
        }
        let ptr = alloc_bytes(_py, &bytes);
        if ptr.is_null() {
            MoltObject::none().bits()
        } else {
            MoltObject::from_ptr(ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_int_from_bytes(
    class_bits: u64,
    bytes_bits: u64,
    byteorder_bits: u64,
    signed_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let byteorder_obj = obj_from_bits(byteorder_bits);
        let Some(byteorder) = string_obj_to_owned(byteorder_obj) else {
            let type_name = class_name_for_error(type_of_bits(_py, byteorder_bits));
            let msg = format!(
                "from_bytes() argument 'byteorder' must be str, not {}",
                type_name
            );
            return raise_exception::<_>(_py, "TypeError", &msg);
        };
        let byteorder_norm = byteorder.to_ascii_lowercase();
        let is_little = match byteorder_norm.as_str() {
            "little" => true,
            "big" => false,
            _ => {
                return raise_exception::<_>(
                    _py,
                    "ValueError",
                    "byteorder must be either 'little' or 'big'",
                );
            }
        };
        let signed = is_truthy(_py, obj_from_bits(signed_bits));
        let bytes_obj = obj_from_bits(bytes_bits);
        let Some(bytes_ptr) = bytes_obj.as_ptr() else {
            let type_name = class_name_for_error(type_of_bits(_py, bytes_bits));
            let msg = format!("cannot convert '{}' object to bytes", type_name);
            return raise_exception::<_>(_py, "TypeError", &msg);
        };
        let Some(slice) = (unsafe { bytes_like_slice(bytes_ptr) }) else {
            let type_name = class_name_for_error(type_of_bits(_py, bytes_bits));
            let msg = format!("cannot convert '{}' object to bytes", type_name);
            return raise_exception::<_>(_py, "TypeError", &msg);
        };
        let mut bytes = slice.to_vec();
        if is_little {
            bytes.reverse();
        }
        let value = if signed {
            BigInt::from_signed_bytes_be(&bytes)
        } else {
            BigInt::from_bytes_be(Sign::Plus, &bytes)
        };
        let int_bits = int_bits_from_bigint(_py, value);
        let builtins = builtin_classes(_py);
        if class_bits == builtins.int {
            return int_bits;
        }
        unsafe { call_callable1(_py, class_bits, int_bits) }
    })
}

fn bytes_item_to_u8(_py: &PyToken<'_>, bits: u64, kind: BytesCtorKind) -> Option<u8> {
    let type_name = class_name_for_error(type_of_bits(_py, bits));
    let msg = format!("'{}' object cannot be interpreted as an integer", type_name);
    let val = index_i64_from_obj(_py, bits, &msg);
    if exception_pending(_py) {
        return None;
    }
    if !(0..=255).contains(&val) {
        return raise_exception::<_>(_py, "ValueError", kind.range_error());
    }
    Some(val as u8)
}

fn bytes_collect_from_iter(
    _py: &PyToken<'_>,
    iter_bits: u64,
    kind: BytesCtorKind,
) -> Option<Vec<u8>> {
    let mut out = Vec::new();
    loop {
        let pair_bits = molt_iter_next(iter_bits);
        if exception_pending(_py) {
            return None;
        }
        let pair_ptr = obj_from_bits(pair_bits).as_ptr()?;
        unsafe {
            if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                return None;
            }
            let elems = seq_vec_ref(pair_ptr);
            if elems.len() < 2 {
                return None;
            }
            let done_bits = elems[1];
            if is_truthy(_py, obj_from_bits(done_bits)) {
                break;
            }
            let val_bits = elems[0];
            let byte = bytes_item_to_u8(_py, val_bits, kind)?;
            out.push(byte);
        }
    }
    Some(out)
}

fn bytes_from_obj_impl(_py: &PyToken<'_>, bits: u64, kind: BytesCtorKind) -> u64 {
    let obj = obj_from_bits(bits);
    if let Some(i) = to_i64(obj) {
        if i < 0 {
            return raise_exception::<_>(_py, "ValueError", "negative count");
        }
        let len = match usize::try_from(i) {
            Ok(len) => len,
            Err(_) => {
                return raise_exception::<_>(
                    _py,
                    "OverflowError",
                    "cannot fit 'int' into an index-sized integer",
                );
            }
        };
        let type_id = match kind {
            BytesCtorKind::Bytes => TYPE_ID_BYTES,
            BytesCtorKind::Bytearray => TYPE_ID_BYTEARRAY,
        };
        return bytes_from_count(_py, len, type_id);
    }
    if let Some(ptr) = obj.as_ptr() {
        unsafe {
            let type_id = object_type_id(ptr);
            if type_id == TYPE_ID_STRING {
                return raise_exception::<_>(
                    _py,
                    "TypeError",
                    "string argument without an encoding",
                );
            }
            if type_id == TYPE_ID_BYTES && matches!(kind, BytesCtorKind::Bytes) {
                inc_ref_bits(_py, bits);
                return bits;
            }
            if type_id == TYPE_ID_LIST || type_id == TYPE_ID_TUPLE {
                let elems = seq_vec_ref(ptr);
                let mut out = Vec::with_capacity(elems.len());
                for &elem in elems.iter() {
                    let Some(byte) = bytes_item_to_u8(_py, elem, kind) else {
                        return MoltObject::none().bits();
                    };
                    out.push(byte);
                }
                let out_ptr = match kind {
                    BytesCtorKind::Bytes => alloc_bytes(_py, &out),
                    BytesCtorKind::Bytearray => alloc_bytearray(_py, &out),
                };
                if out_ptr.is_null() {
                    return MoltObject::none().bits();
                }
                return MoltObject::from_ptr(out_ptr).bits();
            }
            if let Some(slice) = bytes_like_slice(ptr) {
                let out_ptr = match kind {
                    BytesCtorKind::Bytes => alloc_bytes(_py, slice),
                    BytesCtorKind::Bytearray => alloc_bytearray(_py, slice),
                };
                if out_ptr.is_null() {
                    return MoltObject::none().bits();
                }
                return MoltObject::from_ptr(out_ptr).bits();
            }
            if type_id == TYPE_ID_MEMORYVIEW {
                if let Some(out) = memoryview_collect_bytes(ptr) {
                    let out_ptr = match kind {
                        BytesCtorKind::Bytes => alloc_bytes(_py, &out),
                        BytesCtorKind::Bytearray => alloc_bytearray(_py, &out),
                    };
                    if out_ptr.is_null() {
                        return MoltObject::none().bits();
                    }
                    return MoltObject::from_ptr(out_ptr).bits();
                }
            }
            if type_id == TYPE_ID_BIGINT {
                let big = bigint_ref(ptr);
                if big.is_negative() {
                    return raise_exception::<_>(_py, "ValueError", "negative count");
                }
                let Some(len) = big.to_usize() else {
                    return raise_exception::<_>(
                        _py,
                        "OverflowError",
                        "cannot fit 'int' into an index-sized integer",
                    );
                };
                let type_id = match kind {
                    BytesCtorKind::Bytes => TYPE_ID_BYTES,
                    BytesCtorKind::Bytearray => TYPE_ID_BYTEARRAY,
                };
                return bytes_from_count(_py, len, type_id);
            }
            let index_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.index_name, b"__index__");
            let call_bits = attr_lookup_ptr(_py, ptr, index_name_bits);
            dec_ref_bits(_py, index_name_bits);
            if let Some(call_bits) = call_bits {
                let res_bits = call_callable0(_py, call_bits);
                dec_ref_bits(_py, call_bits);
                if exception_pending(_py) {
                    return MoltObject::none().bits();
                }
                let res_obj = obj_from_bits(res_bits);
                if let Some(i) = to_i64(res_obj) {
                    if i < 0 {
                        return raise_exception::<_>(_py, "ValueError", "negative count");
                    }
                    let len = match usize::try_from(i) {
                        Ok(len) => len,
                        Err(_) => {
                            return raise_exception::<_>(
                                _py,
                                "OverflowError",
                                "cannot fit 'int' into an index-sized integer",
                            );
                        }
                    };
                    let type_id = match kind {
                        BytesCtorKind::Bytes => TYPE_ID_BYTES,
                        BytesCtorKind::Bytearray => TYPE_ID_BYTEARRAY,
                    };
                    return bytes_from_count(_py, len, type_id);
                }
                if let Some(big_ptr) = bigint_ptr_from_bits(res_bits) {
                    let big = bigint_ref(big_ptr);
                    if big.is_negative() {
                        return raise_exception::<_>(_py, "ValueError", "negative count");
                    }
                    let Some(len) = big.to_usize() else {
                        return raise_exception::<_>(
                            _py,
                            "OverflowError",
                            "cannot fit 'int' into an index-sized integer",
                        );
                    };
                    dec_ref_bits(_py, res_bits);
                    let type_id = match kind {
                        BytesCtorKind::Bytes => TYPE_ID_BYTES,
                        BytesCtorKind::Bytearray => TYPE_ID_BYTEARRAY,
                    };
                    return bytes_from_count(_py, len, type_id);
                }
                let res_type = class_name_for_error(type_of_bits(_py, res_bits));
                if res_obj.as_ptr().is_some() {
                    dec_ref_bits(_py, res_bits);
                }
                let msg = format!("__index__ returned non-int (type {res_type})");
                return raise_exception::<_>(_py, "TypeError", &msg);
            }
        }
    }
    let iter_bits = molt_iter(bits);
    if obj_from_bits(iter_bits).is_none() {
        let type_name = class_name_for_error(type_of_bits(_py, bits));
        let msg = kind.non_iterable_message(&type_name);
        return raise_exception::<_>(_py, "TypeError", &msg);
    }
    let Some(out) = bytes_collect_from_iter(_py, iter_bits, kind) else {
        return MoltObject::none().bits();
    };
    let out_ptr = match kind {
        BytesCtorKind::Bytes => alloc_bytes(_py, &out),
        BytesCtorKind::Bytearray => alloc_bytearray(_py, &out),
    };
    if out_ptr.is_null() {
        return MoltObject::none().bits();
    }
    MoltObject::from_ptr(out_ptr).bits()
}

fn bytes_from_str_impl(
    _py: &PyToken<'_>,
    src_bits: u64,
    encoding_bits: u64,
    errors_bits: u64,
    kind: BytesCtorKind,
) -> u64 {
    let encoding_obj = obj_from_bits(encoding_bits);
    let errors_obj = obj_from_bits(errors_bits);
    let encoding = if encoding_obj.is_none() {
        None
    } else {
        let Some(encoding) = string_obj_to_owned(encoding_obj) else {
            let type_name = class_name_for_error(type_of_bits(_py, encoding_bits));
            let msg = kind.arg_type_message("encoding", &type_name);
            return raise_exception::<_>(_py, "TypeError", &msg);
        };
        Some(encoding)
    };
    let errors = if errors_obj.is_none() {
        None
    } else {
        let Some(errors) = string_obj_to_owned(errors_obj) else {
            let type_name = class_name_for_error(type_of_bits(_py, errors_bits));
            let msg = kind.arg_type_message("errors", &type_name);
            return raise_exception::<_>(_py, "TypeError", &msg);
        };
        Some(errors)
    };
    let src_obj = obj_from_bits(src_bits);
    let Some(src_ptr) = src_obj.as_ptr() else {
        if encoding.is_some() {
            return raise_exception::<_>(_py, "TypeError", "encoding without a string argument");
        }
        if errors.is_some() {
            return raise_exception::<_>(_py, "TypeError", "errors without a string argument");
        }
        return MoltObject::none().bits();
    };
    unsafe {
        if object_type_id(src_ptr) != TYPE_ID_STRING {
            if encoding.is_some() {
                return raise_exception::<_>(
                    _py,
                    "TypeError",
                    "encoding without a string argument",
                );
            }
            if errors.is_some() {
                return raise_exception::<_>(_py, "TypeError", "errors without a string argument");
            }
            return MoltObject::none().bits();
        }
    }
    let Some(encoding) = encoding else {
        return raise_exception::<_>(_py, "TypeError", "string argument without an encoding");
    };
    let bytes = unsafe { std::slice::from_raw_parts(string_bytes(src_ptr), string_len(src_ptr)) };
    let out = match encode_string_with_errors(bytes, &encoding, errors.as_deref()) {
        Ok(bytes) => bytes,
        Err(EncodeError::UnknownEncoding(name)) => {
            let msg = format!("unknown encoding: {name}");
            return raise_exception::<_>(_py, "LookupError", &msg);
        }
        Err(EncodeError::UnknownErrorHandler(name)) => {
            let msg = format!("unknown error handler name '{name}'");
            return raise_exception::<_>(_py, "LookupError", &msg);
        }
        Err(EncodeError::InvalidChar {
            encoding,
            code,
            pos,
            limit,
        }) => {
            let reason = encode_error_reason(encoding, code, limit);
            return raise_unicode_encode_error::<_>(_py, encoding, src_bits, pos, pos + 1, &reason);
        }
    };
    let out_ptr = match kind {
        BytesCtorKind::Bytes => alloc_bytes(_py, &out),
        BytesCtorKind::Bytearray => alloc_bytearray(_py, &out),
    };
    if out_ptr.is_null() {
        return MoltObject::none().bits();
    }
    MoltObject::from_ptr(out_ptr).bits()
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_from_obj(bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        bytes_from_obj_impl(_py, bits, BytesCtorKind::Bytes)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_from_obj(bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        bytes_from_obj_impl(_py, bits, BytesCtorKind::Bytearray)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytes_from_str(src_bits: u64, encoding_bits: u64, errors_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        bytes_from_str_impl(
            _py,
            src_bits,
            encoding_bits,
            errors_bits,
            BytesCtorKind::Bytes,
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_bytearray_from_str(
    src_bits: u64,
    encoding_bits: u64,
    errors_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        bytes_from_str_impl(
            _py,
            src_bits,
            encoding_bits,
            errors_bits,
            BytesCtorKind::Bytearray,
        )
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_memoryview_new(bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(bits);
        let ptr = match obj.as_ptr() {
            Some(ptr) => ptr,
            None => {
                return raise_exception::<_>(
                    _py,
                    "TypeError",
                    "memoryview expects a bytes-like object",
                );
            }
        };
        unsafe {
            let type_id = object_type_id(ptr);
            if type_id == TYPE_ID_MEMORYVIEW {
                let owner_bits = memoryview_owner_bits(ptr);
                let offset = memoryview_offset(ptr);
                let len = memoryview_len(ptr);
                let itemsize = memoryview_itemsize(ptr);
                let stride = memoryview_stride(ptr);
                let readonly = memoryview_readonly(ptr);
                let format_bits = memoryview_format_bits(ptr);
                let shape = memoryview_shape(ptr).unwrap_or(&[]).to_vec();
                let strides = memoryview_strides(ptr).unwrap_or(&[]).to_vec();
                let out_ptr = if shape.len() > 1 || memoryview_ndim(ptr) == 0 {
                    alloc_memoryview_shaped(
                        _py,
                        owner_bits,
                        offset,
                        itemsize,
                        readonly,
                        format_bits,
                        shape,
                        strides,
                    )
                } else {
                    alloc_memoryview(
                        _py,
                        owner_bits,
                        offset,
                        len,
                        itemsize,
                        stride,
                        readonly,
                        format_bits,
                    )
                };
                if out_ptr.is_null() {
                    return MoltObject::none().bits();
                }
                return MoltObject::from_ptr(out_ptr).bits();
            }
            if type_id == TYPE_ID_BYTES || type_id == TYPE_ID_BYTEARRAY {
                let len = bytes_len(ptr);
                let readonly = type_id == TYPE_ID_BYTES;
                let format_ptr = alloc_string(_py, b"B");
                if format_ptr.is_null() {
                    return MoltObject::none().bits();
                }
                let format_bits = MoltObject::from_ptr(format_ptr).bits();
                let out_ptr = alloc_memoryview(_py, bits, 0, len, 1, 1, readonly, format_bits);
                dec_ref_bits(_py, format_bits);
                if out_ptr.is_null() {
                    return MoltObject::none().bits();
                }
                return MoltObject::from_ptr(out_ptr).bits();
            }
        }
        raise_exception::<_>(_py, "TypeError", "memoryview expects a bytes-like object")
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_memoryview_cast(
    view_bits: u64,
    format_bits: u64,
    shape_bits: u64,
    has_shape_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let view = obj_from_bits(view_bits);
        let view_ptr = match view.as_ptr() {
            Some(ptr) => ptr,
            None => {
                return raise_exception::<_>(
                    _py,
                    "TypeError",
                    "cast() argument 'view' must be a memoryview",
                );
            }
        };
        unsafe {
            if object_type_id(view_ptr) != TYPE_ID_MEMORYVIEW {
                return raise_exception::<_>(
                    _py,
                    "TypeError",
                    "cast() argument 'view' must be a memoryview",
                );
            }
            let format_obj = obj_from_bits(format_bits);
            let format_str = match string_obj_to_owned(format_obj) {
                Some(val) => val,
                None => {
                    return raise_exception::<_>(
                        _py,
                        "TypeError",
                        &format!(
                            "cast() argument 'format' must be str, not {}",
                            type_name(_py, format_obj)
                        ),
                    );
                }
            };
            let fmt = match memoryview_format_from_str(&format_str) {
                Some(val) => val,
                None => {
                    return raise_exception::<_>(
                        _py,
                        "ValueError",
                        "memoryview: destination format must be a native single character format prefixed with an optional '@'",
                    );
                }
            };
            if !memoryview_is_c_contiguous_view(view_ptr) {
                return raise_exception::<_>(
                    _py,
                    "TypeError",
                    "memoryview: casts are restricted to C-contiguous views",
                );
            }
            let shape_view = memoryview_shape(view_ptr).unwrap_or(&[]);
            let nbytes = match memoryview_nbytes_big(shape_view, memoryview_itemsize(view_ptr)) {
                Some(val) => val,
                None => return MoltObject::none().bits(),
            };
            let has_shape = is_truthy(_py, obj_from_bits(has_shape_bits));
            let shape = if has_shape {
                let shape_obj = obj_from_bits(shape_bits);
                let shape_ptr = match shape_obj.as_ptr() {
                    Some(ptr) => ptr,
                    None => {
                        return raise_exception::<_>(
                            _py,
                            "TypeError",
                            "shape must be a list or a tuple",
                        );
                    }
                };
                let type_id = object_type_id(shape_ptr);
                if type_id != TYPE_ID_LIST && type_id != TYPE_ID_TUPLE {
                    return raise_exception::<_>(
                        _py,
                        "TypeError",
                        "shape must be a list or a tuple",
                    );
                }
                let elems = seq_vec_ref(shape_ptr);
                let mut shape = Vec::with_capacity(elems.len());
                for &elem_bits in elems.iter() {
                    let elem_obj = obj_from_bits(elem_bits);
                    let Some(val) = to_i64(elem_obj).or_else(|| {
                        bigint_ptr_from_bits(elem_bits).and_then(|ptr| bigint_ref(ptr).to_i64())
                    }) else {
                        return raise_exception::<_>(
                            _py,
                            "TypeError",
                            "memoryview.cast(): elements of shape must be integers",
                        );
                    };
                    if val <= 0 {
                        return raise_exception::<_>(
                            _py,
                            "ValueError",
                            "memoryview.cast(): elements of shape must be integers > 0",
                        );
                    }
                    shape.push(val as isize);
                }
                shape
            } else {
                let itemsize = fmt.itemsize as i128;
                if itemsize == 0 || nbytes % itemsize != 0 {
                    return raise_exception::<_>(
                        _py,
                        "TypeError",
                        "memoryview: length is not a multiple of itemsize",
                    );
                }
                let len = (nbytes / itemsize) as isize;
                vec![len]
            };
            let product = match memoryview_shape_product(&shape) {
                Some(val) => val,
                None => return MoltObject::none().bits(),
            };
            if product.saturating_mul(fmt.itemsize as i128) != nbytes {
                return raise_exception::<_>(
                    _py,
                    "TypeError",
                    "memoryview: product(shape) * itemsize != buffer size",
                );
            }
            let mut strides = vec![0isize; shape.len()];
            let mut stride = fmt.itemsize as isize;
            for idx in (0..shape.len()).rev() {
                strides[idx] = stride;
                stride = stride.saturating_mul(shape[idx].max(1));
            }
            let out_ptr = alloc_memoryview_shaped(
                _py,
                memoryview_owner_bits(view_ptr),
                memoryview_offset(view_ptr),
                fmt.itemsize,
                memoryview_readonly(view_ptr),
                format_bits,
                shape,
                strides,
            );
            if out_ptr.is_null() {
                return MoltObject::none().bits();
            }
            MoltObject::from_ptr(out_ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_memoryview_tobytes(bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(bits);
        let ptr = match obj.as_ptr() {
            Some(ptr) => ptr,
            None => return raise_exception::<_>(_py, "TypeError", "tobytes expects a memoryview"),
        };
        unsafe {
            if object_type_id(ptr) != TYPE_ID_MEMORYVIEW {
                return raise_exception::<_>(_py, "TypeError", "tobytes expects a memoryview");
            }
            let out = match memoryview_collect_bytes(ptr) {
                Some(val) => val,
                None => return MoltObject::none().bits(),
            };
            let out_ptr = alloc_bytes(_py, &out);
            if out_ptr.is_null() {
                return MoltObject::none().bits();
            }
            MoltObject::from_ptr(out_ptr).bits()
        }
    })
}

#[repr(C)]
pub struct BufferExport {
    pub ptr: u64,
    pub len: u64,
    pub readonly: u64,
    pub stride: i64,
    pub itemsize: u64,
}

/// # Safety
/// Caller must ensure `out_ptr` is valid and writable.
#[unsafe(no_mangle)]
pub unsafe extern "C" fn molt_buffer_export(obj_bits: u64, out_ptr: *mut BufferExport) -> i32 {
    unsafe {
        crate::with_gil_entry!(_py, {
            if out_ptr.is_null() {
                return 1;
            }
            let obj = obj_from_bits(obj_bits);
            let ptr = match obj.as_ptr() {
                Some(ptr) => ptr,
                None => return 1,
            };
            let type_id = object_type_id(ptr);
            if type_id == TYPE_ID_BYTES || type_id == TYPE_ID_BYTEARRAY {
                let data_ptr = bytes_data(ptr) as u64;
                let len = bytes_len(ptr) as u64;
                let readonly = if type_id == TYPE_ID_BYTES { 1 } else { 0 };
                *out_ptr = BufferExport {
                    ptr: data_ptr,
                    len,
                    readonly,
                    stride: 1,
                    itemsize: 1,
                };
                return 0;
            }
            if type_id == TYPE_ID_MEMORYVIEW {
                let owner_bits = memoryview_owner_bits(ptr);
                let owner = obj_from_bits(owner_bits);
                let owner_ptr = match owner.as_ptr() {
                    Some(ptr) => ptr,
                    None => return 1,
                };
                let base = match bytes_like_slice_raw(owner_ptr) {
                    Some(slice) => slice,
                    None => return 1,
                };
                let offset = memoryview_offset(ptr);
                if offset < 0 {
                    return 1;
                }
                let offset = offset as usize;
                if offset > base.len() {
                    return 1;
                }
                let data_ptr = base.as_ptr().add(offset) as u64;
                let len = memoryview_len(ptr) as u64;
                let readonly = if memoryview_readonly(ptr) { 1 } else { 0 };
                let stride = memoryview_stride(ptr) as i64;
                let itemsize = memoryview_itemsize(ptr) as u64;
                *out_ptr = BufferExport {
                    ptr: data_ptr,
                    len,
                    readonly,
                    stride,
                    itemsize,
                };
                return 0;
            }
            1
        })
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_index(obj_bits: u64, key_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        let obj = obj_from_bits(obj_bits);
        let key = obj_from_bits(key_bits);
        if let Some(ptr) = obj.as_ptr() {
            unsafe {
                let type_id = object_type_id(ptr);
                if type_id == TYPE_ID_MEMORYVIEW {
                    let fmt = match memoryview_format_from_bits(memoryview_format_bits(ptr)) {
                        Some(fmt) => fmt,
                        None => return MoltObject::none().bits(),
                    };
                    let owner_bits = memoryview_owner_bits(ptr);
                    let owner = obj_from_bits(owner_bits);
                    let owner_ptr = match owner.as_ptr() {
                        Some(ptr) => ptr,
                        None => return MoltObject::none().bits(),
                    };
                    let base = match bytes_like_slice_raw(owner_ptr) {
                        Some(slice) => slice,
                        None => return MoltObject::none().bits(),
                    };
                    let shape = memoryview_shape(ptr).unwrap_or(&[]);
                    let strides = memoryview_strides(ptr).unwrap_or(&[]);
                    let ndim = shape.len();
                    if ndim == 0 {
                        if let Some(tup_ptr) = key.as_ptr() {
                            if object_type_id(tup_ptr) == TYPE_ID_TUPLE {
                                let elems = seq_vec_ref(tup_ptr);
                                if elems.is_empty() {
                                    let val = memoryview_read_scalar(
                                        _py,
                                        base,
                                        memoryview_offset(ptr),
                                        fmt,
                                    );
                                    return val.unwrap_or_else(|| MoltObject::none().bits());
                                }
                            }
                        }
                        return raise_exception::<_>(
                            _py,
                            "TypeError",
                            "invalid indexing of 0-dim memory",
                        );
                    }
                    if let Some(tup_ptr) = key.as_ptr() {
                        if object_type_id(tup_ptr) == TYPE_ID_TUPLE {
                            let elems = seq_vec_ref(tup_ptr);
                            let mut has_slice = false;
                            let mut all_slice = true;
                            for &elem_bits in elems.iter() {
                                let elem_obj = obj_from_bits(elem_bits);
                                if let Some(elem_ptr) = elem_obj.as_ptr() {
                                    if object_type_id(elem_ptr) == TYPE_ID_SLICE {
                                        has_slice = true;
                                    } else {
                                        all_slice = false;
                                    }
                                } else {
                                    all_slice = false;
                                }
                            }
                            if has_slice {
                                if all_slice {
                                    return raise_exception::<_>(
                                        _py,
                                        "NotImplementedError",
                                        "multi-dimensional slicing is not implemented",
                                    );
                                }
                                return raise_exception::<_>(
                                    _py,
                                    "TypeError",
                                    "memoryview: invalid slice key",
                                );
                            }
                            if elems.len() < ndim {
                                return raise_exception::<_>(
                                    _py,
                                    "NotImplementedError",
                                    "multi-dimensional sub-views are not implemented",
                                );
                            }
                            if elems.len() > ndim {
                                let msg = format!(
                                    "cannot index {}-dimension view with {}-element tuple",
                                    ndim,
                                    elems.len()
                                );
                                return raise_exception::<_>(_py, "TypeError", &msg);
                            }
                            if shape.len() != strides.len() {
                                return MoltObject::none().bits();
                            }
                            let mut pos = memoryview_offset(ptr);
                            for (dim, &elem_bits) in elems.iter().enumerate() {
                                let Some(idx) = index_i64_with_overflow(
                                    _py,
                                    elem_bits,
                                    "memoryview: invalid slice key",
                                    None,
                                ) else {
                                    return MoltObject::none().bits();
                                };
                                let mut i = idx;
                                let dim_len = shape[dim];
                                let dim_len_i64 = dim_len as i64;
                                if i < 0 {
                                    i += dim_len_i64;
                                }
                                if i < 0 || i >= dim_len_i64 {
                                    let msg =
                                        format!("index out of bounds on dimension {}", dim + 1);
                                    return raise_exception::<_>(_py, "IndexError", &msg);
                                }
                                pos = pos.saturating_add((i as isize).saturating_mul(strides[dim]));
                            }
                            if pos < 0 || pos + fmt.itemsize as isize > base.len() as isize {
                                return raise_exception::<_>(
                                    _py,
                                    "IndexError",
                                    "index out of bounds on dimension 1",
                                );
                            }
                            let val = memoryview_read_scalar(_py, base, pos, fmt);
                            return val.unwrap_or_else(|| MoltObject::none().bits());
                        }
                    }
                    if let Some(slice_ptr) = key.as_ptr() {
                        if object_type_id(slice_ptr) == TYPE_ID_SLICE {
                            let len = shape[0];
                            let start_obj = obj_from_bits(slice_start_bits(slice_ptr));
                            let stop_obj = obj_from_bits(slice_stop_bits(slice_ptr));
                            let step_obj = obj_from_bits(slice_step_bits(slice_ptr));
                            let (start, stop, step) = match normalize_slice_indices(
                                _py, len, start_obj, stop_obj, step_obj,
                            ) {
                                Ok(vals) => vals,
                                Err(err) => return slice_error(_py, err),
                            };
                            let base_offset = memoryview_offset(ptr);
                            let base_stride = strides[0];
                            let itemsize = memoryview_itemsize(ptr);
                            let new_offset = base_offset + start * base_stride;
                            let new_stride = base_stride * step;
                            let new_len = range_len_i64(start as i64, stop as i64, step as i64);
                            let new_len = new_len.max(0) as usize;
                            let mut new_shape = shape.to_vec();
                            let mut new_strides = strides.to_vec();
                            if !new_shape.is_empty() {
                                new_shape[0] = new_len as isize;
                                new_strides[0] = new_stride;
                            }
                            let out_ptr = alloc_memoryview_shaped(
                                _py,
                                memoryview_owner_bits(ptr),
                                new_offset,
                                itemsize,
                                memoryview_readonly(ptr),
                                memoryview_format_bits(ptr),
                                new_shape,
                                new_strides,
                            );
                            if out_ptr.is_null() {
                                return MoltObject::none().bits();
                            }
                            return MoltObject::from_ptr(out_ptr).bits();
                        }
                    }
                    if ndim > 1 {
                        return raise_exception::<_>(
                            _py,
                            "NotImplementedError",
                            "multi-dimensional sub-views are not implemented",
                        );
                    }
                    let Some(idx) = index_i64_with_overflow(
                        _py,
                        key_bits,
                        "memoryview: invalid slice key",
                        None,
                    ) else {
                        return MoltObject::none().bits();
                    };
                    let len = shape[0] as i64;
                    let mut i = idx;
                    if i < 0 {
                        i += len;
                    }
                    if i < 0 || i >= len {
                        return raise_exception::<_>(
                            _py,
                            "IndexError",
                            "index out of bounds on dimension 1",
                        );
                    }
                    let pos = memoryview_offset(ptr) + (i as isize) * strides[0];
                    if pos < 0 || pos + fmt.itemsize as isize > base.len() as isize {
                        return raise_exception::<_>(
                            _py,
                            "IndexError",
                            "index out of bounds on dimension 1",
                        );
                    }
                    let val = memoryview_read_scalar(_py, base, pos, fmt);
                    return val.unwrap_or_else(|| MoltObject::none().bits());
                }
                if type_id == TYPE_ID_STRING
                    || type_id == TYPE_ID_BYTES
                    || type_id == TYPE_ID_BYTEARRAY
                {
                    if let Some(slice_ptr) = key.as_ptr() {
                        if object_type_id(slice_ptr) == TYPE_ID_SLICE {
                            let bytes = if type_id == TYPE_ID_STRING {
                                std::slice::from_raw_parts(string_bytes(ptr), string_len(ptr))
                            } else {
                                std::slice::from_raw_parts(bytes_data(ptr), bytes_len(ptr))
                            };
                            let len = if type_id == TYPE_ID_STRING {
                                utf8_codepoint_count_cached(_py, bytes, Some(ptr as usize)) as isize
                            } else {
                                bytes.len() as isize
                            };
                            let start_obj = obj_from_bits(slice_start_bits(slice_ptr));
                            let stop_obj = obj_from_bits(slice_stop_bits(slice_ptr));
                            let step_obj = obj_from_bits(slice_step_bits(slice_ptr));
                            let (start, stop, step) = match normalize_slice_indices(
                                _py, len, start_obj, stop_obj, step_obj,
                            ) {
                                Ok(vals) => vals,
                                Err(err) => return slice_error(_py, err),
                            };
                            let out_ptr = if step == 1 {
                                let s = start as usize;
                                let e = stop as usize;
                                if s >= e {
                                    if type_id == TYPE_ID_STRING {
                                        alloc_string(_py, &[])
                                    } else if type_id == TYPE_ID_BYTES {
                                        alloc_bytes(_py, &[])
                                    } else {
                                        alloc_bytearray(_py, &[])
                                    }
                                } else if type_id == TYPE_ID_STRING {
                                    let start_byte = utf8_char_to_byte_index_cached(
                                        _py,
                                        bytes,
                                        s as i64,
                                        Some(ptr as usize),
                                    );
                                    let end_byte = utf8_char_to_byte_index_cached(
                                        _py,
                                        bytes,
                                        e as i64,
                                        Some(ptr as usize),
                                    );
                                    alloc_string(_py, &bytes[start_byte..end_byte])
                                } else if type_id == TYPE_ID_BYTES {
                                    alloc_bytes(_py, &bytes[s..e])
                                } else {
                                    alloc_bytearray(_py, &bytes[s..e])
                                }
                            } else {
                                let indices = collect_slice_indices(start, stop, step);
                                let mut out = Vec::with_capacity(indices.len());
                                if type_id == TYPE_ID_STRING {
                                    for idx in indices {
                                        if let Some(code) = wtf8_codepoint_at(bytes, idx) {
                                            push_wtf8_codepoint(&mut out, code.to_u32());
                                        }
                                    }
                                } else {
                                    for idx in indices {
                                        out.push(bytes[idx]);
                                    }
                                }
                                if type_id == TYPE_ID_STRING {
                                    alloc_string(_py, &out)
                                } else if type_id == TYPE_ID_BYTES {
                                    alloc_bytes(_py, &out)
                                } else {
                                    alloc_bytearray(_py, &out)
                                }
                            };
                            if out_ptr.is_null() {
                                return MoltObject::none().bits();
                            }
                            return MoltObject::from_ptr(out_ptr).bits();
                        }
                    }
                    let type_err = if type_id == TYPE_ID_STRING {
                        format!(
                            "string indices must be integers, not '{}'",
                            type_name(_py, key)
                        )
                    } else if type_id == TYPE_ID_BYTES {
                        format!(
                            "byte indices must be integers or slices, not {}",
                            type_name(_py, key)
                        )
                    } else {
                        format!(
                            "bytearray indices must be integers or slices, not {}",
                            type_name(_py, key)
                        )
                    };
                    let Some(idx) = index_i64_with_overflow(_py, key_bits, &type_err, None) else {
                        return MoltObject::none().bits();
                    };
                    if type_id == TYPE_ID_STRING {
                        let bytes = std::slice::from_raw_parts(string_bytes(ptr), string_len(ptr));
                        let mut i = idx;
                        let len = utf8_codepoint_count_cached(_py, bytes, Some(ptr as usize));
                        if i < 0 {
                            i += len;
                        }
                        if i < 0 || i >= len {
                            return raise_exception::<_>(
                                _py,
                                "IndexError",
                                "string index out of range",
                            );
                        }
                        let Some(code) = wtf8_codepoint_at(bytes, i as usize) else {
                            return raise_exception::<_>(
                                _py,
                                "IndexError",
                                "string index out of range",
                            );
                        };
                        let mut out = Vec::with_capacity(4);
                        push_wtf8_codepoint(&mut out, code.to_u32());
                        let out_ptr = alloc_string(_py, &out);
                        if out_ptr.is_null() {
                            return MoltObject::none().bits();
                        }
                        return MoltObject::from_ptr(out_ptr).bits();
                    }
                    let bytes = std::slice::from_raw_parts(bytes_data(ptr), bytes_len(ptr));
                    let len = bytes.len() as i64;
                    let mut i = idx;
                    if i < 0 {
                        i += len;
                    }
                    if i < 0 || i >= len {
                        if type_id == TYPE_ID_BYTEARRAY {
                            return raise_exception::<_>(
                                _py,
                                "IndexError",
                                "bytearray index out of range",
                            );
                        }
                        return raise_exception::<_>(_py, "IndexError", "index out of range");
                    }
                    return MoltObject::from_int(bytes[i as usize] as i64).bits();
                }
                if type_id == TYPE_ID_LIST {
                    if let Some(slice_ptr) = key.as_ptr() {
                        if object_type_id(slice_ptr) == TYPE_ID_SLICE {
                            let elems = seq_vec_ref(ptr);
                            let len = elems.len() as isize;
                            let start_obj = obj_from_bits(slice_start_bits(slice_ptr));
                            let stop_obj = obj_from_bits(slice_stop_bits(slice_ptr));
                            let step_obj = obj_from_bits(slice_step_bits(slice_ptr));
                            let (start, stop, step) = match normalize_slice_indices(
                                _py, len, start_obj, stop_obj, step_obj,
                            ) {
                                Ok(vals) => vals,
                                Err(err) => return slice_error(_py, err),
                            };
                            let out_ptr = if step == 1 {
                                let s = start as usize;
                                let e = stop as usize;
                                if s >= e {
                                    alloc_list(_py, &[])
                                } else {
                                    alloc_list(_py, &elems[s..e])
                                }
                            } else {
                                let indices = collect_slice_indices(start, stop, step);
                                let mut out = Vec::with_capacity(indices.len());
                                for idx in indices {
                                    out.push(elems[idx]);
                                }
                                alloc_list(_py, out.as_slice())
                            };
                            if out_ptr.is_null() {
                                return MoltObject::none().bits();
                            }
                            return MoltObject::from_ptr(out_ptr).bits();
                        }
                    }
                    let idx = if let Some(i) = to_i64(key) {
                        i
                    } else {
                        let key_type = type_name(_py, key);
                        if debug_index_enabled() {
                            eprintln!(
                                "molt index type-error op=get container=list key_type={} key_bits=0x{:x} key_float={:?}",
                                key_type,
                                key_bits,
                                key.as_float()
                            );
                        }
                        let type_err =
                            format!("list indices must be integers or slices, not {}", key_type);
                        let Some(i) = index_i64_with_overflow(_py, key_bits, &type_err, None)
                        else {
                            return MoltObject::none().bits();
                        };
                        i
                    };
                    let len = list_len(ptr) as i64;
                    let mut i = idx;
                    if i < 0 {
                        i += len;
                    }
                    if i < 0 || i >= len {
                        if debug_index_enabled() {
                            let task = crate::current_task_key()
                                .map(|slot| slot.0 as usize)
                                .unwrap_or(0);
                            eprintln!(
                                "molt index oob task=0x{:x} type=list len={} idx={}",
                                task, len, i
                            );
                        }
                        return raise_exception::<_>(_py, "IndexError", "list index out of range");
                    }
                    let elems = seq_vec_ref(ptr);
                    let val = elems[i as usize];
                    if debug_index_list_enabled() {
                        let val_obj = obj_from_bits(val);
                        eprintln!(
                            "molt_index list obj=0x{:x} idx={} val_type={} val_bits=0x{:x}",
                            obj_bits,
                            i,
                            type_name(_py, val_obj),
                            val
                        );
                    }
                    inc_ref_bits(_py, val);
                    return val;
                }
                if type_id == TYPE_ID_TUPLE {
                    if let Some(slice_ptr) = key.as_ptr() {
                        if object_type_id(slice_ptr) == TYPE_ID_SLICE {
                            let elems = seq_vec_ref(ptr);
                            let len = elems.len() as isize;
                            let start_obj = obj_from_bits(slice_start_bits(slice_ptr));
                            let stop_obj = obj_from_bits(slice_stop_bits(slice_ptr));
                            let step_obj = obj_from_bits(slice_step_bits(slice_ptr));
                            let (start, stop, step) = match normalize_slice_indices(
                                _py, len, start_obj, stop_obj, step_obj,
                            ) {
                                Ok(vals) => vals,
                                Err(err) => return slice_error(_py, err),
                            };
                            let out_ptr = if step == 1 {
                                let s = start as usize;
                                let e = stop as usize;
                                if s >= e {
                                    alloc_tuple(_py, &[])
                                } else {
                                    alloc_tuple(_py, &elems[s..e])
                                }
                            } else {
                                let indices = collect_slice_indices(start, stop, step);
                                let mut out = Vec::with_capacity(indices.len());
                                for idx in indices {
                                    out.push(elems[idx]);
                                }
                                alloc_tuple(_py, out.as_slice())
                            };
                            if out_ptr.is_null() {
                                return MoltObject::none().bits();
                            }
                            return MoltObject::from_ptr(out_ptr).bits();
                        }
                    }
                    let idx = if let Some(i) = to_i64(key) {
                        i
                    } else {
                        let key_type = type_name(_py, key);
                        if debug_index_enabled() {
                            eprintln!(
                                "molt index type-error op=get container=tuple key_type={} key_bits=0x{:x} key_float={:?}",
                                key_type,
                                key_bits,
                                key.as_float()
                            );
                        }
                        let type_err =
                            format!("tuple indices must be integers or slices, not {}", key_type);
                        let Some(i) = index_i64_with_overflow(_py, key_bits, &type_err, None)
                        else {
                            return MoltObject::none().bits();
                        };
                        i
                    };
                    let len = tuple_len(ptr) as i64;
                    let mut i = idx;
                    if i < 0 {
                        i += len;
                    }
                    if i < 0 || i >= len {
                        if debug_index_enabled() {
                            let task = crate::current_task_key()
                                .map(|slot| slot.0 as usize)
                                .unwrap_or(0);
                            eprintln!(
                                "molt index oob task=0x{:x} type=tuple len={} idx={}",
                                task, len, i
                            );
                        }
                        return raise_exception::<_>(_py, "IndexError", "tuple index out of range");
                    }
                    let elems = seq_vec_ref(ptr);
                    let val = elems[i as usize];
                    inc_ref_bits(_py, val);
                    return val;
                }
                if type_id == TYPE_ID_RANGE {
                    if let Some((start_i64, stop_i64, step_i64)) = range_components_i64(ptr) {
                        if let Some(mut idx_i64) = to_i64(key) {
                            if idx_i64 < 0 {
                                let len = range_len_i128(start_i64, stop_i64, step_i64);
                                let adj = (idx_i64 as i128) + len;
                                if adj < 0 {
                                    return raise_exception::<_>(
                                        _py,
                                        "IndexError",
                                        "range object index out of range",
                                    );
                                }
                                idx_i64 = match i64::try_from(adj) {
                                    Ok(v) => v,
                                    Err(_) => {
                                        return raise_exception::<_>(
                                            _py,
                                            "IndexError",
                                            "range object index out of range",
                                        );
                                    }
                                };
                            }
                            if let Some(value) = range_value_at_index_i64(
                                start_i64,
                                stop_i64,
                                step_i64,
                                idx_i64 as i128,
                            ) {
                                return MoltObject::from_int(value).bits();
                            }
                            return raise_exception::<_>(
                                _py,
                                "IndexError",
                                "range object index out of range",
                            );
                        }
                    }
                    let type_err = format!(
                        "range indices must be integers or slices, not {}",
                        type_name(_py, key)
                    );
                    let Some(mut idx) = index_bigint_from_obj(_py, key_bits, &type_err) else {
                        return MoltObject::none().bits();
                    };
                    let Some((start, stop, step)) = range_components_bigint(ptr) else {
                        return MoltObject::none().bits();
                    };
                    let len = range_len_bigint(&start, &stop, &step);
                    if idx.is_negative() {
                        idx += &len;
                    }
                    if idx.is_negative() || idx >= len {
                        return raise_exception::<_>(
                            _py,
                            "IndexError",
                            "range object index out of range",
                        );
                    }
                    let val = start + step * idx;
                    return int_bits_from_bigint(_py, val);
                }
                if let Some(dict_bits) = dict_like_bits_from_ptr(_py, ptr) {
                    let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() else {
                        return MoltObject::none().bits();
                    };
                    if let Some(val) = dict_get_in_place(_py, dict_ptr, key_bits) {
                        inc_ref_bits(_py, val);
                        return val;
                    }
                    if object_type_id(ptr) != TYPE_ID_DICT {
                        if let Some(name_bits) = attr_name_bits_from_bytes(_py, b"__missing__") {
                            if let Some(call_bits) =
                                attr_lookup_ptr_allow_missing(_py, ptr, name_bits)
                            {
                                dec_ref_bits(_py, name_bits);
                                let res = call_callable1(_py, call_bits, key_bits);
                                dec_ref_bits(_py, call_bits);
                                if exception_pending(_py) {
                                    return MoltObject::none().bits();
                                }
                                return res;
                            }
                            dec_ref_bits(_py, name_bits);
                            if exception_pending(_py) {
                                return MoltObject::none().bits();
                            }
                        }
                    }
                    return raise_key_error_with_key(_py, key_bits);
                }
                if type_id == TYPE_ID_DICT_KEYS_VIEW
                    || type_id == TYPE_ID_DICT_VALUES_VIEW
                    || type_id == TYPE_ID_DICT_ITEMS_VIEW
                {
                    let view_name = type_name(_py, obj);
                    let msg = format!("'{}' object is not subscriptable", view_name);
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
                if type_id == TYPE_ID_TYPE {
                    if let Some(name_bits) = attr_name_bits_from_bytes(_py, b"__class_getitem__") {
                        if let Some(call_bits) =
                            class_attr_lookup(_py, ptr, ptr, Some(ptr), name_bits)
                        {
                            dec_ref_bits(_py, name_bits);
                            exception_stack_push();
                            let res = call_callable1(_py, call_bits, key_bits);
                            dec_ref_bits(_py, call_bits);
                            if exception_pending(_py) {
                                exception_stack_pop(_py);
                                return MoltObject::none().bits();
                            }
                            exception_stack_pop(_py);
                            return res;
                        }
                        dec_ref_bits(_py, name_bits);
                    }
                }
                if let Some(name_bits) = attr_name_bits_from_bytes(_py, b"__getitem__") {
                    if let Some(call_bits) = attr_lookup_ptr(_py, ptr, name_bits) {
                        dec_ref_bits(_py, name_bits);
                        exception_stack_push();
                        let res = call_callable1(_py, call_bits, key_bits);
                        dec_ref_bits(_py, call_bits);
                        if exception_pending(_py) {
                            exception_stack_pop(_py);
                            return MoltObject::none().bits();
                        }
                        exception_stack_pop(_py);
                        return res;
                    }
                    dec_ref_bits(_py, name_bits);
                }
            }
            let msg = if unsafe { object_type_id(ptr) } == TYPE_ID_TYPE {
                let class_name =
                    unsafe { string_obj_to_owned(obj_from_bits(class_name_bits(ptr))) }
                        .unwrap_or_else(|| "object".to_string());
                format!("type '{}' is not subscriptable", class_name)
            } else {
                format!("'{}' object is not subscriptable", type_name(_py, obj))
            };
            return raise_exception::<_>(_py, "TypeError", &msg);
        }
        let msg = format!("'{}' object is not subscriptable", type_name(_py, obj));
        raise_exception::<_>(_py, "TypeError", &msg)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_store_index(obj_bits: u64, key_bits: u64, val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(obj_bits);
        let key = obj_from_bits(key_bits);
        if let Some(ptr) = obj.as_ptr() {
            unsafe {
                let type_id = object_type_id(ptr);
                if type_id == TYPE_ID_LIST {
                    if let Some(slice_ptr) = key.as_ptr() {
                        if object_type_id(slice_ptr) == TYPE_ID_SLICE {
                            let len = list_len(ptr) as isize;
                            let start_obj = obj_from_bits(slice_start_bits(slice_ptr));
                            let stop_obj = obj_from_bits(slice_stop_bits(slice_ptr));
                            let step_obj = obj_from_bits(slice_step_bits(slice_ptr));
                            let (start, stop, step) = match normalize_slice_indices(
                                _py, len, start_obj, stop_obj, step_obj,
                            ) {
                                Ok(vals) => vals,
                                Err(err) => return slice_error(_py, err),
                            };
                            let new_items = match collect_iterable_values(
                                _py,
                                val_bits,
                                "must assign iterable to extended slice",
                            ) {
                                Some(items) => items,
                                None => return MoltObject::none().bits(),
                            };
                            let elems = seq_vec(ptr);
                            if step == 1 {
                                let s = start as usize;
                                let mut e = stop as usize;
                                if s > e {
                                    e = s;
                                }
                                for &item in new_items.iter() {
                                    inc_ref_bits(_py, item);
                                }
                                let removed: Vec<u64> =
                                    elems.splice(s..e, new_items.iter().copied()).collect();
                                for old_bits in removed {
                                    dec_ref_bits(_py, old_bits);
                                }
                                return obj_bits;
                            }
                            let indices = collect_slice_indices(start, stop, step);
                            if indices.len() != new_items.len() {
                                return raise_exception::<_>(
                                    _py,
                                    "ValueError",
                                    &format!(
                                        "attempt to assign sequence of size {} to extended slice of size {}",
                                        new_items.len(),
                                        indices.len()
                                    ),
                                );
                            }
                            for &item in new_items.iter() {
                                inc_ref_bits(_py, item);
                            }
                            for (idx, &item) in indices.iter().zip(new_items.iter()) {
                                let old_bits = elems[*idx];
                                if old_bits != item {
                                    dec_ref_bits(_py, old_bits);
                                    elems[*idx] = item;
                                }
                            }
                            return obj_bits;
                        }
                    }
                    let idx = if let Some(i) = to_i64(key) {
                        i
                    } else {
                        let key_type = type_name(_py, key);
                        if debug_index_enabled() {
                            eprintln!(
                                "molt index type-error op=set container=list key_type={} key_bits=0x{:x} key_float={:?}",
                                key_type,
                                key_bits,
                                key.as_float()
                            );
                        }
                        let type_err =
                            format!("list indices must be integers or slices, not {}", key_type);
                        let Some(i) = index_i64_with_overflow(_py, key_bits, &type_err, None)
                        else {
                            return MoltObject::none().bits();
                        };
                        i
                    };
                    if debug_store_index_enabled() {
                        let val_obj = obj_from_bits(val_bits);
                        eprintln!(
                            "molt_store_index list obj=0x{:x} idx={} val_type={} val_bits=0x{:x}",
                            obj_bits,
                            idx,
                            type_name(_py, val_obj),
                            val_bits
                        );
                    }
                    let len = list_len(ptr) as i64;
                    let mut i = idx;
                    if i < 0 {
                        i += len;
                    }
                    if i < 0 || i >= len {
                        return raise_exception::<_>(
                            _py,
                            "IndexError",
                            "list assignment index out of range",
                        );
                    }
                    let elems = seq_vec(ptr);
                    let old_bits = elems[i as usize];
                    if old_bits != val_bits {
                        dec_ref_bits(_py, old_bits);
                        inc_ref_bits(_py, val_bits);
                        elems[i as usize] = val_bits;
                    }
                    return obj_bits;
                }
                if type_id == TYPE_ID_TUPLE {
                    return MoltObject::none().bits();
                }
                if type_id == TYPE_ID_BYTEARRAY {
                    if let Some(slice_ptr) = key.as_ptr() {
                        if object_type_id(slice_ptr) == TYPE_ID_SLICE {
                            let len = bytes_len(ptr) as isize;
                            let start_obj = obj_from_bits(slice_start_bits(slice_ptr));
                            let stop_obj = obj_from_bits(slice_stop_bits(slice_ptr));
                            let step_obj = obj_from_bits(slice_step_bits(slice_ptr));
                            let (start, stop, step) = match normalize_slice_indices(
                                _py, len, start_obj, stop_obj, step_obj,
                            ) {
                                Ok(vals) => vals,
                                Err(err) => return slice_error(_py, err),
                            };
                            let src_bytes = match collect_bytearray_assign_bytes(_py, val_bits) {
                                Some(bytes) => bytes,
                                None => return MoltObject::none().bits(),
                            };
                            let elems = bytearray_vec(ptr);
                            if step == 1 {
                                let s = start as usize;
                                let mut e = stop as usize;
                                if s > e {
                                    e = s;
                                }
                                elems.splice(s..e, src_bytes.iter().copied());
                                return obj_bits;
                            }
                            let indices = collect_slice_indices(start, stop, step);
                            if indices.len() != src_bytes.len() {
                                return raise_exception::<_>(
                                    _py,
                                    "ValueError",
                                    &format!(
                                        "attempt to assign bytes of size {} to extended slice of size {}",
                                        src_bytes.len(),
                                        indices.len()
                                    ),
                                );
                            }
                            for (idx, byte) in indices.iter().zip(src_bytes.iter()) {
                                elems[*idx] = *byte;
                            }
                            return obj_bits;
                        }
                    }
                    let type_err = format!(
                        "bytearray indices must be integers or slices, not {}",
                        type_name(_py, key)
                    );
                    let Some(idx) = index_i64_with_overflow(_py, key_bits, &type_err, None) else {
                        return MoltObject::none().bits();
                    };
                    let len = bytes_len(ptr) as i64;
                    let mut i = idx;
                    if i < 0 {
                        i += len;
                    }
                    if i < 0 || i >= len {
                        return raise_exception::<_>(
                            _py,
                            "IndexError",
                            "bytearray index out of range",
                        );
                    }
                    let Some(byte) = bytes_item_to_u8(_py, val_bits, BytesCtorKind::Bytearray)
                    else {
                        return MoltObject::none().bits();
                    };
                    let elems = bytearray_vec(ptr);
                    elems[i as usize] = byte;
                    return obj_bits;
                }
                if type_id == TYPE_ID_MEMORYVIEW {
                    if memoryview_readonly(ptr) {
                        return raise_exception::<_>(
                            _py,
                            "TypeError",
                            "cannot modify read-only memory",
                        );
                    }
                    let owner_bits = memoryview_owner_bits(ptr);
                    let owner = obj_from_bits(owner_bits);
                    let owner_ptr = match owner.as_ptr() {
                        Some(ptr) => ptr,
                        None => return MoltObject::none().bits(),
                    };
                    if object_type_id(owner_ptr) != TYPE_ID_BYTEARRAY {
                        return raise_exception::<_>(
                            _py,
                            "TypeError",
                            "memoryview is not writable",
                        );
                    }
                    let fmt = match memoryview_format_from_bits(memoryview_format_bits(ptr)) {
                        Some(fmt) => fmt,
                        None => return MoltObject::none().bits(),
                    };
                    let shape = memoryview_shape(ptr).unwrap_or(&[]);
                    let strides = memoryview_strides(ptr).unwrap_or(&[]);
                    let ndim = shape.len();
                    let data = bytearray_vec(owner_ptr);
                    if ndim == 0 {
                        if let Some(tup_ptr) = key.as_ptr() {
                            if object_type_id(tup_ptr) == TYPE_ID_TUPLE {
                                let elems = seq_vec_ref(tup_ptr);
                                if elems.is_empty() {
                                    let ok = memoryview_write_scalar(
                                        _py,
                                        data.as_mut_slice(),
                                        memoryview_offset(ptr),
                                        fmt,
                                        val_bits,
                                    );
                                    if ok.is_none() {
                                        return MoltObject::none().bits();
                                    }
                                    return obj_bits;
                                }
                            }
                        }
                        return raise_exception::<_>(
                            _py,
                            "TypeError",
                            "invalid indexing of 0-dim memory",
                        );
                    }
                    if let Some(tup_ptr) = key.as_ptr() {
                        if object_type_id(tup_ptr) == TYPE_ID_TUPLE {
                            let elems = seq_vec_ref(tup_ptr);
                            let mut has_slice = false;
                            let mut all_slice = true;
                            for &elem_bits in elems.iter() {
                                let elem_obj = obj_from_bits(elem_bits);
                                if let Some(elem_ptr) = elem_obj.as_ptr() {
                                    if object_type_id(elem_ptr) == TYPE_ID_SLICE {
                                        has_slice = true;
                                    } else {
                                        all_slice = false;
                                    }
                                } else {
                                    all_slice = false;
                                }
                            }
                            if has_slice {
                                if all_slice {
                                    return raise_exception::<_>(
                                        _py,
                                        "NotImplementedError",
                                        "memoryview slice assignments are currently restricted to ndim = 1",
                                    );
                                }
                                return raise_exception::<_>(
                                    _py,
                                    "TypeError",
                                    "memoryview: invalid slice key",
                                );
                            }
                            if elems.len() < ndim {
                                return raise_exception::<_>(
                                    _py,
                                    "NotImplementedError",
                                    "sub-views are not implemented",
                                );
                            }
                            if elems.len() > ndim {
                                let msg = format!(
                                    "cannot index {}-dimension view with {}-element tuple",
                                    ndim,
                                    elems.len()
                                );
                                return raise_exception::<_>(_py, "TypeError", &msg);
                            }
                            if shape.len() != strides.len() {
                                return MoltObject::none().bits();
                            }
                            let mut pos = memoryview_offset(ptr);
                            for (dim, &elem_bits) in elems.iter().enumerate() {
                                let Some(idx) = index_i64_with_overflow(
                                    _py,
                                    elem_bits,
                                    "memoryview: invalid slice key",
                                    None,
                                ) else {
                                    return MoltObject::none().bits();
                                };
                                let mut i = idx;
                                let dim_len = shape[dim];
                                let dim_len_i64 = dim_len as i64;
                                if i < 0 {
                                    i += dim_len_i64;
                                }
                                if i < 0 || i >= dim_len_i64 {
                                    let msg =
                                        format!("index out of bounds on dimension {}", dim + 1);
                                    return raise_exception::<_>(_py, "IndexError", &msg);
                                }
                                pos = pos.saturating_add((i as isize).saturating_mul(strides[dim]));
                            }
                            if pos < 0 || pos + fmt.itemsize as isize > data.len() as isize {
                                return raise_exception::<_>(
                                    _py,
                                    "IndexError",
                                    "index out of bounds on dimension 1",
                                );
                            }
                            let ok = memoryview_write_scalar(
                                _py,
                                data.as_mut_slice(),
                                pos,
                                fmt,
                                val_bits,
                            );
                            if ok.is_none() {
                                return MoltObject::none().bits();
                            }
                            return obj_bits;
                        }
                    }
                    if let Some(slice_ptr) = key.as_ptr() {
                        if object_type_id(slice_ptr) == TYPE_ID_SLICE {
                            if ndim != 1 {
                                return raise_exception::<_>(
                                    _py,
                                    "NotImplementedError",
                                    "memoryview slice assignments are currently restricted to ndim = 1",
                                );
                            }
                            let len = shape[0];
                            let start_obj = obj_from_bits(slice_start_bits(slice_ptr));
                            let stop_obj = obj_from_bits(slice_stop_bits(slice_ptr));
                            let step_obj = obj_from_bits(slice_step_bits(slice_ptr));
                            let (start, stop, step) = match normalize_slice_indices(
                                _py, len, start_obj, stop_obj, step_obj,
                            ) {
                                Ok(vals) => vals,
                                Err(err) => return slice_error(_py, err),
                            };
                            let indices = collect_slice_indices(start, stop, step);
                            let elem_count = indices.len();
                            let val_obj = obj_from_bits(val_bits);
                            let src_bytes = if let Some(src_ptr) = val_obj.as_ptr() {
                                let src_type = object_type_id(src_ptr);
                                if src_type == TYPE_ID_BYTES || src_type == TYPE_ID_BYTEARRAY {
                                    if fmt.code != b'B' {
                                        return raise_exception::<_>(
                                            _py,
                                            "ValueError",
                                            "memoryview assignment: lvalue and rvalue have different structures",
                                        );
                                    }
                                    bytes_like_slice_raw(src_ptr).unwrap_or(&[]).to_vec()
                                } else if src_type == TYPE_ID_MEMORYVIEW {
                                    let src_fmt = match memoryview_format_from_bits(
                                        memoryview_format_bits(src_ptr),
                                    ) {
                                        Some(fmt) => fmt,
                                        None => return MoltObject::none().bits(),
                                    };
                                    let src_shape = memoryview_shape(src_ptr).unwrap_or(&[]);
                                    if src_fmt.code != fmt.code
                                        || src_shape.len() != 1
                                        || src_shape[0] as usize != elem_count
                                    {
                                        return raise_exception::<_>(
                                            _py,
                                            "ValueError",
                                            "memoryview assignment: lvalue and rvalue have different structures",
                                        );
                                    }
                                    match memoryview_collect_bytes(src_ptr) {
                                        Some(buf) => buf,
                                        None => return MoltObject::none().bits(),
                                    }
                                } else {
                                    return raise_exception::<_>(
                                        _py,
                                        "TypeError",
                                        &format!(
                                            "a bytes-like object is required, not '{}'",
                                            type_name(_py, val_obj)
                                        ),
                                    );
                                }
                            } else {
                                return raise_exception::<_>(
                                    _py,
                                    "TypeError",
                                    &format!(
                                        "a bytes-like object is required, not '{}'",
                                        type_name(_py, val_obj)
                                    ),
                                );
                            };
                            let expected = elem_count * fmt.itemsize;
                            if src_bytes.len() != expected {
                                return raise_exception::<_>(
                                    _py,
                                    "ValueError",
                                    "memoryview assignment: lvalue and rvalue have different structures",
                                );
                            }
                            let base_offset = memoryview_offset(ptr);
                            let base_stride = strides[0];
                            let mut pos = base_offset + start * base_stride;
                            let step_stride = base_stride * step;
                            let mut idx = 0usize;
                            while idx < src_bytes.len() {
                                if pos < 0 || pos + fmt.itemsize as isize > data.len() as isize {
                                    return MoltObject::none().bits();
                                }
                                let start = pos as usize;
                                let end = start + fmt.itemsize;
                                data[start..end]
                                    .copy_from_slice(&src_bytes[idx..idx + fmt.itemsize]);
                                idx += fmt.itemsize;
                                pos += step_stride;
                            }
                            return obj_bits;
                        }
                    }
                    if ndim != 1 {
                        return raise_exception::<_>(
                            _py,
                            "NotImplementedError",
                            "sub-views are not implemented",
                        );
                    }
                    let Some(idx) = index_i64_with_overflow(
                        _py,
                        key_bits,
                        "memoryview: invalid slice key",
                        None,
                    ) else {
                        return MoltObject::none().bits();
                    };
                    let len = shape[0] as i64;
                    let mut i = idx;
                    if i < 0 {
                        i += len;
                    }
                    if i < 0 || i >= len {
                        return raise_exception::<_>(
                            _py,
                            "IndexError",
                            "index out of bounds on dimension 1",
                        );
                    }
                    let pos = memoryview_offset(ptr) + (i as isize) * strides[0];
                    if pos < 0 || pos + fmt.itemsize as isize > data.len() as isize {
                        return raise_exception::<_>(
                            _py,
                            "IndexError",
                            "index out of bounds on dimension 1",
                        );
                    }
                    let ok = memoryview_write_scalar(_py, data.as_mut_slice(), pos, fmt, val_bits);
                    if ok.is_none() {
                        return MoltObject::none().bits();
                    }
                    return obj_bits;
                }
                if type_id == TYPE_ID_OBJECT {
                    let class_bits = object_class_bits(ptr);
                    if class_bits != 0 {
                        let builtins = builtin_classes(_py);
                        if issubclass_bits(class_bits, builtins.dict) {
                            if let Some(name_bits) = attr_name_bits_from_bytes(_py, b"__setitem__")
                            {
                                if let Some(call_bits) = attr_lookup_ptr(_py, ptr, name_bits) {
                                    dec_ref_bits(_py, name_bits);
                                    exception_stack_push();
                                    let _ = call_callable2(_py, call_bits, key_bits, val_bits);
                                    dec_ref_bits(_py, call_bits);
                                    if exception_pending(_py) {
                                        exception_stack_pop(_py);
                                        return MoltObject::none().bits();
                                    }
                                    exception_stack_pop(_py);
                                    return obj_bits;
                                }
                                dec_ref_bits(_py, name_bits);
                            }
                        }
                    }
                }
                if let Some(dict_bits) = dict_like_bits_from_ptr(_py, ptr) {
                    let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() else {
                        return MoltObject::none().bits();
                    };
                    dict_set_in_place(_py, dict_ptr, key_bits, val_bits);
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    return obj_bits;
                }
                if let Some(name_bits) = attr_name_bits_from_bytes(_py, b"__setitem__") {
                    if let Some(call_bits) = attr_lookup_ptr(_py, ptr, name_bits) {
                        dec_ref_bits(_py, name_bits);
                        exception_stack_push();
                        let _ = call_callable2(_py, call_bits, key_bits, val_bits);
                        dec_ref_bits(_py, call_bits);
                        if exception_pending(_py) {
                            exception_stack_pop(_py);
                            return MoltObject::none().bits();
                        }
                        exception_stack_pop(_py);
                        return obj_bits;
                    }
                    dec_ref_bits(_py, name_bits);
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_dict_update_missing(dict_bits: u64, key_bits: u64, val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let dict_obj = obj_from_bits(dict_bits);
        let key_obj = obj_from_bits(key_bits);
        if dict_obj.as_ptr().is_none() || key_obj.as_ptr().is_none() {
            return MoltObject::none().bits();
        }
        unsafe {
            let Some(container_ptr) = dict_obj.as_ptr() else {
                return MoltObject::none().bits();
            };
            let Some(real_dict_bits) = dict_like_bits_from_ptr(_py, container_ptr) else {
                return raise_exception::<_>(
                    _py,
                    "TypeError",
                    &format!(
                        "'{}' object does not support item assignment",
                        type_name(_py, dict_obj)
                    ),
                );
            };
            let Some(real_dict_ptr) = obj_from_bits(real_dict_bits).as_ptr() else {
                return MoltObject::none().bits();
            };
            if object_type_id(real_dict_ptr) != TYPE_ID_DICT {
                return MoltObject::none().bits();
            }
            let missing = missing_bits(_py);
            if val_bits == missing {
                let _ = dict_del_in_place(_py, real_dict_ptr, key_bits);
                if exception_pending(_py) {
                    return MoltObject::none().bits();
                }
                return dict_bits;
            }
            dict_set_in_place(_py, real_dict_ptr, key_bits, val_bits);
            if exception_pending(_py) {
                return MoltObject::none().bits();
            }
            dict_bits
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_del_index(obj_bits: u64, key_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(obj_bits);
        let key = obj_from_bits(key_bits);
        if let Some(ptr) = obj.as_ptr() {
            unsafe {
                let type_id = object_type_id(ptr);
                if type_id == TYPE_ID_LIST {
                    if let Some(slice_ptr) = key.as_ptr() {
                        if object_type_id(slice_ptr) == TYPE_ID_SLICE {
                            let len = list_len(ptr) as isize;
                            let start_obj = obj_from_bits(slice_start_bits(slice_ptr));
                            let stop_obj = obj_from_bits(slice_stop_bits(slice_ptr));
                            let step_obj = obj_from_bits(slice_step_bits(slice_ptr));
                            let (start, stop, step) = match normalize_slice_indices(
                                _py, len, start_obj, stop_obj, step_obj,
                            ) {
                                Ok(vals) => vals,
                                Err(err) => return slice_error(_py, err),
                            };
                            let elems = seq_vec(ptr);
                            if step == 1 {
                                let s = start as usize;
                                let mut e = stop as usize;
                                if s > e {
                                    e = s;
                                }
                                let removed: Vec<u64> = elems.drain(s..e).collect();
                                for old_bits in removed {
                                    dec_ref_bits(_py, old_bits);
                                }
                                return obj_bits;
                            }
                            let indices = collect_slice_indices(start, stop, step);
                            if step > 0 {
                                for &idx in indices.iter().rev() {
                                    let old_bits = elems.remove(idx);
                                    dec_ref_bits(_py, old_bits);
                                }
                            } else {
                                for &idx in indices.iter() {
                                    let old_bits = elems.remove(idx);
                                    dec_ref_bits(_py, old_bits);
                                }
                            }
                            return obj_bits;
                        }
                    }
                    let key_type = type_name(_py, key);
                    if debug_index_enabled() {
                        eprintln!(
                            "molt index type-error op=del container=list key_type={} key_bits=0x{:x} key_float={:?}",
                            key_type,
                            key_bits,
                            key.as_float()
                        );
                    }
                    let type_err =
                        format!("list indices must be integers or slices, not {}", key_type);
                    let Some(idx) = index_i64_with_overflow(_py, key_bits, &type_err, None) else {
                        return MoltObject::none().bits();
                    };
                    let len = list_len(ptr) as i64;
                    let mut i = idx;
                    if i < 0 {
                        i += len;
                    }
                    if i < 0 || i >= len {
                        return raise_exception::<_>(
                            _py,
                            "IndexError",
                            "list assignment index out of range",
                        );
                    }
                    let elems = seq_vec(ptr);
                    let old_bits = elems.remove(i as usize);
                    dec_ref_bits(_py, old_bits);
                    return obj_bits;
                }
                if type_id == TYPE_ID_BYTEARRAY {
                    if let Some(slice_ptr) = key.as_ptr() {
                        if object_type_id(slice_ptr) == TYPE_ID_SLICE {
                            let len = bytes_len(ptr) as isize;
                            let start_obj = obj_from_bits(slice_start_bits(slice_ptr));
                            let stop_obj = obj_from_bits(slice_stop_bits(slice_ptr));
                            let step_obj = obj_from_bits(slice_step_bits(slice_ptr));
                            let (start, stop, step) = match normalize_slice_indices(
                                _py, len, start_obj, stop_obj, step_obj,
                            ) {
                                Ok(vals) => vals,
                                Err(err) => return slice_error(_py, err),
                            };
                            let elems = bytearray_vec(ptr);
                            if step == 1 {
                                let s = start as usize;
                                let mut e = stop as usize;
                                if s > e {
                                    e = s;
                                }
                                elems.drain(s..e);
                                return obj_bits;
                            }
                            let indices = collect_slice_indices(start, stop, step);
                            if step > 0 {
                                for &idx in indices.iter().rev() {
                                    elems.remove(idx);
                                }
                            } else {
                                for &idx in indices.iter() {
                                    elems.remove(idx);
                                }
                            }
                            return obj_bits;
                        }
                    }
                    let type_err = format!(
                        "bytearray indices must be integers or slices, not {}",
                        type_name(_py, key)
                    );
                    let Some(idx) = index_i64_with_overflow(_py, key_bits, &type_err, None) else {
                        return MoltObject::none().bits();
                    };
                    let len = bytes_len(ptr) as i64;
                    let mut i = idx;
                    if i < 0 {
                        i += len;
                    }
                    if i < 0 || i >= len {
                        return raise_exception::<_>(
                            _py,
                            "IndexError",
                            "bytearray index out of range",
                        );
                    }
                    let elems = bytearray_vec(ptr);
                    elems.remove(i as usize);
                    return obj_bits;
                }
                if type_id == TYPE_ID_MEMORYVIEW {
                    if memoryview_readonly(ptr) {
                        return raise_exception::<_>(
                            _py,
                            "TypeError",
                            "cannot modify read-only memory",
                        );
                    }
                    return raise_exception::<_>(_py, "TypeError", "cannot delete memory");
                }
                if let Some(dict_bits) = dict_like_bits_from_ptr(_py, ptr) {
                    let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() else {
                        return MoltObject::none().bits();
                    };
                    let removed = dict_del_in_place(_py, dict_ptr, key_bits);
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    if removed {
                        return obj_bits;
                    }
                    return raise_key_error_with_key(_py, key_bits);
                }
                if let Some(name_bits) = attr_name_bits_from_bytes(_py, b"__delitem__") {
                    if let Some(call_bits) = attr_lookup_ptr(_py, ptr, name_bits) {
                        dec_ref_bits(_py, name_bits);
                        exception_stack_push();
                        let _ = call_callable1(_py, call_bits, key_bits);
                        dec_ref_bits(_py, call_bits);
                        if exception_pending(_py) {
                            exception_stack_pop(_py);
                            return MoltObject::none().bits();
                        }
                        exception_stack_pop(_py);
                        return obj_bits;
                    }
                    dec_ref_bits(_py, name_bits);
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_getitem_method(obj_bits: u64, key_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, { molt_index(obj_bits, key_bits) })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_setitem_method(obj_bits: u64, key_bits: u64, val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(obj_bits);
        if let Some(ptr) = obj.as_ptr() {
            unsafe {
                if let Some(dict_bits) = dict_like_bits_from_ptr(_py, ptr) {
                    let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() else {
                        return MoltObject::none().bits();
                    };
                    dict_set_in_place(_py, dict_ptr, key_bits, val_bits);
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    return MoltObject::none().bits();
                }
            }
        }
        let _ = molt_store_index(obj_bits, key_bits, val_bits);
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_delitem_method(obj_bits: u64, key_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let _ = molt_del_index(obj_bits, key_bits);
        MoltObject::none().bits()
    })
}

unsafe fn eq_bool_from_bits(_py: &PyToken<'_>, lhs_bits: u64, rhs_bits: u64) -> Option<bool> {
    let pending_before = exception_pending(_py);
    let prev_exc_bits = if pending_before {
        exception_last_bits_noinc(_py).unwrap_or(0)
    } else {
        0
    };
    let res_bits = molt_eq(lhs_bits, rhs_bits);
    if exception_pending(_py) {
        if !pending_before {
            return None;
        }
        let after_exc_bits = exception_last_bits_noinc(_py).unwrap_or(0);
        if after_exc_bits != prev_exc_bits {
            return None;
        }
    }
    let res_obj = obj_from_bits(res_bits);
    if pending_before && res_obj.is_none() {
        return Some(obj_eq(
            _py,
            obj_from_bits(lhs_bits),
            obj_from_bits(rhs_bits),
        ));
    }
    Some(is_truthy(_py, res_obj))
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_contains(container_bits: u64, item_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let container = obj_from_bits(container_bits);
        let item = obj_from_bits(item_bits);
        if let Some(ptr) = container.as_ptr() {
            unsafe {
                let type_id = object_type_id(ptr);
                if let Some(dict_bits) = dict_like_bits_from_ptr(_py, ptr) {
                    let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() else {
                        return MoltObject::none().bits();
                    };
                    if !ensure_hashable(_py, item_bits) {
                        return MoltObject::none().bits();
                    }
                    let order = dict_order(dict_ptr);
                    let table = dict_table(dict_ptr);
                    let found = dict_find_entry(_py, order, table, item_bits);
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    return MoltObject::from_bool(found.is_some()).bits();
                }
                match type_id {
                    TYPE_ID_LIST => {
                        let mut idx = 0usize;
                        loop {
                            let elem_bits = match list_elem_at(ptr, idx) {
                                Some(val) => val,
                                None => break,
                            };
                            inc_ref_bits(_py, elem_bits);
                            let eq = match eq_bool_from_bits(_py, elem_bits, item_bits) {
                                Some(val) => val,
                                None => {
                                    dec_ref_bits(_py, elem_bits);
                                    return MoltObject::none().bits();
                                }
                            };
                            dec_ref_bits(_py, elem_bits);
                            if eq {
                                return MoltObject::from_bool(true).bits();
                            }
                            idx += 1;
                        }
                        return MoltObject::from_bool(false).bits();
                    }
                    TYPE_ID_TUPLE => {
                        let elems = seq_vec_ref(ptr);
                        for &elem_bits in elems.iter() {
                            let eq = match eq_bool_from_bits(_py, elem_bits, item_bits) {
                                Some(val) => val,
                                None => return MoltObject::none().bits(),
                            };
                            if eq {
                                return MoltObject::from_bool(true).bits();
                            }
                        }
                        return MoltObject::from_bool(false).bits();
                    }
                    TYPE_ID_SET | TYPE_ID_FROZENSET => {
                        if !ensure_hashable(_py, item_bits) {
                            return MoltObject::none().bits();
                        }
                        let order = set_order(ptr);
                        let table = set_table(ptr);
                        let found = set_find_entry(_py, order, table, item_bits);
                        if exception_pending(_py) {
                            return MoltObject::none().bits();
                        }
                        return MoltObject::from_bool(found.is_some()).bits();
                    }
                    TYPE_ID_STRING => {
                        let Some(item_ptr) = item.as_ptr() else {
                            return raise_exception::<_>(
                                _py,
                                "TypeError",
                                &format!(
                                    "'in <string>' requires string as left operand, not {}",
                                    type_name(_py, item)
                                ),
                            );
                        };
                        if object_type_id(item_ptr) != TYPE_ID_STRING {
                            return raise_exception::<_>(
                                _py,
                                "TypeError",
                                &format!(
                                    "'in <string>' requires string as left operand, not {}",
                                    type_name(_py, item)
                                ),
                            );
                        }
                        let hay_len = string_len(ptr);
                        let needle_len = string_len(item_ptr);
                        let hay_bytes = std::slice::from_raw_parts(string_bytes(ptr), hay_len);
                        let needle_bytes =
                            std::slice::from_raw_parts(string_bytes(item_ptr), needle_len);
                        if needle_bytes.is_empty() {
                            return MoltObject::from_bool(true).bits();
                        }
                        let idx = bytes_find_impl(hay_bytes, needle_bytes);
                        return MoltObject::from_bool(idx >= 0).bits();
                    }
                    TYPE_ID_BYTES | TYPE_ID_BYTEARRAY => {
                        let hay_len = bytes_len(ptr);
                        let hay_bytes = std::slice::from_raw_parts(bytes_data(ptr), hay_len);
                        if let Some(byte) = item.as_int() {
                            if !(0..=255).contains(&byte) {
                                return raise_exception::<_>(
                                    _py,
                                    "ValueError",
                                    "byte must be in range(0, 256)",
                                );
                            }
                            let found = memchr(byte as u8, hay_bytes).is_some();
                            return MoltObject::from_bool(found).bits();
                        }
                        if let Some(item_ptr) = item.as_ptr() {
                            let item_type = object_type_id(item_ptr);
                            if item_type == TYPE_ID_BYTES || item_type == TYPE_ID_BYTEARRAY {
                                let needle_len = bytes_len(item_ptr);
                                let needle_bytes =
                                    std::slice::from_raw_parts(bytes_data(item_ptr), needle_len);
                                if needle_bytes.is_empty() {
                                    return MoltObject::from_bool(true).bits();
                                }
                                let idx = bytes_find_impl(hay_bytes, needle_bytes);
                                return MoltObject::from_bool(idx >= 0).bits();
                            }
                        }
                        return raise_exception::<_>(
                            _py,
                            "TypeError",
                            &format!(
                                "a bytes-like object is required, not '{}'",
                                type_name(_py, item)
                            ),
                        );
                    }
                    TYPE_ID_RANGE => {
                        let candidate = if let Some(f) = item.as_float() {
                            if !f.is_finite() || f.fract() != 0.0 {
                                return MoltObject::from_bool(false).bits();
                            }
                            bigint_from_f64_trunc(f)
                        } else {
                            let type_err = format!(
                                "'{}' object cannot be interpreted as an integer",
                                type_name(_py, item)
                            );
                            let Some(val) = index_bigint_from_obj(_py, item_bits, &type_err) else {
                                if exception_pending(_py) {
                                    molt_exception_clear();
                                }
                                return MoltObject::from_bool(false).bits();
                            };
                            val
                        };
                        let Some((start, stop, step)) = range_components_bigint(ptr) else {
                            return MoltObject::none().bits();
                        };
                        if step.is_zero() {
                            return MoltObject::from_bool(false).bits();
                        }
                        let in_range = if step.is_positive() {
                            candidate >= start && candidate < stop
                        } else {
                            candidate <= start && candidate > stop
                        };
                        if !in_range {
                            return MoltObject::from_bool(false).bits();
                        }
                        let offset = candidate - start;
                        let step_abs = if step.is_negative() { -step } else { step };
                        let aligned = offset.mod_floor(&step_abs).is_zero();
                        return MoltObject::from_bool(aligned).bits();
                    }
                    TYPE_ID_MEMORYVIEW => {
                        let owner_bits = memoryview_owner_bits(ptr);
                        let owner = obj_from_bits(owner_bits);
                        let owner_ptr = match owner.as_ptr() {
                            Some(ptr) => ptr,
                            None => {
                                return raise_exception::<_>(
                                    _py,
                                    "TypeError",
                                    &format!(
                                        "a bytes-like object is required, not '{}'",
                                        type_name(_py, item)
                                    ),
                                );
                            }
                        };
                        let base = match bytes_like_slice_raw(owner_ptr) {
                            Some(slice) => slice,
                            None => {
                                return raise_exception::<_>(
                                    _py,
                                    "TypeError",
                                    &format!(
                                        "a bytes-like object is required, not '{}'",
                                        type_name(_py, item)
                                    ),
                                );
                            }
                        };
                        let offset = memoryview_offset(ptr);
                        let len = memoryview_len(ptr);
                        let itemsize = memoryview_itemsize(ptr);
                        let stride = memoryview_stride(ptr);
                        if offset < 0 {
                            return raise_exception::<_>(
                                _py,
                                "TypeError",
                                &format!(
                                    "a bytes-like object is required, not '{}'",
                                    type_name(_py, item)
                                ),
                            );
                        }
                        if itemsize != 1 {
                            return raise_exception::<_>(
                                _py,
                                "TypeError",
                                "memoryview itemsize not supported",
                            );
                        }
                        if stride == 1 {
                            let start = offset as usize;
                            let end = start.saturating_add(len);
                            let hay = &base[start.min(base.len())..end.min(base.len())];
                            if let Some(byte) = item.as_int() {
                                if !(0..=255).contains(&byte) {
                                    return raise_exception::<_>(
                                        _py,
                                        "ValueError",
                                        "byte must be in range(0, 256)",
                                    );
                                }
                                let found = memchr(byte as u8, hay).is_some();
                                return MoltObject::from_bool(found).bits();
                            }
                            if let Some(item_ptr) = item.as_ptr() {
                                let item_type = object_type_id(item_ptr);
                                if item_type == TYPE_ID_BYTES || item_type == TYPE_ID_BYTEARRAY {
                                    let needle_len = bytes_len(item_ptr);
                                    let needle_bytes = std::slice::from_raw_parts(
                                        bytes_data(item_ptr),
                                        needle_len,
                                    );
                                    if needle_bytes.is_empty() {
                                        return MoltObject::from_bool(true).bits();
                                    }
                                    let idx = bytes_find_impl(hay, needle_bytes);
                                    return MoltObject::from_bool(idx >= 0).bits();
                                }
                            }
                            return raise_exception::<_>(
                                _py,
                                "TypeError",
                                &format!(
                                    "a bytes-like object is required, not '{}'",
                                    type_name(_py, item)
                                ),
                            );
                        }
                        let mut out = Vec::with_capacity(len);
                        for idx in 0..len {
                            let start = offset + (idx as isize) * stride;
                            if start < 0 {
                                return raise_exception::<_>(
                                    _py,
                                    "TypeError",
                                    &format!(
                                        "a bytes-like object is required, not '{}'",
                                        type_name(_py, item)
                                    ),
                                );
                            }
                            let start = start as usize;
                            if start >= base.len() {
                                break;
                            }
                            out.push(base[start]);
                        }
                        let hay = out.as_slice();
                        if let Some(byte) = item.as_int() {
                            if !(0..=255).contains(&byte) {
                                return raise_exception::<_>(
                                    _py,
                                    "ValueError",
                                    "byte must be in range(0, 256)",
                                );
                            }
                            let found = memchr(byte as u8, hay).is_some();
                            return MoltObject::from_bool(found).bits();
                        }
                        if let Some(item_ptr) = item.as_ptr() {
                            let item_type = object_type_id(item_ptr);
                            if item_type == TYPE_ID_BYTES || item_type == TYPE_ID_BYTEARRAY {
                                let needle_len = bytes_len(item_ptr);
                                let needle_bytes =
                                    std::slice::from_raw_parts(bytes_data(item_ptr), needle_len);
                                if needle_bytes.is_empty() {
                                    return MoltObject::from_bool(true).bits();
                                }
                                let idx = bytes_find_impl(hay, needle_bytes);
                                return MoltObject::from_bool(idx >= 0).bits();
                            }
                        }
                        return raise_exception::<_>(
                            _py,
                            "TypeError",
                            &format!(
                                "a bytes-like object is required, not '{}'",
                                type_name(_py, item)
                            ),
                        );
                    }
                    _ => {}
                }
                if let Some(name_bits) = attr_name_bits_from_bytes(_py, b"__contains__") {
                    if let Some(call_bits) = attr_lookup_ptr_allow_missing(_py, ptr, name_bits) {
                        dec_ref_bits(_py, name_bits);
                        let res_bits = call_callable1(_py, call_bits, item_bits);
                        dec_ref_bits(_py, call_bits);
                        if exception_pending(_py) {
                            return MoltObject::none().bits();
                        }
                        if !is_not_implemented_bits(_py, res_bits) {
                            let truthy = is_truthy(_py, obj_from_bits(res_bits));
                            dec_ref_bits(_py, res_bits);
                            return MoltObject::from_bool(truthy).bits();
                        }
                        dec_ref_bits(_py, res_bits);
                    } else {
                        dec_ref_bits(_py, name_bits);
                    }
                }
                let iter_bits = molt_iter(container_bits);
                if !obj_from_bits(iter_bits).is_none() {
                    loop {
                        let pair_bits = molt_iter_next(iter_bits);
                        let pair_obj = obj_from_bits(pair_bits);
                        let Some(pair_ptr) = pair_obj.as_ptr() else {
                            return raise_exception::<_>(
                                _py,
                                "TypeError",
                                "object is not an iterator",
                            );
                        };
                        if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                            return raise_exception::<_>(
                                _py,
                                "TypeError",
                                "object is not an iterator",
                            );
                        }
                        let elems = seq_vec_ref(pair_ptr);
                        if elems.len() < 2 {
                            return raise_exception::<_>(
                                _py,
                                "TypeError",
                                "object is not an iterator",
                            );
                        }
                        let val_bits = elems[0];
                        let done_bits = elems[1];
                        if is_truthy(_py, obj_from_bits(done_bits)) {
                            return MoltObject::from_bool(false).bits();
                        }
                        if obj_eq(_py, obj_from_bits(val_bits), item) {
                            return MoltObject::from_bool(true).bits();
                        }
                    }
                }
                if let Some(name_bits) = attr_name_bits_from_bytes(_py, b"__getitem__") {
                    if let Some(call_bits) = attr_lookup_ptr_allow_missing(_py, ptr, name_bits) {
                        dec_ref_bits(_py, name_bits);
                        let mut idx = 0i64;
                        loop {
                            let idx_bits = MoltObject::from_int(idx).bits();
                            exception_stack_push();
                            let val_bits = call_callable1(_py, call_bits, idx_bits);
                            if exception_pending(_py) {
                                let exc_bits = molt_exception_last();
                                let exc_obj = obj_from_bits(exc_bits);
                                let mut is_index_error = false;
                                if let Some(exc_ptr) = exc_obj.as_ptr() {
                                    if object_type_id(exc_ptr) == TYPE_ID_EXCEPTION {
                                        let kind_bits = exception_kind_bits(exc_ptr);
                                        let kind_obj = obj_from_bits(kind_bits);
                                        if let Some(kind_ptr) = kind_obj.as_ptr() {
                                            if object_type_id(kind_ptr) == TYPE_ID_STRING {
                                                let bytes = std::slice::from_raw_parts(
                                                    string_bytes(kind_ptr),
                                                    string_len(kind_ptr),
                                                );
                                                if bytes == b"IndexError" {
                                                    is_index_error = true;
                                                }
                                            }
                                        }
                                    }
                                }
                                dec_ref_bits(_py, exc_bits);
                                exception_stack_pop(_py);
                                if is_index_error {
                                    clear_exception(_py);
                                    return MoltObject::from_bool(false).bits();
                                }
                                return MoltObject::none().bits();
                            }
                            exception_stack_pop(_py);
                            if obj_eq(_py, obj_from_bits(val_bits), item) {
                                dec_ref_bits(_py, val_bits);
                                return MoltObject::from_bool(true).bits();
                            }
                            dec_ref_bits(_py, val_bits);
                            idx += 1;
                        }
                    } else {
                        dec_ref_bits(_py, name_bits);
                    }
                }
            }
        }
        raise_exception::<_>(
            _py,
            "TypeError",
            &format!(
                "argument of type '{}' is not iterable",
                type_name(_py, container)
            ),
        )
    })
}

pub(crate) extern "C" fn dict_keys_method(self_bits: u64) -> i64 {
    molt_dict_keys(self_bits) as i64
}

pub(crate) extern "C" fn dict_values_method(self_bits: u64) -> i64 {
    molt_dict_values(self_bits) as i64
}

pub(crate) extern "C" fn dict_items_method(self_bits: u64) -> i64 {
    molt_dict_items(self_bits) as i64
}

pub(crate) extern "C" fn dict_get_method(self_bits: u64, key_bits: u64, default_bits: u64) -> i64 {
    molt_dict_get(self_bits, key_bits, default_bits) as i64
}

pub(crate) extern "C" fn dict_pop_method(
    self_bits: u64,
    key_bits: u64,
    default_bits: u64,
    has_default_bits: u64,
) -> i64 {
    molt_dict_pop(self_bits, key_bits, default_bits, has_default_bits) as i64
}

pub(crate) extern "C" fn dict_clear_method(self_bits: u64) -> i64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(self_bits);
        let Some(ptr) = obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "dict.clear expects dict");
        };
        unsafe {
            if object_type_id(ptr) != TYPE_ID_DICT {
                return raise_exception::<_>(_py, "TypeError", "dict.clear expects dict");
            }
            dict_clear_in_place(_py, ptr);
        }
        MoltObject::none().bits() as i64
    })
}

pub(crate) extern "C" fn dict_copy_method(self_bits: u64) -> i64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(self_bits);
        let Some(ptr) = obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "dict.copy expects dict");
        };
        unsafe {
            if object_type_id(ptr) != TYPE_ID_DICT {
                return raise_exception::<_>(_py, "TypeError", "dict.copy expects dict");
            }
            let pairs = dict_order(ptr).clone();
            let out_ptr = alloc_dict_with_pairs(_py, pairs.as_slice());
            if out_ptr.is_null() {
                return MoltObject::none().bits() as i64;
            }
            MoltObject::from_ptr(out_ptr).bits() as i64
        }
    })
}

pub(crate) extern "C" fn dict_popitem_method(self_bits: u64) -> i64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(self_bits);
        let Some(ptr) = obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "dict.popitem expects dict");
        };
        unsafe {
            if object_type_id(ptr) != TYPE_ID_DICT {
                return raise_exception::<_>(_py, "TypeError", "dict.popitem expects dict");
            }
            let order = dict_order(ptr);
            if order.len() < 2 {
                return raise_exception::<_>(_py, "KeyError", "popitem(): dictionary is empty");
            }
            let key_bits = order[order.len() - 2];
            let val_bits = order[order.len() - 1];
            let item_ptr = alloc_tuple(_py, &[key_bits, val_bits]);
            if item_ptr.is_null() {
                return MoltObject::none().bits() as i64;
            }
            dec_ref_bits(_py, key_bits);
            dec_ref_bits(_py, val_bits);
            order.truncate(order.len() - 2);
            let entries = order.len() / 2;
            let table = dict_table(ptr);
            let capacity = dict_table_capacity(entries.max(1));
            dict_rebuild(_py, order, table, capacity);
            MoltObject::from_ptr(item_ptr).bits() as i64
        }
    })
}

pub(crate) extern "C" fn dict_setdefault_method(
    self_bits: u64,
    key_bits: u64,
    default_bits: u64,
) -> i64 {
    molt_dict_setdefault(self_bits, key_bits, default_bits) as i64
}

pub(crate) extern "C" fn dict_fromkeys_method(
    self_bits: u64,
    iterable_bits: u64,
    default_bits: u64,
) -> i64 {
    crate::with_gil_entry!(_py, {
        let class_bits = if let Some(ptr) = maybe_ptr_from_bits(self_bits) {
            unsafe {
                if object_type_id(ptr) == TYPE_ID_TYPE {
                    self_bits
                } else {
                    type_of_bits(_py, self_bits)
                }
            }
        } else {
            type_of_bits(_py, self_bits)
        };
        let builtins = builtin_classes(_py);
        if !issubclass_bits(class_bits, builtins.dict) {
            return raise_exception::<_>(_py, "TypeError", "dict.fromkeys expects dict type");
        }
        let capacity_hint = {
            let obj = obj_from_bits(iterable_bits);
            let mut hint = if let Some(ptr) = obj.as_ptr() {
                unsafe {
                    match object_type_id(ptr) {
                        TYPE_ID_LIST => list_len(ptr),
                        TYPE_ID_TUPLE => tuple_len(ptr),
                        TYPE_ID_DICT => dict_len(ptr),
                        TYPE_ID_SET | TYPE_ID_FROZENSET => set_len(ptr),
                        TYPE_ID_DICT_KEYS_VIEW
                        | TYPE_ID_DICT_VALUES_VIEW
                        | TYPE_ID_DICT_ITEMS_VIEW => dict_view_len(ptr),
                        TYPE_ID_BYTES | TYPE_ID_BYTEARRAY => bytes_len(ptr),
                        TYPE_ID_STRING => string_len(ptr),
                        TYPE_ID_INTARRAY => intarray_len(ptr),
                        TYPE_ID_RANGE => {
                            if let Some((start, stop, step)) = range_components_bigint(ptr) {
                                let len = range_len_bigint(&start, &stop, &step);
                                len.to_usize().unwrap_or(usize::MAX)
                            } else {
                                0
                            }
                        }
                        _ => 0,
                    }
                }
            } else {
                0
            };
            let max_entries = (isize::MAX as usize) / 2;
            if hint > max_entries {
                hint = max_entries;
            }
            hint
        };
        let dict_bits = if class_bits == builtins.dict {
            molt_dict_new(capacity_hint as u64)
        } else {
            let Some(class_ptr) = obj_from_bits(class_bits).as_ptr() else {
                return MoltObject::none().bits() as i64;
            };
            unsafe { call_class_init_with_args(_py, class_ptr, &[]) }
        };
        if exception_pending(_py) {
            return MoltObject::none().bits() as i64;
        }
        let iter_bits = molt_iter(iterable_bits);
        if obj_from_bits(iter_bits).is_none() {
            return raise_not_iterable(_py, iterable_bits);
        }
        loop {
            let pair_bits = molt_iter_next(iter_bits);
            if exception_pending(_py) {
                return MoltObject::none().bits() as i64;
            }
            let pair_obj = obj_from_bits(pair_bits);
            let Some(pair_ptr) = pair_obj.as_ptr() else {
                return MoltObject::none().bits() as i64;
            };
            unsafe {
                if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                    return raise_exception::<_>(_py, "TypeError", "object is not an iterator");
                }
                let elems = seq_vec_ref(pair_ptr);
                if elems.len() < 2 {
                    return raise_exception::<_>(_py, "TypeError", "object is not an iterator");
                }
                let done_bits = elems[1];
                if is_truthy(_py, obj_from_bits(done_bits)) {
                    break;
                }
                let key_bits = elems[0];
                let _ = molt_store_index(dict_bits, key_bits, default_bits);
                if exception_pending(_py) {
                    return MoltObject::none().bits() as i64;
                }
            }
        }
        dict_bits as i64
    })
}

pub(crate) extern "C" fn dict_update_method(self_bits: u64, other_bits: u64) -> i64 {
    crate::with_gil_entry!(_py, {
        if other_bits == missing_bits(_py) {
            return MoltObject::none().bits() as i64;
        }
        molt_dict_update(self_bits, other_bits) as i64
    })
}

type DictUpdateSetter = unsafe fn(&PyToken<'_>, u64, u64, u64);

pub(crate) unsafe fn dict_update_set_in_place(
    _py: &PyToken<'_>,
    dict_bits: u64,
    key_bits: u64,
    val_bits: u64,
) {
    unsafe {
        crate::gil_assert();
        let dict_obj = obj_from_bits(dict_bits);
        let Some(dict_ptr) = dict_obj.as_ptr() else {
            return;
        };
        if object_type_id(dict_ptr) != TYPE_ID_DICT {
            return;
        }
        dict_set_in_place(_py, dict_ptr, key_bits, val_bits);
    }
}

pub(crate) unsafe fn dict_update_set_via_store(
    _py: &PyToken<'_>,
    target_bits: u64,
    key_bits: u64,
    val_bits: u64,
) {
    crate::gil_assert();
    let _ = molt_store_index(target_bits, key_bits, val_bits);
}

pub(crate) unsafe fn dict_update_apply(
    _py: &PyToken<'_>,
    target_bits: u64,
    set_fn: DictUpdateSetter,
    other_bits: u64,
) -> u64 {
    unsafe {
        let other_obj = obj_from_bits(other_bits);
        if let Some(ptr) = other_obj.as_ptr() {
            if object_type_id(ptr) == TYPE_ID_DICT {
                let iter_bits = molt_dict_items(other_bits);
                if obj_from_bits(iter_bits).is_none() {
                    return MoltObject::none().bits();
                }
                let iter = molt_iter(iter_bits);
                if obj_from_bits(iter).is_none() {
                    return MoltObject::none().bits();
                }
                let mut elem_index = 0usize;
                loop {
                    let pair_bits = molt_iter_next(iter);
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    let pair_obj = obj_from_bits(pair_bits);
                    let Some(pair_ptr) = pair_obj.as_ptr() else {
                        return MoltObject::none().bits();
                    };
                    if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                        return MoltObject::none().bits();
                    }
                    let elems = seq_vec_ref(pair_ptr);
                    if elems.len() < 2 {
                        return MoltObject::none().bits();
                    }
                    let done_bits = elems[1];
                    if is_truthy(_py, obj_from_bits(done_bits)) {
                        break;
                    }
                    let item_bits = elems[0];
                    match dict_pair_from_item(_py, item_bits) {
                        Ok((key, val)) => {
                            set_fn(_py, target_bits, key, val);
                            if exception_pending(_py) {
                                return MoltObject::none().bits();
                            }
                        }
                        Err(DictSeqError::NotIterable) => {
                            let msg = format!(
                                "cannot convert dictionary update sequence element #{elem_index} to a sequence"
                            );
                            return raise_exception::<_>(_py, "TypeError", &msg);
                        }
                        Err(DictSeqError::BadLen(len)) => {
                            let msg = format!(
                                "dictionary update sequence element #{elem_index} has length {len}; 2 is required"
                            );
                            return raise_exception::<_>(_py, "ValueError", &msg);
                        }
                        Err(DictSeqError::Exception) => {
                            return MoltObject::none().bits();
                        }
                    }
                    elem_index += 1;
                }
                return MoltObject::none().bits();
            }
            if let Some(keys_bits) = attr_name_bits_from_bytes(_py, b"keys") {
                let keys_method_bits = attr_lookup_ptr(_py, ptr, keys_bits);
                dec_ref_bits(_py, keys_bits);
                if let Some(keys_method_bits) = keys_method_bits {
                    let keys_iterable = call_callable0(_py, keys_method_bits);
                    let keys_iter = molt_iter(keys_iterable);
                    if obj_from_bits(keys_iter).is_none() {
                        return raise_exception::<_>(
                            _py,
                            "TypeError",
                            "dict.update expects a mapping or iterable",
                        );
                    }
                    let Some(getitem_bits) = attr_name_bits_from_bytes(_py, b"__getitem__") else {
                        return raise_exception::<_>(
                            _py,
                            "TypeError",
                            "dict.update expects a mapping or iterable",
                        );
                    };
                    let getitem_method_bits = attr_lookup_ptr(_py, ptr, getitem_bits);
                    dec_ref_bits(_py, getitem_bits);
                    let Some(getitem_method_bits) = getitem_method_bits else {
                        return raise_exception::<_>(
                            _py,
                            "TypeError",
                            "dict.update expects a mapping or iterable",
                        );
                    };
                    loop {
                        let pair_bits = molt_iter_next(keys_iter);
                        let pair_obj = obj_from_bits(pair_bits);
                        let Some(pair_ptr) = pair_obj.as_ptr() else {
                            return MoltObject::none().bits();
                        };
                        if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                            return MoltObject::none().bits();
                        }
                        let elems = seq_vec_ref(pair_ptr);
                        if elems.len() < 2 {
                            return MoltObject::none().bits();
                        }
                        let done_bits = elems[1];
                        if is_truthy(_py, obj_from_bits(done_bits)) {
                            break;
                        }
                        let key_bits = elems[0];
                        let val_bits = call_callable1(_py, getitem_method_bits, key_bits);
                        if exception_pending(_py) {
                            return MoltObject::none().bits();
                        }
                        set_fn(_py, target_bits, key_bits, val_bits);
                        if exception_pending(_py) {
                            return MoltObject::none().bits();
                        }
                    }
                    return MoltObject::none().bits();
                }
                if exception_pending(_py) {
                    return MoltObject::none().bits();
                }
            }
        }
        let iter = molt_iter(other_bits);
        if obj_from_bits(iter).is_none() {
            if exception_pending(_py) {
                return MoltObject::none().bits();
            }
            return raise_not_iterable(_py, other_bits);
        }
        let mut elem_index = 0usize;
        loop {
            let pair_bits = molt_iter_next(iter);
            if exception_pending(_py) {
                return MoltObject::none().bits();
            }
            let pair_obj = obj_from_bits(pair_bits);
            let Some(pair_ptr) = pair_obj.as_ptr() else {
                return MoltObject::none().bits();
            };
            if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                return MoltObject::none().bits();
            }
            let elems = seq_vec_ref(pair_ptr);
            if elems.len() < 2 {
                return MoltObject::none().bits();
            }
            let done_bits = elems[1];
            if is_truthy(_py, obj_from_bits(done_bits)) {
                break;
            }
            let item_bits = elems[0];
            match dict_pair_from_item(_py, item_bits) {
                Ok((key, val)) => {
                    set_fn(_py, target_bits, key, val);
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                }
                Err(DictSeqError::NotIterable) => {
                    let msg = format!(
                        "cannot convert dictionary update sequence element #{elem_index} to a sequence"
                    );
                    return raise_exception::<_>(_py, "TypeError", &msg);
                }
                Err(DictSeqError::BadLen(len)) => {
                    let msg = format!(
                        "dictionary update sequence element #{elem_index} has length {len}; 2 is required"
                    );
                    return raise_exception::<_>(_py, "ValueError", &msg);
                }
                Err(DictSeqError::Exception) => {
                    return MoltObject::none().bits();
                }
            }
            elem_index += 1;
        }
        MoltObject::none().bits()
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_dict_set(dict_bits: u64, key_bits: u64, val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        if !ensure_hashable(_py, key_bits) {
            return MoltObject::none().bits();
        }
        molt_store_index(dict_bits, key_bits, val_bits)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_dict_get(dict_bits: u64, key_bits: u64, default_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(dict_bits);
        let Some(ptr) = obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "dict.get expects dict");
        };
        unsafe {
            let Some(dict_bits) = dict_like_bits_from_ptr(_py, ptr) else {
                return raise_exception::<_>(_py, "TypeError", "dict.get expects dict");
            };
            let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() else {
                return MoltObject::none().bits();
            };
            if object_type_id(dict_ptr) != TYPE_ID_DICT {
                return raise_exception::<_>(_py, "TypeError", "dict.get expects dict");
            }
            if !ensure_hashable(_py, key_bits) {
                return MoltObject::none().bits();
            }
            if let Some(val) = dict_get_in_place(_py, dict_ptr, key_bits) {
                inc_ref_bits(_py, val);
                return val;
            }
            inc_ref_bits(_py, default_bits);
            default_bits
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_dict_inc(dict_bits: u64, key_bits: u64, delta_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(dict_bits);
        let Some(ptr) = obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "dict increment expects dict");
        };
        unsafe {
            let Some(dict_bits) = dict_like_bits_from_ptr(_py, ptr) else {
                return raise_exception::<_>(_py, "TypeError", "dict increment expects dict");
            };
            let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() else {
                return MoltObject::none().bits();
            };
            if object_type_id(dict_ptr) != TYPE_ID_DICT {
                return raise_exception::<_>(_py, "TypeError", "dict increment expects dict");
            }
            if !dict_inc_in_place(_py, dict_ptr, key_bits, delta_bits) {
                return MoltObject::none().bits();
            }
            MoltObject::none().bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_dict_str_int_inc(dict_bits: u64, key_bits: u64, delta_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(dict_bits);
        let Some(ptr) = obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "dict increment expects dict");
        };
        unsafe {
            let Some(dict_bits) = dict_like_bits_from_ptr(_py, ptr) else {
                return raise_exception::<_>(_py, "TypeError", "dict increment expects dict");
            };
            let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() else {
                return MoltObject::none().bits();
            };
            if object_type_id(dict_ptr) != TYPE_ID_DICT {
                return raise_exception::<_>(_py, "TypeError", "dict increment expects dict");
            }
            if let Some(done) =
                dict_inc_prehashed_string_key_in_place(_py, dict_ptr, key_bits, delta_bits)
            {
                if !done {
                    return MoltObject::none().bits();
                }
                return MoltObject::none().bits();
            }
            profile_hit_unchecked(&DICT_STR_INT_PREHASH_DEOPT_COUNT);
            if !dict_inc_in_place(_py, dict_ptr, key_bits, delta_bits) {
                return MoltObject::none().bits();
            }
            MoltObject::none().bits()
        }
    })
}

unsafe fn dict_inc_in_place(
    _py: &PyToken<'_>,
    dict_ptr: *mut u8,
    key_bits: u64,
    delta_bits: u64,
) -> bool {
    unsafe {
        if !ensure_hashable(_py, key_bits) {
            return false;
        }
        let current_bits =
            dict_get_in_place(_py, dict_ptr, key_bits).unwrap_or(MoltObject::from_int(0).bits());
        if exception_pending(_py) {
            return false;
        }

        if let (Some(current), Some(delta)) = (
            obj_from_bits(current_bits).as_int(),
            obj_from_bits(delta_bits).as_int(),
        ) {
            if let Some(sum) = current.checked_add(delta) {
                let sum_bits = MoltObject::from_int(sum).bits();
                dict_set_in_place(_py, dict_ptr, key_bits, sum_bits);
                return !exception_pending(_py);
            }
        }

        let sum_bits = molt_add(current_bits, delta_bits);
        if obj_from_bits(sum_bits).is_none() {
            return false;
        }
        dict_set_in_place(_py, dict_ptr, key_bits, sum_bits);
        dec_ref_bits(_py, sum_bits);
        !exception_pending(_py)
    }
}

unsafe fn dict_inc_prehashed_string_key_in_place(
    _py: &PyToken<'_>,
    dict_ptr: *mut u8,
    key_bits: u64,
    delta_bits: u64,
) -> Option<bool> {
    unsafe {
        let key_obj = obj_from_bits(key_bits);
        let key_ptr = key_obj.as_ptr()?;
        if object_type_id(key_ptr) != TYPE_ID_STRING {
            return None;
        }
        let delta = bits_as_int(delta_bits)?;
        let key_bytes = std::slice::from_raw_parts(string_bytes(key_ptr), string_len(key_ptr));
        let hash = hash_string_bytes(_py, key_bytes) as u64;

        let order = dict_order(dict_ptr);
        let table = dict_table(dict_ptr);
        if !table.is_empty() {
            let mask = table.len() - 1;
            let mut slot = (hash as usize) & mask;
            loop {
                let entry = table[slot];
                if entry == 0 {
                    break;
                }
                let entry_idx = entry - 1;
                let entry_key_bits = order[entry_idx * 2];
                let mut keys_match = entry_key_bits == key_bits;
                if !keys_match {
                    let Some(entry_key_ptr) = obj_from_bits(entry_key_bits).as_ptr() else {
                        // continue probing
                        slot = (slot + 1) & mask;
                        continue;
                    };
                    if object_type_id(entry_key_ptr) == TYPE_ID_STRING {
                        let entry_len = string_len(entry_key_ptr);
                        if entry_len == key_bytes.len() {
                            let entry_bytes =
                                std::slice::from_raw_parts(string_bytes(entry_key_ptr), entry_len);
                            keys_match = entry_bytes == key_bytes;
                        }
                    }
                }
                if keys_match {
                    profile_hit_unchecked(&DICT_STR_INT_PREHASH_HIT_COUNT);
                    let val_idx = entry_idx * 2 + 1;
                    let current_bits = order[val_idx];
                    let sum_bits: u64;
                    let mut sum_owned = false;
                    if let Some(current) = obj_from_bits(current_bits).as_int() {
                        if let Some(sum) = current.checked_add(delta) {
                            sum_bits = MoltObject::from_int(sum).bits();
                        } else {
                            sum_bits = molt_add(current_bits, delta_bits);
                            if obj_from_bits(sum_bits).is_none() {
                                return Some(false);
                            }
                            sum_owned = true;
                        }
                    } else {
                        sum_bits = molt_add(current_bits, delta_bits);
                        if obj_from_bits(sum_bits).is_none() {
                            return Some(false);
                        }
                        sum_owned = true;
                    }
                    if current_bits != sum_bits {
                        dec_ref_bits(_py, current_bits);
                        inc_ref_bits(_py, sum_bits);
                        order[val_idx] = sum_bits;
                    }
                    if sum_owned {
                        dec_ref_bits(_py, sum_bits);
                    }
                    return Some(!exception_pending(_py));
                }
                slot = (slot + 1) & mask;
            }
        }

        let sum_bits = MoltObject::from_int(delta).bits();
        let new_entries = (order.len() / 2) + 1;
        let needs_resize = table.is_empty() || new_entries * 10 >= table.len() * 7;
        if needs_resize {
            let capacity = dict_table_capacity(new_entries);
            dict_rebuild(_py, order, table, capacity);
            if exception_pending(_py) {
                return Some(false);
            }
        }
        order.push(key_bits);
        order.push(sum_bits);
        inc_ref_bits(_py, key_bits);
        inc_ref_bits(_py, sum_bits);
        let entry_idx = order.len() / 2 - 1;
        dict_insert_entry_with_hash(_py, order, table, entry_idx, hash);
        profile_hit_unchecked(&DICT_STR_INT_PREHASH_MISS_COUNT);
        Some(!exception_pending(_py))
    }
}

fn bits_as_int(bits: u64) -> Option<i64> {
    obj_from_bits(bits).as_int()
}

unsafe fn dict_inc_with_string_token_fallback(
    _py: &PyToken<'_>,
    dict_ptr: *mut u8,
    token: &[u8],
    delta_bits: u64,
    last_bits: &mut u64,
    had_any: &mut bool,
) -> bool {
    unsafe {
        let key_ptr = alloc_string(_py, token);
        if key_ptr.is_null() {
            return false;
        }
        let key_bits = MoltObject::from_ptr(key_ptr).bits();
        if let Some(done) =
            dict_inc_prehashed_string_key_in_place(_py, dict_ptr, key_bits, delta_bits)
        {
            if !done {
                dec_ref_bits(_py, key_bits);
                return false;
            }
        } else if !dict_inc_in_place(_py, dict_ptr, key_bits, delta_bits) {
            dec_ref_bits(_py, key_bits);
            return false;
        }
        if *had_any && !obj_from_bits(*last_bits).is_none() {
            dec_ref_bits(_py, *last_bits);
        }
        inc_ref_bits(_py, key_bits);
        *last_bits = key_bits;
        *had_any = true;
        dec_ref_bits(_py, key_bits);
        true
    }
}

unsafe fn dict_inc_with_string_token(
    _py: &PyToken<'_>,
    dict_ptr: *mut u8,
    token: &[u8],
    delta_bits: u64,
    last_bits: &mut u64,
    had_any: &mut bool,
) -> bool {
    unsafe {
        let hash = hash_string_bytes(_py, token) as u64;
        {
            let order = dict_order(dict_ptr);
            let table = dict_table(dict_ptr);
            if !table.is_empty() {
                let mask = table.len() - 1;
                let mut slot = (hash as usize) & mask;
                loop {
                    let entry = table[slot];
                    if entry == 0 {
                        break;
                    }
                    let entry_idx = entry - 1;
                    let entry_key_bits = order[entry_idx * 2];
                    let Some(entry_key_ptr) = obj_from_bits(entry_key_bits).as_ptr() else {
                        return dict_inc_with_string_token_fallback(
                            _py, dict_ptr, token, delta_bits, last_bits, had_any,
                        );
                    };
                    if object_type_id(entry_key_ptr) != TYPE_ID_STRING {
                        return dict_inc_with_string_token_fallback(
                            _py, dict_ptr, token, delta_bits, last_bits, had_any,
                        );
                    }
                    let entry_len = string_len(entry_key_ptr);
                    if entry_len == token.len() {
                        let entry_bytes =
                            std::slice::from_raw_parts(string_bytes(entry_key_ptr), entry_len);
                        if entry_bytes == token {
                            let val_idx = entry_idx * 2 + 1;
                            let current_bits = order[val_idx];
                            let sum_bits: u64;
                            let mut sum_owned = false;
                            if let (Some(current), Some(delta)) = (
                                obj_from_bits(current_bits).as_int(),
                                obj_from_bits(delta_bits).as_int(),
                            ) {
                                if let Some(sum) = current.checked_add(delta) {
                                    sum_bits = MoltObject::from_int(sum).bits();
                                } else {
                                    sum_bits = molt_add(current_bits, delta_bits);
                                    if obj_from_bits(sum_bits).is_none() {
                                        return false;
                                    }
                                    sum_owned = true;
                                }
                            } else {
                                sum_bits = molt_add(current_bits, delta_bits);
                                if obj_from_bits(sum_bits).is_none() {
                                    return false;
                                }
                                sum_owned = true;
                            }
                            if current_bits != sum_bits {
                                dec_ref_bits(_py, current_bits);
                                inc_ref_bits(_py, sum_bits);
                                order[val_idx] = sum_bits;
                            }
                            if sum_owned {
                                dec_ref_bits(_py, sum_bits);
                            }
                            if *had_any && !obj_from_bits(*last_bits).is_none() {
                                dec_ref_bits(_py, *last_bits);
                            }
                            inc_ref_bits(_py, entry_key_bits);
                            *last_bits = entry_key_bits;
                            *had_any = true;
                            return true;
                        }
                    }
                    slot = (slot + 1) & mask;
                }
            }
        }

        let key_ptr = alloc_string(_py, token);
        if key_ptr.is_null() {
            return false;
        }
        let key_bits = MoltObject::from_ptr(key_ptr).bits();
        let zero_bits = MoltObject::from_int(0).bits();
        let sum_bits: u64;
        let mut sum_owned = false;
        if let Some(delta) = obj_from_bits(delta_bits).as_int() {
            sum_bits = MoltObject::from_int(delta).bits();
        } else {
            sum_bits = molt_add(zero_bits, delta_bits);
            if obj_from_bits(sum_bits).is_none() {
                dec_ref_bits(_py, key_bits);
                return false;
            }
            sum_owned = true;
        }
        let order = dict_order(dict_ptr);
        let table = dict_table(dict_ptr);
        let new_entries = (order.len() / 2) + 1;
        let needs_resize = table.is_empty() || new_entries * 10 >= table.len() * 7;
        if needs_resize {
            let capacity = dict_table_capacity(new_entries);
            dict_rebuild(_py, order, table, capacity);
            if exception_pending(_py) {
                if sum_owned {
                    dec_ref_bits(_py, sum_bits);
                }
                dec_ref_bits(_py, key_bits);
                return false;
            }
        }
        order.push(key_bits);
        order.push(sum_bits);
        inc_ref_bits(_py, key_bits);
        inc_ref_bits(_py, sum_bits);
        let entry_idx = order.len() / 2 - 1;
        dict_insert_entry_with_hash(_py, order, table, entry_idx, hash);
        if sum_owned {
            dec_ref_bits(_py, sum_bits);
        }
        if *had_any && !obj_from_bits(*last_bits).is_none() {
            dec_ref_bits(_py, *last_bits);
        }
        inc_ref_bits(_py, key_bits);
        *last_bits = key_bits;
        *had_any = true;
        dec_ref_bits(_py, key_bits);
        true
    }
}

unsafe fn dict_setdefault_empty_list_with_string_token(
    _py: &PyToken<'_>,
    dict_ptr: *mut u8,
    token: &[u8],
) -> Option<u64> {
    unsafe {
        let hash = hash_string_bytes(_py, token) as u64;
        {
            let order = dict_order(dict_ptr);
            let table = dict_table(dict_ptr);
            if !table.is_empty() {
                let mask = table.len() - 1;
                let mut slot = (hash as usize) & mask;
                loop {
                    let entry = table[slot];
                    if entry == 0 {
                        break;
                    }
                    let entry_idx = entry - 1;
                    let entry_key_bits = order[entry_idx * 2];
                    let Some(entry_key_ptr) = obj_from_bits(entry_key_bits).as_ptr() else {
                        slot = (slot + 1) & mask;
                        continue;
                    };
                    if object_type_id(entry_key_ptr) == TYPE_ID_STRING {
                        let entry_len = string_len(entry_key_ptr);
                        if entry_len == token.len() {
                            let entry_bytes =
                                std::slice::from_raw_parts(string_bytes(entry_key_ptr), entry_len);
                            if entry_bytes == token {
                                let val_bits = order[entry_idx * 2 + 1];
                                inc_ref_bits(_py, val_bits);
                                return Some(val_bits);
                            }
                        }
                    }
                    slot = (slot + 1) & mask;
                }
            }
        }

        let key_ptr = alloc_string(_py, token);
        if key_ptr.is_null() {
            return None;
        }
        let key_bits = MoltObject::from_ptr(key_ptr).bits();
        let default_ptr = alloc_list(_py, &[]);
        if default_ptr.is_null() {
            dec_ref_bits(_py, key_bits);
            return None;
        }
        let default_bits = MoltObject::from_ptr(default_ptr).bits();
        let order = dict_order(dict_ptr);
        let table = dict_table(dict_ptr);
        let new_entries = (order.len() / 2) + 1;
        let needs_resize = table.is_empty() || new_entries * 10 >= table.len() * 7;
        if needs_resize {
            let capacity = dict_table_capacity(new_entries);
            dict_rebuild(_py, order, table, capacity);
            if exception_pending(_py) {
                dec_ref_bits(_py, default_bits);
                dec_ref_bits(_py, key_bits);
                return None;
            }
        }
        order.push(key_bits);
        order.push(default_bits);
        inc_ref_bits(_py, key_bits);
        inc_ref_bits(_py, default_bits);
        let entry_idx = order.len() / 2 - 1;
        dict_insert_entry_with_hash(_py, order, table, entry_idx, hash);
        if exception_pending(_py) {
            dec_ref_bits(_py, default_bits);
            dec_ref_bits(_py, key_bits);
            return None;
        }
        inc_ref_bits(_py, default_bits);
        dec_ref_bits(_py, default_bits);
        dec_ref_bits(_py, key_bits);
        Some(default_bits)
    }
}

unsafe fn split_dict_inc_result_tuple(_py: &PyToken<'_>, last_bits: u64, had_any: bool) -> u64 {
    let had_any_bits = MoltObject::from_bool(had_any).bits();
    let pair_ptr = alloc_tuple(_py, &[last_bits, had_any_bits]);
    if pair_ptr.is_null() {
        if had_any && !obj_from_bits(last_bits).is_none() {
            dec_ref_bits(_py, last_bits);
        }
        return MoltObject::none().bits();
    }
    if had_any && !obj_from_bits(last_bits).is_none() {
        dec_ref_bits(_py, last_bits);
    }
    MoltObject::from_ptr(pair_ptr).bits()
}

fn parse_ascii_i64_field(_py: &PyToken<'_>, field: &[u8]) -> Option<i64> {
    let mut start = 0usize;
    let mut end = field.len();
    while start < end && field[start].is_ascii_whitespace() {
        start += 1;
    }
    while end > start && field[end - 1].is_ascii_whitespace() {
        end -= 1;
    }
    let trimmed = &field[start..end];
    if trimmed.is_empty() {
        profile_hit_unchecked(&ASCII_I64_PARSE_FAIL_COUNT);
        raise_exception::<()>(
            _py,
            "ValueError",
            "invalid literal for int() with base 10: ''",
        );
        return None;
    }
    let mut idx = 0usize;
    let mut neg = false;
    if trimmed[0] == b'+' {
        idx = 1;
    } else if trimmed[0] == b'-' {
        neg = true;
        idx = 1;
    }
    if idx >= trimmed.len() {
        profile_hit_unchecked(&ASCII_I64_PARSE_FAIL_COUNT);
        let shown = String::from_utf8_lossy(trimmed);
        let msg = format!("invalid literal for int() with base 10: '{shown}'");
        raise_exception::<()>(_py, "ValueError", &msg);
        return None;
    }
    let mut value: i128 = 0;
    while idx < trimmed.len() {
        let b = trimmed[idx];
        if !b.is_ascii_digit() {
            profile_hit_unchecked(&ASCII_I64_PARSE_FAIL_COUNT);
            let shown = String::from_utf8_lossy(trimmed);
            let msg = format!("invalid literal for int() with base 10: '{shown}'");
            raise_exception::<()>(_py, "ValueError", &msg);
            return None;
        }
        value = value * 10 + i128::from((b - b'0') as i64);
        idx += 1;
    }
    if neg {
        value = -value;
    }
    if value < i128::from(i64::MIN) || value > i128::from(i64::MAX) {
        profile_hit_unchecked(&ASCII_I64_PARSE_FAIL_COUNT);
        let shown = String::from_utf8_lossy(trimmed);
        let msg = format!("invalid literal for int() with base 10: '{shown}'");
        raise_exception::<()>(_py, "ValueError", &msg);
        None
    } else {
        Some(value as i64)
    }
}

#[inline]
fn is_ascii_split_whitespace_byte(byte: u8) -> bool {
    matches!(byte, b' ' | b'\n' | b'\r' | b'\t' | 0x0b | 0x0c)
}

#[cfg(target_arch = "x86_64")]
#[target_feature(enable = "sse2")]
unsafe fn find_ascii_split_whitespace_sse2(bytes: &[u8], start: usize) -> usize {
    use std::arch::x86_64::*;
    let mut i = start;
    let len = bytes.len();
    let sp = _mm_set1_epi8(b' ' as i8);
    let nl = _mm_set1_epi8(b'\n' as i8);
    let cr = _mm_set1_epi8(b'\r' as i8);
    let tab = _mm_set1_epi8(b'\t' as i8);
    let vt = _mm_set1_epi8(0x0b_i8);
    let ff = _mm_set1_epi8(0x0c_i8);
    while i + 16 <= len {
        let chunk = _mm_loadu_si128(bytes.as_ptr().add(i) as *const __m128i);
        let mut mask_vec = _mm_or_si128(_mm_cmpeq_epi8(chunk, sp), _mm_cmpeq_epi8(chunk, nl));
        mask_vec = _mm_or_si128(mask_vec, _mm_cmpeq_epi8(chunk, cr));
        mask_vec = _mm_or_si128(mask_vec, _mm_cmpeq_epi8(chunk, tab));
        mask_vec = _mm_or_si128(mask_vec, _mm_cmpeq_epi8(chunk, vt));
        mask_vec = _mm_or_si128(mask_vec, _mm_cmpeq_epi8(chunk, ff));
        let mask = _mm_movemask_epi8(mask_vec) as u32;
        if mask != 0 {
            return i + mask.trailing_zeros() as usize;
        }
        i += 16;
    }
    while i < len {
        if is_ascii_split_whitespace_byte(bytes[i]) {
            return i;
        }
        i += 1;
    }
    len
}

fn find_ascii_split_whitespace(bytes: &[u8], start: usize) -> usize {
    #[cfg(target_arch = "x86_64")]
    {
        if std::arch::is_x86_feature_detected!("sse2") {
            return unsafe { find_ascii_split_whitespace_sse2(bytes, start) };
        }
    }
    let mut i = start;
    while i < bytes.len() {
        if is_ascii_split_whitespace_byte(bytes[i]) {
            return i;
        }
        i += 1;
    }
    bytes.len()
}

unsafe fn split_ascii_whitespace_dict_inc_tokens(
    _py: &PyToken<'_>,
    dict_ptr: *mut u8,
    line_bytes: &[u8],
    delta_bits: u64,
    last_bits: &mut u64,
    had_any: &mut bool,
) -> bool {
    unsafe {
        let mut idx = 0usize;
        let len = line_bytes.len();
        while idx < len {
            while idx < len && is_ascii_split_whitespace_byte(line_bytes[idx]) {
                idx += 1;
            }
            if idx >= len {
                break;
            }
            let token_start = idx;
            let token_end = find_ascii_split_whitespace(line_bytes, token_start);
            if !dict_inc_with_string_token(
                _py,
                dict_ptr,
                &line_bytes[token_start..token_end],
                delta_bits,
                last_bits,
                had_any,
            ) {
                return false;
            }
            idx = token_end;
        }
        true
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_split_ws_dict_inc(
    line_bits: u64,
    dict_bits: u64,
    delta_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let line_obj = obj_from_bits(line_bits);
        let dict_obj = obj_from_bits(dict_bits);
        let Some(line_ptr) = line_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "split expects str");
        };
        let Some(dict_ptr_raw) = dict_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "dict increment expects dict");
        };
        unsafe {
            if object_type_id(line_ptr) != TYPE_ID_STRING {
                return raise_exception::<_>(_py, "TypeError", "split expects str");
            }
            let Some(dict_bits) = dict_like_bits_from_ptr(_py, dict_ptr_raw) else {
                return raise_exception::<_>(_py, "TypeError", "dict increment expects dict");
            };
            let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() else {
                return MoltObject::none().bits();
            };
            if object_type_id(dict_ptr) != TYPE_ID_DICT {
                return raise_exception::<_>(_py, "TypeError", "dict increment expects dict");
            }
            let line_bytes =
                std::slice::from_raw_parts(string_bytes(line_ptr), string_len(line_ptr));
            let mut last_bits = MoltObject::none().bits();
            let mut had_any = false;
            if line_bytes.is_ascii() {
                profile_hit_unchecked(&SPLIT_WS_ASCII_FAST_PATH_COUNT);
                if !split_ascii_whitespace_dict_inc_tokens(
                    _py,
                    dict_ptr,
                    line_bytes,
                    delta_bits,
                    &mut last_bits,
                    &mut had_any,
                ) {
                    return MoltObject::none().bits();
                }
            } else {
                profile_hit_unchecked(&SPLIT_WS_UNICODE_PATH_COUNT);
                let Ok(line_str) = std::str::from_utf8(line_bytes) else {
                    return MoltObject::none().bits();
                };
                for part in line_str.split_whitespace() {
                    if !dict_inc_with_string_token(
                        _py,
                        dict_ptr,
                        part.as_bytes(),
                        delta_bits,
                        &mut last_bits,
                        &mut had_any,
                    ) {
                        return MoltObject::none().bits();
                    }
                }
            }
            split_dict_inc_result_tuple(_py, last_bits, had_any)
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_string_split_sep_dict_inc(
    line_bits: u64,
    sep_bits: u64,
    dict_bits: u64,
    delta_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let line_obj = obj_from_bits(line_bits);
        let sep_obj = obj_from_bits(sep_bits);
        let dict_obj = obj_from_bits(dict_bits);
        let Some(line_ptr) = line_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "split expects str");
        };
        let Some(sep_ptr) = sep_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "must be str or None");
        };
        let Some(dict_ptr_raw) = dict_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "dict increment expects dict");
        };
        unsafe {
            if object_type_id(line_ptr) != TYPE_ID_STRING {
                return raise_exception::<_>(_py, "TypeError", "split expects str");
            }
            if object_type_id(sep_ptr) != TYPE_ID_STRING {
                return raise_exception::<_>(_py, "TypeError", "must be str or None");
            }
            let Some(dict_bits) = dict_like_bits_from_ptr(_py, dict_ptr_raw) else {
                return raise_exception::<_>(_py, "TypeError", "dict increment expects dict");
            };
            let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() else {
                return MoltObject::none().bits();
            };
            if object_type_id(dict_ptr) != TYPE_ID_DICT {
                return raise_exception::<_>(_py, "TypeError", "dict increment expects dict");
            }

            let line_bytes =
                std::slice::from_raw_parts(string_bytes(line_ptr), string_len(line_ptr));
            let sep_bytes = std::slice::from_raw_parts(string_bytes(sep_ptr), string_len(sep_ptr));
            if sep_bytes.is_empty() {
                return raise_exception::<_>(_py, "ValueError", "empty separator");
            }
            let mut last_bits = MoltObject::none().bits();
            let mut had_any = false;
            let mut start = 0usize;
            if sep_bytes.len() == 1 {
                for idx in memchr::memchr_iter(sep_bytes[0], line_bytes) {
                    if !dict_inc_with_string_token(
                        _py,
                        dict_ptr,
                        &line_bytes[start..idx],
                        delta_bits,
                        &mut last_bits,
                        &mut had_any,
                    ) {
                        return MoltObject::none().bits();
                    }
                    start = idx + 1;
                }
            } else {
                let finder = memmem::Finder::new(sep_bytes);
                for idx in finder.find_iter(line_bytes) {
                    if !dict_inc_with_string_token(
                        _py,
                        dict_ptr,
                        &line_bytes[start..idx],
                        delta_bits,
                        &mut last_bits,
                        &mut had_any,
                    ) {
                        return MoltObject::none().bits();
                    }
                    start = idx + sep_bytes.len();
                }
            }
            if !dict_inc_with_string_token(
                _py,
                dict_ptr,
                &line_bytes[start..],
                delta_bits,
                &mut last_bits,
                &mut had_any,
            ) {
                return MoltObject::none().bits();
            }
            split_dict_inc_result_tuple(_py, last_bits, had_any)
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_taq_ingest_line(
    dict_bits: u64,
    line_bits: u64,
    bucket_size_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        profile_hit_unchecked(&TAQ_INGEST_CALL_COUNT);
        let dict_obj = obj_from_bits(dict_bits);
        let line_obj = obj_from_bits(line_bits);
        let Some(dict_ptr_raw) = dict_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "TAQ ingest expects dict");
        };
        let Some(line_ptr) = line_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "TAQ ingest expects str");
        };
        let Some(bucket_size) = obj_from_bits(bucket_size_bits).as_int() else {
            return raise_exception::<_>(
                _py,
                "TypeError",
                "TAQ ingest expects integer bucket size",
            );
        };
        if bucket_size == 0 {
            return raise_exception::<_>(
                _py,
                "ZeroDivisionError",
                "integer division or modulo by zero",
            );
        }
        unsafe {
            if object_type_id(line_ptr) != TYPE_ID_STRING {
                return raise_exception::<_>(_py, "TypeError", "TAQ ingest expects str");
            }
            let Some(dict_bits) = dict_like_bits_from_ptr(_py, dict_ptr_raw) else {
                return raise_exception::<_>(_py, "TypeError", "TAQ ingest expects dict");
            };
            let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() else {
                return MoltObject::none().bits();
            };
            if object_type_id(dict_ptr) != TYPE_ID_DICT {
                return raise_exception::<_>(_py, "TypeError", "TAQ ingest expects dict");
            }

            let line_bytes =
                std::slice::from_raw_parts(string_bytes(line_ptr), string_len(line_ptr));
            let mut field_idx = 0usize;
            let mut field_start = 0usize;
            let mut ts_field: Option<&[u8]> = None;
            let mut sym_field: Option<&[u8]> = None;
            let mut vol_field: Option<&[u8]> = None;
            for idx in 0..=line_bytes.len() {
                if idx == line_bytes.len() || line_bytes[idx] == b'|' {
                    let field = &line_bytes[field_start..idx];
                    match field_idx {
                        0 => ts_field = Some(field),
                        2 => sym_field = Some(field),
                        4 => {
                            vol_field = Some(field);
                            break;
                        }
                        _ => {}
                    }
                    field_idx += 1;
                    field_start = idx + 1;
                }
            }
            let Some(ts_field) = ts_field else {
                return raise_exception::<_>(_py, "IndexError", "list index out of range");
            };
            let Some(sym_field) = sym_field else {
                return raise_exception::<_>(_py, "IndexError", "list index out of range");
            };
            let Some(vol_field) = vol_field else {
                return raise_exception::<_>(_py, "IndexError", "list index out of range");
            };
            if ts_field == b"END" || vol_field == b"ENDP" {
                profile_hit_unchecked(&TAQ_INGEST_SKIP_MARKER_COUNT);
                return MoltObject::from_bool(false).bits();
            }
            let Some(timestamp) = parse_ascii_i64_field(_py, ts_field) else {
                return MoltObject::none().bits();
            };
            let Some(volume) = parse_ascii_i64_field(_py, vol_field) else {
                return MoltObject::none().bits();
            };
            let Some(series_bits) =
                dict_setdefault_empty_list_with_string_token(_py, dict_ptr, sym_field)
            else {
                return MoltObject::none().bits();
            };
            let bucket_bits = MoltObject::from_int(timestamp.div_euclid(bucket_size)).bits();
            let volume_bits = MoltObject::from_int(volume).bits();
            let pair_ptr = alloc_tuple(_py, &[bucket_bits, volume_bits]);
            if pair_ptr.is_null() {
                dec_ref_bits(_py, series_bits);
                return MoltObject::none().bits();
            }
            let pair_bits = MoltObject::from_ptr(pair_ptr).bits();
            let appended = if let Some(series_ptr) = obj_from_bits(series_bits).as_ptr() {
                if object_type_id(series_ptr) == TYPE_ID_LIST {
                    let _ = molt_list_append(series_bits, pair_bits);
                    !exception_pending(_py)
                } else {
                    let Some(append_name_bits) = attr_name_bits_from_bytes(_py, b"append") else {
                        dec_ref_bits(_py, pair_bits);
                        dec_ref_bits(_py, series_bits);
                        return MoltObject::none().bits();
                    };
                    let method_bits = attr_lookup_ptr(_py, series_ptr, append_name_bits);
                    dec_ref_bits(_py, append_name_bits);
                    let Some(method_bits) = method_bits else {
                        dec_ref_bits(_py, pair_bits);
                        dec_ref_bits(_py, series_bits);
                        return MoltObject::none().bits();
                    };
                    let out_bits = call_callable1(_py, method_bits, pair_bits);
                    if maybe_ptr_from_bits(out_bits).is_some() {
                        dec_ref_bits(_py, out_bits);
                    }
                    !exception_pending(_py)
                }
            } else {
                false
            };
            dec_ref_bits(_py, pair_bits);
            dec_ref_bits(_py, series_bits);
            if !appended {
                return MoltObject::none().bits();
            }
            MoltObject::from_bool(true).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_dict_pop(
    dict_bits: u64,
    key_bits: u64,
    default_bits: u64,
    has_default_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let dict_obj = obj_from_bits(dict_bits);
        let has_default = obj_from_bits(has_default_bits).as_int().unwrap_or(0) != 0;
        let Some(ptr) = dict_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "dict.pop expects dict");
        };
        unsafe {
            let Some(dict_bits) = dict_like_bits_from_ptr(_py, ptr) else {
                return raise_exception::<_>(_py, "TypeError", "dict.pop expects dict");
            };
            let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() else {
                return MoltObject::none().bits();
            };
            if object_type_id(dict_ptr) != TYPE_ID_DICT {
                return raise_exception::<_>(_py, "TypeError", "dict.pop expects dict");
            }
            if !ensure_hashable(_py, key_bits) {
                return MoltObject::none().bits();
            }
            let order = dict_order(dict_ptr);
            let table = dict_table(dict_ptr);
            let found = dict_find_entry(_py, order, table, key_bits);
            if exception_pending(_py) {
                return MoltObject::none().bits();
            }
            if let Some(entry_idx) = found {
                let key_idx = entry_idx * 2;
                let val_idx = key_idx + 1;
                let key_val = order[key_idx];
                let val_val = order[val_idx];
                inc_ref_bits(_py, val_val);
                dec_ref_bits(_py, key_val);
                dec_ref_bits(_py, val_val);
                order.drain(key_idx..=val_idx);
                let entries = order.len() / 2;
                let capacity = dict_table_capacity(entries.max(1));
                dict_rebuild(_py, order, table, capacity);
                return val_val;
            }
            if has_default {
                inc_ref_bits(_py, default_bits);
                return default_bits;
            }
        }
        raise_key_error_with_key(_py, key_bits)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_dict_setdefault(dict_bits: u64, key_bits: u64, default_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let dict_obj = obj_from_bits(dict_bits);
        let Some(ptr) = dict_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "dict.setdefault expects dict");
        };
        unsafe {
            let Some(dict_bits) = dict_like_bits_from_ptr(_py, ptr) else {
                return raise_exception::<_>(_py, "TypeError", "dict.setdefault expects dict");
            };
            let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() else {
                return MoltObject::none().bits();
            };
            if object_type_id(dict_ptr) != TYPE_ID_DICT {
                return raise_exception::<_>(_py, "TypeError", "dict.setdefault expects dict");
            }
            if !ensure_hashable(_py, key_bits) {
                return MoltObject::none().bits();
            }
            if let Some(val) = dict_get_in_place(_py, dict_ptr, key_bits) {
                inc_ref_bits(_py, val);
                return val;
            }
            dict_set_in_place(_py, dict_ptr, key_bits, default_bits);
            if exception_pending(_py) {
                return MoltObject::none().bits();
            }
            inc_ref_bits(_py, default_bits);
            default_bits
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_dict_setdefault_empty_list(dict_bits: u64, key_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let dict_obj = obj_from_bits(dict_bits);
        let Some(ptr) = dict_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "dict.setdefault expects dict");
        };
        unsafe {
            let Some(dict_bits) = dict_like_bits_from_ptr(_py, ptr) else {
                return raise_exception::<_>(_py, "TypeError", "dict.setdefault expects dict");
            };
            let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() else {
                return MoltObject::none().bits();
            };
            if object_type_id(dict_ptr) != TYPE_ID_DICT {
                return raise_exception::<_>(_py, "TypeError", "dict.setdefault expects dict");
            }
            if !ensure_hashable(_py, key_bits) {
                return MoltObject::none().bits();
            }
            if let Some(val) = dict_get_in_place(_py, dict_ptr, key_bits) {
                inc_ref_bits(_py, val);
                return val;
            }
            let default_ptr = alloc_list(_py, &[]);
            if default_ptr.is_null() {
                return MoltObject::none().bits();
            }
            let default_bits = MoltObject::from_ptr(default_ptr).bits();
            dict_set_in_place(_py, dict_ptr, key_bits, default_bits);
            if exception_pending(_py) {
                dec_ref_bits(_py, default_bits);
                return MoltObject::none().bits();
            }
            inc_ref_bits(_py, default_bits);
            default_bits
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_dict_update(dict_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let dict_obj = obj_from_bits(dict_bits);
        let Some(ptr) = dict_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "dict.update expects dict");
        };
        unsafe {
            let Some(dict_bits) = dict_like_bits_from_ptr(_py, ptr) else {
                return raise_exception::<_>(_py, "TypeError", "dict.update expects dict");
            };
            dict_update_apply(_py, dict_bits, dict_update_set_in_place, other_bits)
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_dict_clear(dict_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(dict_bits);
        let Some(ptr) = obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "dict.clear expects dict");
        };
        unsafe {
            let Some(dict_bits) = dict_like_bits_from_ptr(_py, ptr) else {
                return raise_exception::<_>(_py, "TypeError", "dict.clear expects dict");
            };
            let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() else {
                return MoltObject::none().bits();
            };
            if object_type_id(dict_ptr) != TYPE_ID_DICT {
                return raise_exception::<_>(_py, "TypeError", "dict.clear expects dict");
            }
            dict_clear_in_place(_py, dict_ptr);
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_dict_copy(dict_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(dict_bits);
        let Some(ptr) = obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "dict.copy expects dict");
        };
        unsafe {
            let Some(dict_bits) = dict_like_bits_from_ptr(_py, ptr) else {
                return raise_exception::<_>(_py, "TypeError", "dict.copy expects dict");
            };
            let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() else {
                return MoltObject::none().bits();
            };
            if object_type_id(dict_ptr) != TYPE_ID_DICT {
                return raise_exception::<_>(_py, "TypeError", "dict.copy expects dict");
            }
            let pairs = dict_order(dict_ptr).clone();
            let out_ptr = alloc_dict_with_pairs(_py, pairs.as_slice());
            if out_ptr.is_null() {
                return MoltObject::none().bits();
            }
            MoltObject::from_ptr(out_ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_dict_popitem(dict_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(dict_bits);
        let Some(ptr) = obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "dict.popitem expects dict");
        };
        unsafe {
            let Some(dict_bits) = dict_like_bits_from_ptr(_py, ptr) else {
                return raise_exception::<_>(_py, "TypeError", "dict.popitem expects dict");
            };
            let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() else {
                return MoltObject::none().bits();
            };
            if object_type_id(dict_ptr) != TYPE_ID_DICT {
                return raise_exception::<_>(_py, "TypeError", "dict.popitem expects dict");
            }
            let order = dict_order(dict_ptr);
            if order.len() < 2 {
                return raise_exception::<_>(_py, "KeyError", "popitem(): dictionary is empty");
            }
            let key_bits = order[order.len() - 2];
            let val_bits = order[order.len() - 1];
            let item_ptr = alloc_tuple(_py, &[key_bits, val_bits]);
            if item_ptr.is_null() {
                return MoltObject::none().bits();
            }
            dec_ref_bits(_py, key_bits);
            dec_ref_bits(_py, val_bits);
            order.truncate(order.len() - 2);
            let entries = order.len() / 2;
            let table = dict_table(dict_ptr);
            let capacity = dict_table_capacity(entries.max(1));
            dict_rebuild(_py, order, table, capacity);
            MoltObject::from_ptr(item_ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_dict_update_kwstar(dict_bits: u64, mapping_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let dict_obj = obj_from_bits(dict_bits);
        let Some(ptr) = dict_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "dict.update expects dict");
        };
        unsafe {
            let Some(dict_bits) = dict_like_bits_from_ptr(_py, ptr) else {
                return raise_exception::<_>(_py, "TypeError", "dict.update expects dict");
            };
            let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() else {
                return MoltObject::none().bits();
            };
            if object_type_id(dict_ptr) != TYPE_ID_DICT {
                return raise_exception::<_>(_py, "TypeError", "dict.update expects dict");
            }
            let mapping_obj = obj_from_bits(mapping_bits);
            let Some(mapping_ptr) = mapping_obj.as_ptr() else {
                return raise_exception::<_>(
                    _py,
                    "TypeError",
                    "argument after ** must be a mapping",
                );
            };
            if object_type_id(mapping_ptr) == TYPE_ID_DICT {
                let order = dict_order(mapping_ptr);
                for idx in (0..order.len()).step_by(2) {
                    let key_bits = order[idx];
                    let val_bits = order[idx + 1];
                    let key_obj = obj_from_bits(key_bits);
                    let Some(key_ptr) = key_obj.as_ptr() else {
                        return raise_exception::<_>(_py, "TypeError", "keywords must be strings");
                    };
                    if object_type_id(key_ptr) != TYPE_ID_STRING {
                        return raise_exception::<_>(_py, "TypeError", "keywords must be strings");
                    }
                    dict_set_in_place(_py, dict_ptr, key_bits, val_bits);
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                }
                return MoltObject::none().bits();
            }
            let Some(keys_bits) = attr_name_bits_from_bytes(_py, b"keys") else {
                return raise_exception::<_>(
                    _py,
                    "TypeError",
                    "argument after ** must be a mapping",
                );
            };
            let keys_method_bits = attr_lookup_ptr(_py, mapping_ptr, keys_bits);
            dec_ref_bits(_py, keys_bits);
            let Some(keys_method_bits) = keys_method_bits else {
                return raise_exception::<_>(
                    _py,
                    "TypeError",
                    "argument after ** must be a mapping",
                );
            };
            let keys_iterable = call_callable0(_py, keys_method_bits);
            let iter_bits = molt_iter(keys_iterable);
            if obj_from_bits(iter_bits).is_none() {
                return raise_exception::<_>(
                    _py,
                    "TypeError",
                    "argument after ** must be a mapping",
                );
            }
            let Some(getitem_bits) = attr_name_bits_from_bytes(_py, b"__getitem__") else {
                return raise_exception::<_>(
                    _py,
                    "TypeError",
                    "argument after ** must be a mapping",
                );
            };
            let getitem_method_bits = attr_lookup_ptr(_py, mapping_ptr, getitem_bits);
            dec_ref_bits(_py, getitem_bits);
            let Some(getitem_method_bits) = getitem_method_bits else {
                return raise_exception::<_>(
                    _py,
                    "TypeError",
                    "argument after ** must be a mapping",
                );
            };
            loop {
                let pair_bits = molt_iter_next(iter_bits);
                let pair_obj = obj_from_bits(pair_bits);
                let Some(pair_ptr) = pair_obj.as_ptr() else {
                    return MoltObject::none().bits();
                };
                if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                    return MoltObject::none().bits();
                }
                let elems = seq_vec_ref(pair_ptr);
                if elems.len() < 2 {
                    return MoltObject::none().bits();
                }
                let done_bits = elems[1];
                if is_truthy(_py, obj_from_bits(done_bits)) {
                    break;
                }
                let key_bits = elems[0];
                let key_obj = obj_from_bits(key_bits);
                let Some(key_ptr) = key_obj.as_ptr() else {
                    return raise_exception::<_>(_py, "TypeError", "keywords must be strings");
                };
                if object_type_id(key_ptr) != TYPE_ID_STRING {
                    return raise_exception::<_>(_py, "TypeError", "keywords must be strings");
                }
                let val_bits = call_callable1(_py, getitem_method_bits, key_bits);
                dict_set_in_place(_py, dict_ptr, key_bits, val_bits);
                if exception_pending(_py) {
                    return MoltObject::none().bits();
                }
            }
            MoltObject::none().bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_set_add(set_bits: u64, key_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        if !ensure_hashable(_py, key_bits) {
            return MoltObject::none().bits();
        }
        let obj = obj_from_bits(set_bits);
        if let Some(ptr) = obj.as_ptr() {
            unsafe {
                if object_type_id(ptr) == TYPE_ID_SET {
                    set_add_in_place(_py, ptr, key_bits);
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    return MoltObject::none().bits();
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_frozenset_add(set_bits: u64, key_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        if !ensure_hashable(_py, key_bits) {
            return MoltObject::none().bits();
        }
        let obj = obj_from_bits(set_bits);
        if let Some(ptr) = obj.as_ptr() {
            unsafe {
                if object_type_id(ptr) == TYPE_ID_FROZENSET {
                    set_add_in_place(_py, ptr, key_bits);
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    return MoltObject::none().bits();
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_set_discard(set_bits: u64, key_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(set_bits);
        if let Some(ptr) = obj.as_ptr() {
            unsafe {
                if object_type_id(ptr) == TYPE_ID_SET {
                    set_del_in_place(_py, ptr, key_bits);
                    return MoltObject::none().bits();
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_set_remove(set_bits: u64, key_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(set_bits);
        if let Some(ptr) = obj.as_ptr() {
            unsafe {
                if object_type_id(ptr) == TYPE_ID_SET {
                    if set_del_in_place(_py, ptr, key_bits) {
                        return MoltObject::none().bits();
                    }
                    return raise_exception::<_>(_py, "KeyError", "set.remove(x): x not in set");
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_set_pop(set_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(set_bits);
        if let Some(ptr) = obj.as_ptr() {
            unsafe {
                if object_type_id(ptr) == TYPE_ID_SET {
                    let order = set_order(ptr);
                    if order.is_empty() {
                        return raise_exception::<_>(_py, "KeyError", "pop from an empty set");
                    }
                    let key_bits = order.pop().unwrap_or_else(|| MoltObject::none().bits());
                    let entries = order.len();
                    let table = set_table(ptr);
                    let capacity = set_table_capacity(entries.max(1));
                    set_rebuild(_py, order, table, capacity);
                    inc_ref_bits(_py, key_bits);
                    return key_bits;
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_set_clear(set_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(set_bits);
        if let Some(ptr) = obj.as_ptr() {
            unsafe {
                if object_type_id(ptr) == TYPE_ID_SET {
                    set_replace_entries(_py, ptr, &[]);
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_set_copy_method(set_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(set_bits);
        let Some(ptr) = obj.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            match object_type_id(ptr) {
                TYPE_ID_SET => set_like_copy_bits(_py, ptr, TYPE_ID_SET),
                TYPE_ID_FROZENSET => {
                    inc_ref_bits(_py, set_bits);
                    set_bits
                }
                _ => MoltObject::none().bits(),
            }
        }
    })
}

unsafe fn set_from_iter_bits(_py: &PyToken<'_>, other_bits: u64) -> Option<u64> {
    unsafe {
        let iter_bits = molt_iter(other_bits);
        if obj_from_bits(iter_bits).is_none() {
            return raise_not_iterable(_py, other_bits);
        }
        let set_bits = molt_set_new(0);
        let set_ptr = obj_from_bits(set_bits).as_ptr()?;
        loop {
            let pair_bits = molt_iter_next(iter_bits);
            let pair_obj = obj_from_bits(pair_bits);
            let pair_ptr = pair_obj.as_ptr()?;
            if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                return None;
            }
            let pair_elems = seq_vec_ref(pair_ptr);
            if pair_elems.len() < 2 {
                return None;
            }
            let done_bits = pair_elems[1];
            if is_truthy(_py, obj_from_bits(done_bits)) {
                break;
            }
            let val_bits = pair_elems[0];
            set_add_in_place(_py, set_ptr, val_bits);
            if exception_pending(_py) {
                dec_ref_bits(_py, set_bits);
                return None;
            }
        }
        Some(set_bits)
    }
}

pub(crate) unsafe fn list_from_iter_bits(_py: &PyToken<'_>, other_bits: u64) -> Option<u64> {
    let list_ptr = alloc_list(_py, &[]);
    if list_ptr.is_null() {
        return None;
    }
    let list_bits = MoltObject::from_ptr(list_ptr).bits();
    let _ = molt_list_extend(list_bits, other_bits);
    if exception_pending(_py) {
        dec_ref_bits(_py, list_bits);
        return None;
    }
    Some(list_bits)
}

pub(crate) unsafe fn tuple_from_iter_bits(_py: &PyToken<'_>, other_bits: u64) -> Option<u64> {
    unsafe {
        let obj = obj_from_bits(other_bits);
        if let Some(ptr) = obj.as_ptr() {
            let type_id = object_type_id(ptr);
            if type_id == TYPE_ID_TUPLE {
                inc_ref_bits(_py, other_bits);
                return Some(other_bits);
            }
            if type_id == TYPE_ID_LIST {
                let tuple_bits = molt_tuple_from_list(other_bits);
                if obj_from_bits(tuple_bits).is_none() {
                    return None;
                }
                return Some(tuple_bits);
            }
        }
        let list_bits = list_from_iter_bits(_py, other_bits)?;
        let tuple_bits = molt_tuple_from_list(list_bits);
        dec_ref_bits(_py, list_bits);
        if obj_from_bits(tuple_bits).is_none() {
            return None;
        }
        Some(tuple_bits)
    }
}

pub(crate) unsafe fn frozenset_from_iter_bits(_py: &PyToken<'_>, other_bits: u64) -> Option<u64> {
    unsafe {
        let obj = obj_from_bits(other_bits);
        if let Some(ptr) = obj.as_ptr() {
            if object_type_id(ptr) == TYPE_ID_FROZENSET {
                inc_ref_bits(_py, other_bits);
                return Some(other_bits);
            }
        }
        let iter_bits = molt_iter(other_bits);
        if obj_from_bits(iter_bits).is_none() {
            return raise_not_iterable(_py, other_bits);
        }
        let set_bits = molt_frozenset_new(0);
        let set_ptr = obj_from_bits(set_bits).as_ptr()?;
        loop {
            let pair_bits = molt_iter_next(iter_bits);
            let pair_obj = obj_from_bits(pair_bits);
            let pair_ptr = pair_obj.as_ptr()?;
            if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                return None;
            }
            let pair_elems = seq_vec_ref(pair_ptr);
            if pair_elems.len() < 2 {
                return None;
            }
            let done_bits = pair_elems[1];
            if is_truthy(_py, obj_from_bits(done_bits)) {
                break;
            }
            let val_bits = pair_elems[0];
            set_add_in_place(_py, set_ptr, val_bits);
            if exception_pending(_py) {
                dec_ref_bits(_py, set_bits);
                return None;
            }
        }
        Some(set_bits)
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_set_update(set_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(set_bits);
        let other = obj_from_bits(other_bits);
        let Some(set_ptr) = obj.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(set_ptr) != TYPE_ID_SET {
                return MoltObject::none().bits();
            }
            if let Some(other_ptr) = other.as_ptr() {
                let other_type = object_type_id(other_ptr);
                if other_type == TYPE_ID_SET || other_type == TYPE_ID_FROZENSET {
                    if other_ptr == set_ptr {
                        return MoltObject::none().bits();
                    }
                    let entries = set_order(other_ptr);
                    for entry in entries.iter().copied() {
                        set_add_in_place(_py, set_ptr, entry);
                    }
                    return MoltObject::none().bits();
                }
                if is_set_view_type(other_type) {
                    let Some(bits) = dict_view_as_set_bits(_py, other_ptr, other_type) else {
                        return MoltObject::none().bits();
                    };
                    let Some(view_set_ptr) = obj_from_bits(bits).as_ptr() else {
                        dec_ref_bits(_py, bits);
                        return MoltObject::none().bits();
                    };
                    let entries = set_order(view_set_ptr);
                    for entry in entries.iter().copied() {
                        set_add_in_place(_py, set_ptr, entry);
                    }
                    dec_ref_bits(_py, bits);
                    return MoltObject::none().bits();
                }
            }
            let iter_bits = molt_iter(other_bits);
            if obj_from_bits(iter_bits).is_none() {
                return raise_not_iterable(_py, other_bits);
            }
            loop {
                let pair_bits = molt_iter_next(iter_bits);
                let pair_obj = obj_from_bits(pair_bits);
                let Some(pair_ptr) = pair_obj.as_ptr() else {
                    return MoltObject::none().bits();
                };
                if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                    return MoltObject::none().bits();
                }
                let pair_elems = seq_vec_ref(pair_ptr);
                if pair_elems.len() < 2 {
                    return MoltObject::none().bits();
                }
                let done_bits = pair_elems[1];
                if is_truthy(_py, obj_from_bits(done_bits)) {
                    break;
                }
                let val_bits = pair_elems[0];
                set_add_in_place(_py, set_ptr, val_bits);
                if exception_pending(_py) {
                    return MoltObject::none().bits();
                }
            }
            MoltObject::none().bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_set_intersection_update(set_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(set_bits);
        let other = obj_from_bits(other_bits);
        if let (Some(set_ptr), Some(other_ptr)) = (obj.as_ptr(), other.as_ptr()) {
            unsafe {
                if object_type_id(set_ptr) == TYPE_ID_SET {
                    let other_type = object_type_id(other_ptr);
                    if other_type == TYPE_ID_SET || other_type == TYPE_ID_FROZENSET {
                        if other_ptr == set_ptr {
                            return MoltObject::none().bits();
                        }
                        let other_order = set_order(other_ptr);
                        let other_table = set_table(other_ptr);
                        let set_entries = set_order(set_ptr).clone();
                        let mut new_entries = Vec::with_capacity(set_entries.len());
                        for entry in set_entries {
                            let found = set_find_entry(_py, other_order, other_table, entry);
                            if exception_pending(_py) {
                                return MoltObject::none().bits();
                            }
                            if found.is_some() {
                                new_entries.push(entry);
                            }
                        }
                        set_replace_entries(_py, set_ptr, &new_entries);
                        return MoltObject::none().bits();
                    }
                    if is_set_view_type(other_type) {
                        let Some(bits) = dict_view_as_set_bits(_py, other_ptr, other_type) else {
                            return MoltObject::none().bits();
                        };
                        let Some(view_set_ptr) = obj_from_bits(bits).as_ptr() else {
                            dec_ref_bits(_py, bits);
                            return MoltObject::none().bits();
                        };
                        let other_order = set_order(view_set_ptr);
                        let other_table = set_table(view_set_ptr);
                        let set_entries = set_order(set_ptr).clone();
                        let mut new_entries = Vec::with_capacity(set_entries.len());
                        for entry in set_entries {
                            let found = set_find_entry(_py, other_order, other_table, entry);
                            if exception_pending(_py) {
                                dec_ref_bits(_py, bits);
                                return MoltObject::none().bits();
                            }
                            if found.is_some() {
                                new_entries.push(entry);
                            }
                        }
                        set_replace_entries(_py, set_ptr, &new_entries);
                        dec_ref_bits(_py, bits);
                        return MoltObject::none().bits();
                    }
                    let other_set_bits = set_from_iter_bits(_py, other_bits);
                    let Some(other_set_bits) = other_set_bits else {
                        return MoltObject::none().bits();
                    };
                    let other_set = obj_from_bits(other_set_bits);
                    let Some(other_ptr) = other_set.as_ptr() else {
                        dec_ref_bits(_py, other_set_bits);
                        return MoltObject::none().bits();
                    };
                    let other_order = set_order(other_ptr);
                    let other_table = set_table(other_ptr);
                    let set_entries = set_order(set_ptr).clone();
                    let mut new_entries = Vec::with_capacity(set_entries.len());
                    for entry in set_entries {
                        let found = set_find_entry(_py, other_order, other_table, entry);
                        if exception_pending(_py) {
                            dec_ref_bits(_py, other_set_bits);
                            return MoltObject::none().bits();
                        }
                        if found.is_some() {
                            new_entries.push(entry);
                        }
                    }
                    set_replace_entries(_py, set_ptr, &new_entries);
                    dec_ref_bits(_py, other_set_bits);
                    return MoltObject::none().bits();
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_set_difference_update(set_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(set_bits);
        let other = obj_from_bits(other_bits);
        if let (Some(set_ptr), Some(other_ptr)) = (obj.as_ptr(), other.as_ptr()) {
            unsafe {
                if object_type_id(set_ptr) == TYPE_ID_SET {
                    let other_type = object_type_id(other_ptr);
                    if other_type == TYPE_ID_SET || other_type == TYPE_ID_FROZENSET {
                        if other_ptr == set_ptr {
                            set_replace_entries(_py, set_ptr, &[]);
                            return MoltObject::none().bits();
                        }
                        let other_order = set_order(other_ptr);
                        let other_table = set_table(other_ptr);
                        let set_entries = set_order(set_ptr).clone();
                        let mut new_entries = Vec::with_capacity(set_entries.len());
                        for entry in set_entries {
                            let found = set_find_entry(_py, other_order, other_table, entry);
                            if exception_pending(_py) {
                                return MoltObject::none().bits();
                            }
                            if found.is_none() {
                                new_entries.push(entry);
                            }
                        }
                        set_replace_entries(_py, set_ptr, &new_entries);
                        return MoltObject::none().bits();
                    }
                    if is_set_view_type(other_type) {
                        let Some(bits) = dict_view_as_set_bits(_py, other_ptr, other_type) else {
                            return MoltObject::none().bits();
                        };
                        let Some(view_set_ptr) = obj_from_bits(bits).as_ptr() else {
                            dec_ref_bits(_py, bits);
                            return MoltObject::none().bits();
                        };
                        let other_order = set_order(view_set_ptr);
                        let other_table = set_table(view_set_ptr);
                        let set_entries = set_order(set_ptr).clone();
                        let mut new_entries = Vec::with_capacity(set_entries.len());
                        for entry in set_entries {
                            let found = set_find_entry(_py, other_order, other_table, entry);
                            if exception_pending(_py) {
                                dec_ref_bits(_py, bits);
                                return MoltObject::none().bits();
                            }
                            if found.is_none() {
                                new_entries.push(entry);
                            }
                        }
                        set_replace_entries(_py, set_ptr, &new_entries);
                        dec_ref_bits(_py, bits);
                        return MoltObject::none().bits();
                    }
                    let iter_bits = molt_iter(other_bits);
                    if obj_from_bits(iter_bits).is_none() {
                        return raise_not_iterable(_py, other_bits);
                    }
                    loop {
                        let pair_bits = molt_iter_next(iter_bits);
                        let pair_obj = obj_from_bits(pair_bits);
                        let Some(pair_ptr) = pair_obj.as_ptr() else {
                            return MoltObject::none().bits();
                        };
                        if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                            return MoltObject::none().bits();
                        }
                        let pair_elems = seq_vec_ref(pair_ptr);
                        if pair_elems.len() < 2 {
                            return MoltObject::none().bits();
                        }
                        let done_bits = pair_elems[1];
                        if is_truthy(_py, obj_from_bits(done_bits)) {
                            break;
                        }
                        let val_bits = pair_elems[0];
                        set_del_in_place(_py, set_ptr, val_bits);
                        if exception_pending(_py) {
                            return MoltObject::none().bits();
                        }
                    }
                    return MoltObject::none().bits();
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_set_symdiff_update(set_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(set_bits);
        let other = obj_from_bits(other_bits);
        if let (Some(set_ptr), Some(other_ptr)) = (obj.as_ptr(), other.as_ptr()) {
            unsafe {
                if object_type_id(set_ptr) == TYPE_ID_SET {
                    let other_type = object_type_id(other_ptr);
                    if other_type == TYPE_ID_SET || other_type == TYPE_ID_FROZENSET {
                        if other_ptr == set_ptr {
                            set_replace_entries(_py, set_ptr, &[]);
                            return MoltObject::none().bits();
                        }
                        let other_order = set_order(other_ptr);
                        let other_table = set_table(other_ptr);
                        let set_entries = set_order(set_ptr).clone();
                        let set_table_ptr = set_table(set_ptr);
                        let mut new_entries =
                            Vec::with_capacity(set_entries.len() + other_order.len());
                        for entry in &set_entries {
                            let found = set_find_entry(_py, other_order, other_table, *entry);
                            if exception_pending(_py) {
                                return MoltObject::none().bits();
                            }
                            if found.is_none() {
                                new_entries.push(*entry);
                            }
                        }
                        for entry in other_order.iter().copied() {
                            let found =
                                set_find_entry(_py, set_entries.as_slice(), set_table_ptr, entry);
                            if exception_pending(_py) {
                                return MoltObject::none().bits();
                            }
                            if found.is_none() {
                                new_entries.push(entry);
                            }
                        }
                        set_replace_entries(_py, set_ptr, &new_entries);
                        return MoltObject::none().bits();
                    }
                    if is_set_view_type(other_type) {
                        let Some(bits) = dict_view_as_set_bits(_py, other_ptr, other_type) else {
                            return MoltObject::none().bits();
                        };
                        let Some(view_set_ptr) = obj_from_bits(bits).as_ptr() else {
                            dec_ref_bits(_py, bits);
                            return MoltObject::none().bits();
                        };
                        let other_order = set_order(view_set_ptr);
                        let other_table = set_table(view_set_ptr);
                        let set_entries = set_order(set_ptr).clone();
                        let set_table_ptr = set_table(set_ptr);
                        let mut new_entries =
                            Vec::with_capacity(set_entries.len() + other_order.len());
                        for entry in &set_entries {
                            let found = set_find_entry(_py, other_order, other_table, *entry);
                            if exception_pending(_py) {
                                dec_ref_bits(_py, bits);
                                return MoltObject::none().bits();
                            }
                            if found.is_none() {
                                new_entries.push(*entry);
                            }
                        }
                        for entry in other_order.iter().copied() {
                            let found =
                                set_find_entry(_py, set_entries.as_slice(), set_table_ptr, entry);
                            if exception_pending(_py) {
                                dec_ref_bits(_py, bits);
                                return MoltObject::none().bits();
                            }
                            if found.is_none() {
                                new_entries.push(entry);
                            }
                        }
                        set_replace_entries(_py, set_ptr, &new_entries);
                        dec_ref_bits(_py, bits);
                        return MoltObject::none().bits();
                    }
                    let other_set_bits = set_from_iter_bits(_py, other_bits);
                    let Some(other_set_bits) = other_set_bits else {
                        return MoltObject::none().bits();
                    };
                    let other_set = obj_from_bits(other_set_bits);
                    let Some(other_ptr) = other_set.as_ptr() else {
                        dec_ref_bits(_py, other_set_bits);
                        return MoltObject::none().bits();
                    };
                    let other_order = set_order(other_ptr);
                    let other_table = set_table(other_ptr);
                    let set_entries = set_order(set_ptr).clone();
                    let set_table_ptr = set_table(set_ptr);
                    let mut new_entries = Vec::with_capacity(set_entries.len() + other_order.len());
                    for entry in &set_entries {
                        let found = set_find_entry(_py, other_order, other_table, *entry);
                        if exception_pending(_py) {
                            dec_ref_bits(_py, other_set_bits);
                            return MoltObject::none().bits();
                        }
                        if found.is_none() {
                            new_entries.push(*entry);
                        }
                    }
                    for entry in other_order.iter().copied() {
                        let found =
                            set_find_entry(_py, set_entries.as_slice(), set_table_ptr, entry);
                        if exception_pending(_py) {
                            dec_ref_bits(_py, other_set_bits);
                            return MoltObject::none().bits();
                        }
                        if found.is_none() {
                            new_entries.push(entry);
                        }
                    }
                    set_replace_entries(_py, set_ptr, &new_entries);
                    dec_ref_bits(_py, other_set_bits);
                    return MoltObject::none().bits();
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_set_update_multi(set_bits: u64, others_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(set_bits);
        let Some(ptr) = obj.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(ptr) != TYPE_ID_SET {
                return MoltObject::none().bits();
            }
            let Some(others_ptr) = obj_from_bits(others_bits).as_ptr() else {
                return MoltObject::none().bits();
            };
            if object_type_id(others_ptr) != TYPE_ID_TUPLE {
                return MoltObject::none().bits();
            }
            for &other_bits in seq_vec_ref(others_ptr).iter() {
                let _ = molt_set_update(set_bits, other_bits);
                if exception_pending(_py) {
                    return MoltObject::none().bits();
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_frozenset_union_multi(set_bits: u64, others_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, { molt_set_union_multi(set_bits, others_bits) })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_frozenset_intersection_multi(set_bits: u64, others_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, { molt_set_intersection_multi(set_bits, others_bits) })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_frozenset_difference_multi(set_bits: u64, others_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, { molt_set_difference_multi(set_bits, others_bits) })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_frozenset_symmetric_difference(set_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, { molt_set_symmetric_difference(set_bits, other_bits) })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_frozenset_isdisjoint(set_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, { molt_set_isdisjoint(set_bits, other_bits) })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_frozenset_issubset(set_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, { molt_set_issubset(set_bits, other_bits) })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_frozenset_issuperset(set_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, { molt_set_issuperset(set_bits, other_bits) })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_frozenset_copy_method(set_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(set_bits);
        let Some(ptr) = obj.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(ptr) == TYPE_ID_FROZENSET {
                inc_ref_bits(_py, set_bits);
                return set_bits;
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_set_intersection_update_multi(set_bits: u64, others_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(set_bits);
        let Some(ptr) = obj.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(ptr) != TYPE_ID_SET {
                return MoltObject::none().bits();
            }
            let Some(others_ptr) = obj_from_bits(others_bits).as_ptr() else {
                return MoltObject::none().bits();
            };
            if object_type_id(others_ptr) != TYPE_ID_TUPLE {
                return MoltObject::none().bits();
            }
            for &other_bits in seq_vec_ref(others_ptr).iter() {
                let _ = molt_set_intersection_update(set_bits, other_bits);
                if exception_pending(_py) {
                    return MoltObject::none().bits();
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_set_difference_update_multi(set_bits: u64, others_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(set_bits);
        let Some(ptr) = obj.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(ptr) != TYPE_ID_SET {
                return MoltObject::none().bits();
            }
            let Some(others_ptr) = obj_from_bits(others_bits).as_ptr() else {
                return MoltObject::none().bits();
            };
            if object_type_id(others_ptr) != TYPE_ID_TUPLE {
                return MoltObject::none().bits();
            }
            for &other_bits in seq_vec_ref(others_ptr).iter() {
                let _ = molt_set_difference_update(set_bits, other_bits);
                if exception_pending(_py) {
                    return MoltObject::none().bits();
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_set_symmetric_difference_update(set_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let _ = molt_set_symdiff_update(set_bits, other_bits);
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_set_union_multi(set_bits: u64, others_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(set_bits);
        let Some(ptr) = obj.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            let type_id = object_type_id(ptr);
            if !is_set_like_type(type_id) {
                return MoltObject::none().bits();
            }
            let result_type_id = set_like_result_type_id(type_id);
            let mut result_bits = set_like_copy_bits(_py, ptr, result_type_id);
            if obj_from_bits(result_bits).is_none() {
                return MoltObject::none().bits();
            }
            let Some(others_ptr) = obj_from_bits(others_bits).as_ptr() else {
                return result_bits;
            };
            if object_type_id(others_ptr) != TYPE_ID_TUPLE {
                return result_bits;
            }
            for &other_bits in seq_vec_ref(others_ptr).iter() {
                let Some((other_ptr, drop_bits)) = set_like_ptr_from_bits(_py, other_bits) else {
                    dec_ref_bits(_py, result_bits);
                    return MoltObject::none().bits();
                };
                let result_ptr = obj_from_bits(result_bits)
                    .as_ptr()
                    .unwrap_or(std::ptr::null_mut());
                if result_ptr.is_null() {
                    if let Some(bits) = drop_bits {
                        dec_ref_bits(_py, bits);
                    }
                    dec_ref_bits(_py, result_bits);
                    return MoltObject::none().bits();
                }
                let new_bits = set_like_union(_py, result_ptr, other_ptr, result_type_id);
                if let Some(bits) = drop_bits {
                    dec_ref_bits(_py, bits);
                }
                dec_ref_bits(_py, result_bits);
                result_bits = new_bits;
                if obj_from_bits(result_bits).is_none() {
                    return MoltObject::none().bits();
                }
            }
            result_bits
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_set_intersection_multi(set_bits: u64, others_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(set_bits);
        let Some(ptr) = obj.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            let type_id = object_type_id(ptr);
            if !is_set_like_type(type_id) {
                return MoltObject::none().bits();
            }
            let result_type_id = set_like_result_type_id(type_id);
            let mut result_bits = set_like_copy_bits(_py, ptr, result_type_id);
            if obj_from_bits(result_bits).is_none() {
                return MoltObject::none().bits();
            }
            let Some(others_ptr) = obj_from_bits(others_bits).as_ptr() else {
                return result_bits;
            };
            if object_type_id(others_ptr) != TYPE_ID_TUPLE {
                return result_bits;
            }
            for &other_bits in seq_vec_ref(others_ptr).iter() {
                let Some((other_ptr, drop_bits)) = set_like_ptr_from_bits(_py, other_bits) else {
                    dec_ref_bits(_py, result_bits);
                    return MoltObject::none().bits();
                };
                let result_ptr = obj_from_bits(result_bits)
                    .as_ptr()
                    .unwrap_or(std::ptr::null_mut());
                if result_ptr.is_null() {
                    if let Some(bits) = drop_bits {
                        dec_ref_bits(_py, bits);
                    }
                    dec_ref_bits(_py, result_bits);
                    return MoltObject::none().bits();
                }
                let new_bits = set_like_intersection(_py, result_ptr, other_ptr, result_type_id);
                if let Some(bits) = drop_bits {
                    dec_ref_bits(_py, bits);
                }
                dec_ref_bits(_py, result_bits);
                result_bits = new_bits;
                if obj_from_bits(result_bits).is_none() {
                    return MoltObject::none().bits();
                }
            }
            result_bits
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_set_difference_multi(set_bits: u64, others_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(set_bits);
        let Some(ptr) = obj.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            let type_id = object_type_id(ptr);
            if !is_set_like_type(type_id) {
                return MoltObject::none().bits();
            }
            let result_type_id = set_like_result_type_id(type_id);
            let mut result_bits = set_like_copy_bits(_py, ptr, result_type_id);
            if obj_from_bits(result_bits).is_none() {
                return MoltObject::none().bits();
            }
            let Some(others_ptr) = obj_from_bits(others_bits).as_ptr() else {
                return result_bits;
            };
            if object_type_id(others_ptr) != TYPE_ID_TUPLE {
                return result_bits;
            }
            for &other_bits in seq_vec_ref(others_ptr).iter() {
                let Some((other_ptr, drop_bits)) = set_like_ptr_from_bits(_py, other_bits) else {
                    dec_ref_bits(_py, result_bits);
                    return MoltObject::none().bits();
                };
                let result_ptr = obj_from_bits(result_bits)
                    .as_ptr()
                    .unwrap_or(std::ptr::null_mut());
                if result_ptr.is_null() {
                    if let Some(bits) = drop_bits {
                        dec_ref_bits(_py, bits);
                    }
                    dec_ref_bits(_py, result_bits);
                    return MoltObject::none().bits();
                }
                let new_bits = set_like_difference(_py, result_ptr, other_ptr, result_type_id);
                if let Some(bits) = drop_bits {
                    dec_ref_bits(_py, bits);
                }
                dec_ref_bits(_py, result_bits);
                result_bits = new_bits;
                if obj_from_bits(result_bits).is_none() {
                    return MoltObject::none().bits();
                }
            }
            result_bits
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_set_symmetric_difference(set_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(set_bits);
        let Some(ptr) = obj.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            let type_id = object_type_id(ptr);
            if !is_set_like_type(type_id) {
                return MoltObject::none().bits();
            }
            let result_type_id = set_like_result_type_id(type_id);
            let Some((other_ptr, drop_bits)) = set_like_ptr_from_bits(_py, other_bits) else {
                return MoltObject::none().bits();
            };
            let result_bits = set_like_symdiff(_py, ptr, other_ptr, result_type_id);
            if let Some(bits) = drop_bits {
                dec_ref_bits(_py, bits);
            }
            result_bits
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_set_isdisjoint(set_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(set_bits);
        let Some(ptr) = obj.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if !is_set_like_type(object_type_id(ptr)) {
                return MoltObject::none().bits();
            }
            let Some((other_ptr, drop_bits)) = set_like_ptr_from_bits(_py, other_bits) else {
                return MoltObject::none().bits();
            };
            let self_order = set_order(ptr);
            let other_order = set_order(other_ptr);
            let (probe_order, probe_table, output) = if self_order.len() <= other_order.len() {
                (other_order, set_table(other_ptr), self_order)
            } else {
                (self_order, set_table(ptr), other_order)
            };
            let mut disjoint = true;
            for &entry in output.iter() {
                let found = set_find_entry(_py, probe_order, probe_table, entry);
                if exception_pending(_py) {
                    if let Some(bits) = drop_bits {
                        dec_ref_bits(_py, bits);
                    }
                    return MoltObject::none().bits();
                }
                if found.is_some() {
                    disjoint = false;
                    break;
                }
            }
            if let Some(bits) = drop_bits {
                dec_ref_bits(_py, bits);
            }
            MoltObject::from_bool(disjoint).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_set_issubset(set_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(set_bits);
        let Some(ptr) = obj.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if !is_set_like_type(object_type_id(ptr)) {
                return MoltObject::none().bits();
            }
            let Some((other_ptr, drop_bits)) = set_like_ptr_from_bits(_py, other_bits) else {
                return MoltObject::none().bits();
            };
            let self_order = set_order(ptr);
            let other_order = set_order(other_ptr);
            let other_table = set_table(other_ptr);
            let mut subset = true;
            for &entry in self_order.iter() {
                let found = set_find_entry(_py, other_order, other_table, entry);
                if exception_pending(_py) {
                    if let Some(bits) = drop_bits {
                        dec_ref_bits(_py, bits);
                    }
                    return MoltObject::none().bits();
                }
                if found.is_none() {
                    subset = false;
                    break;
                }
            }
            if let Some(bits) = drop_bits {
                dec_ref_bits(_py, bits);
            }
            MoltObject::from_bool(subset).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_set_issuperset(set_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(set_bits);
        let Some(ptr) = obj.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if !is_set_like_type(object_type_id(ptr)) {
                return MoltObject::none().bits();
            }
            let Some((other_ptr, drop_bits)) = set_like_ptr_from_bits(_py, other_bits) else {
                return MoltObject::none().bits();
            };
            let self_order = set_order(ptr);
            let self_table = set_table(ptr);
            let other_order = set_order(other_ptr);
            let mut superset = true;
            for &entry in other_order.iter() {
                let found = set_find_entry(_py, self_order, self_table, entry);
                if exception_pending(_py) {
                    if let Some(bits) = drop_bits {
                        dec_ref_bits(_py, bits);
                    }
                    return MoltObject::none().bits();
                }
                if found.is_none() {
                    superset = false;
                    break;
                }
            }
            if let Some(bits) = drop_bits {
                dec_ref_bits(_py, bits);
            }
            MoltObject::from_bool(superset).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_enumerate(iterable_bits: u64, start_bits: u64, has_start_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let has_start = is_truthy(_py, obj_from_bits(has_start_bits));
        let start_opt = if has_start { Some(start_bits) } else { None };
        unsafe { enumerate_new_impl(_py, iterable_bits, start_opt) }
    })
}

pub(crate) unsafe fn enumerate_new_impl(
    _py: &PyToken<'_>,
    iterable_bits: u64,
    start_opt: Option<u64>,
) -> u64 {
    unsafe {
        let iter_bits = molt_iter(iterable_bits);
        if obj_from_bits(iter_bits).is_none() {
            return raise_not_iterable(_py, iterable_bits);
        }
        let index_bits = if let Some(start_bits) = start_opt {
            let start_obj = obj_from_bits(start_bits);
            let mut is_int_like = start_obj.is_int() || start_obj.is_bool();
            if !is_int_like {
                if let Some(ptr) = start_obj.as_ptr() {
                    is_int_like = object_type_id(ptr) == TYPE_ID_BIGINT;
                }
            }
            if !is_int_like {
                return raise_exception::<_>(_py, "TypeError", "enumerate() start must be an int");
            }
            start_bits
        } else {
            MoltObject::from_int(0).bits()
        };
        let total = std::mem::size_of::<MoltHeader>() + 2 * std::mem::size_of::<u64>();
        let enum_ptr = alloc_object(_py, total, TYPE_ID_ENUMERATE);
        if enum_ptr.is_null() {
            return MoltObject::none().bits();
        }
        *(enum_ptr as *mut u64) = iter_bits;
        *(enum_ptr.add(std::mem::size_of::<u64>()) as *mut u64) = index_bits;
        inc_ref_bits(_py, index_bits);
        MoltObject::from_ptr(enum_ptr).bits()
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_iter(iter_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        if let Some(ptr) = maybe_ptr_from_bits(iter_bits) {
            unsafe {
                let type_id = object_type_id(ptr);
                if let Some(dict_bits) = dict_like_bits_from_ptr(_py, ptr) {
                    let target_bits = molt_dict_keys(dict_bits);
                    if obj_from_bits(target_bits).is_none() {
                        return MoltObject::none().bits();
                    }
                    let total = std::mem::size_of::<MoltHeader>()
                        + std::mem::size_of::<u64>()
                        + std::mem::size_of::<usize>();
                    let iter_ptr = alloc_object(_py, total, TYPE_ID_ITER);
                    if iter_ptr.is_null() {
                        return MoltObject::none().bits();
                    }
                    *(iter_ptr as *mut u64) = target_bits;
                    iter_set_index(iter_ptr, 0);
                    return MoltObject::from_ptr(iter_ptr).bits();
                }
                if type_id == TYPE_ID_GENERATOR {
                    inc_ref_bits(_py, iter_bits);
                    return iter_bits;
                }
                if type_id == TYPE_ID_ENUMERATE {
                    inc_ref_bits(_py, iter_bits);
                    return iter_bits;
                }
                if type_id == TYPE_ID_ITER {
                    inc_ref_bits(_py, iter_bits);
                    return iter_bits;
                }
                if type_id == TYPE_ID_CALL_ITER
                    || type_id == TYPE_ID_REVERSED
                    || type_id == TYPE_ID_ZIP
                    || type_id == TYPE_ID_MAP
                    || type_id == TYPE_ID_FILTER
                {
                    inc_ref_bits(_py, iter_bits);
                    return iter_bits;
                }
                if type_id == TYPE_ID_LIST
                    || type_id == TYPE_ID_TUPLE
                    || type_id == TYPE_ID_STRING
                    || type_id == TYPE_ID_BYTES
                    || type_id == TYPE_ID_BYTEARRAY
                    || type_id == TYPE_ID_DICT
                    || type_id == TYPE_ID_SET
                    || type_id == TYPE_ID_FROZENSET
                    || type_id == TYPE_ID_DICT_KEYS_VIEW
                    || type_id == TYPE_ID_DICT_VALUES_VIEW
                    || type_id == TYPE_ID_DICT_ITEMS_VIEW
                    || type_id == TYPE_ID_RANGE
                {
                    let total = std::mem::size_of::<MoltHeader>()
                        + std::mem::size_of::<u64>()
                        + std::mem::size_of::<usize>();
                    let iter_ptr = alloc_object(_py, total, TYPE_ID_ITER);
                    if iter_ptr.is_null() {
                        return MoltObject::none().bits();
                    }
                    inc_ref_bits(_py, iter_bits);
                    *(iter_ptr as *mut u64) = iter_bits;
                    iter_set_index(iter_ptr, 0);
                    return MoltObject::from_ptr(iter_ptr).bits();
                }
                if let Some(name_bits) = attr_name_bits_from_bytes(_py, b"__iter__") {
                    if let Some(call_bits) = attr_lookup_ptr_allow_missing(_py, ptr, name_bits) {
                        dec_ref_bits(_py, name_bits);
                        let res = call_callable0(_py, call_bits);
                        dec_ref_bits(_py, call_bits);
                        if exception_pending(_py) {
                            return MoltObject::none().bits();
                        }
                        if !is_iterator_bits(_py, res) {
                            let msg = format!(
                                "iter() returned non-iterator of type '{}'",
                                type_name(_py, obj_from_bits(res))
                            );
                            return raise_exception::<_>(_py, "TypeError", &msg);
                        }
                        if res == iter_bits {
                            // __iter__ returning self must hand out a new reference.
                            inc_ref_bits(_py, res);
                        }
                        return res;
                    }
                    dec_ref_bits(_py, name_bits);
                }
                if let Some(name_bits) = attr_name_bits_from_bytes(_py, b"__getitem__") {
                    if let Some(call_bits) = attr_lookup_ptr_allow_missing(_py, ptr, name_bits) {
                        dec_ref_bits(_py, call_bits);
                        dec_ref_bits(_py, name_bits);
                        let total = std::mem::size_of::<MoltHeader>()
                            + std::mem::size_of::<u64>()
                            + std::mem::size_of::<usize>();
                        let iter_ptr = alloc_object(_py, total, TYPE_ID_ITER);
                        if iter_ptr.is_null() {
                            return MoltObject::none().bits();
                        }
                        inc_ref_bits(_py, iter_bits);
                        *(iter_ptr as *mut u64) = iter_bits;
                        iter_set_index(iter_ptr, 0);
                        return MoltObject::from_ptr(iter_ptr).bits();
                    }
                    dec_ref_bits(_py, name_bits);
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_iter_checked(iter_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let res = molt_iter(iter_bits);
        if obj_from_bits(res).is_none() {
            if exception_pending(_py) {
                return res;
            }
            if std::env::var("MOLT_DEBUG_ITER").as_deref() == Ok("1") {
                let iter_obj = obj_from_bits(iter_bits);
                eprintln!(
                    "molt_iter_checked: non-iterable type={} bits=0x{:x}",
                    type_name(_py, iter_obj),
                    iter_bits
                );
            }
            return raise_not_iterable(_py, iter_bits);
        }
        res
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_iter_sentinel(callable_bits: u64, sentinel_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let callable_ok = is_truthy(_py, obj_from_bits(molt_is_callable(callable_bits)));
        if !callable_ok {
            return raise_exception::<_>(_py, "TypeError", "iter(v, w): v must be callable");
        }
        let total = std::mem::size_of::<MoltHeader>() + 2 * std::mem::size_of::<u64>();
        let iter_ptr = alloc_object(_py, total, TYPE_ID_CALL_ITER);
        if iter_ptr.is_null() {
            return MoltObject::none().bits();
        }
        unsafe {
            *(iter_ptr as *mut u64) = callable_bits;
            *(iter_ptr.add(std::mem::size_of::<u64>()) as *mut u64) = sentinel_bits;
        }
        inc_ref_bits(_py, callable_bits);
        inc_ref_bits(_py, sentinel_bits);
        MoltObject::from_ptr(iter_ptr).bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_aiter(obj_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        unsafe {
            let obj = obj_from_bits(obj_bits);
            let Some(name_bits) = attr_name_bits_from_bytes(_py, b"__aiter__") else {
                return MoltObject::none().bits();
            };
            let Some(obj_ptr) = maybe_ptr_from_bits(obj_bits) else {
                dec_ref_bits(_py, name_bits);
                let msg = format!("'{}' object is not async iterable", type_name(_py, obj));
                return raise_exception::<_>(_py, "TypeError", &msg);
            };
            let Some(call_bits) = attr_lookup_ptr_allow_missing(_py, obj_ptr, name_bits) else {
                dec_ref_bits(_py, name_bits);
                let msg = format!("'{}' object is not async iterable", type_name(_py, obj));
                return raise_exception::<_>(_py, "TypeError", &msg);
            };
            dec_ref_bits(_py, name_bits);
            let res = call_callable0(_py, call_bits);
            dec_ref_bits(_py, call_bits);
            res
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_iter_next(iter_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        if let Some(ptr) = maybe_ptr_from_bits(iter_bits) {
            unsafe {
                if object_type_id(ptr) == TYPE_ID_GENERATOR {
                    let res_bits = molt_generator_send(iter_bits, MoltObject::none().bits());
                    if exception_pending(_py) {
                        return res_bits;
                    }
                    let res_obj = obj_from_bits(res_bits);
                    if let Some(res_ptr) = res_obj.as_ptr() {
                        if object_type_id(res_ptr) == TYPE_ID_TUPLE {
                            let elems = seq_vec_ref(res_ptr);
                            if elems.len() >= 2 {
                                let done = is_truthy(_py, obj_from_bits(elems[1]));
                                if done {
                                    let closed_bits = MoltObject::from_bool(true).bits();
                                    *(ptr.add(GEN_CLOSED_OFFSET) as *mut u64) = closed_bits;
                                }
                            }
                        }
                    }
                    return res_bits;
                }
                if object_type_id(ptr) == TYPE_ID_ENUMERATE {
                    let iter_bits = enumerate_target_bits(ptr);
                    let pair_bits = molt_iter_next(iter_bits);
                    let pair_obj = obj_from_bits(pair_bits);
                    let Some(pair_ptr) = pair_obj.as_ptr() else {
                        return MoltObject::none().bits();
                    };
                    if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                        return MoltObject::none().bits();
                    }
                    let elems = seq_vec_ref(pair_ptr);
                    if elems.len() < 2 {
                        return MoltObject::none().bits();
                    }
                    let val_bits = elems[0];
                    let done_bits = elems[1];
                    if is_truthy(_py, obj_from_bits(done_bits)) {
                        return pair_bits;
                    }
                    let idx_bits = enumerate_index_bits(ptr);
                    let item_ptr = alloc_tuple(_py, &[idx_bits, val_bits]);
                    if item_ptr.is_null() {
                        return MoltObject::none().bits();
                    }
                    let item_bits = MoltObject::from_ptr(item_ptr).bits();
                    let done_false = MoltObject::from_bool(false).bits();
                    let out_ptr = alloc_tuple(_py, &[item_bits, done_false]);
                    if out_ptr.is_null() {
                        dec_ref_bits(_py, item_bits);
                        return MoltObject::none().bits();
                    }
                    dec_ref_bits(_py, item_bits);
                    let next_bits = molt_add(idx_bits, MoltObject::from_int(1).bits());
                    if obj_from_bits(next_bits).is_none() {
                        return MoltObject::none().bits();
                    }
                    dec_ref_bits(_py, idx_bits);
                    enumerate_set_index_bits(ptr, next_bits);
                    return MoltObject::from_ptr(out_ptr).bits();
                }
                if object_type_id(ptr) == TYPE_ID_CALL_ITER {
                    let call_bits = call_iter_callable_bits(ptr);
                    let sentinel_bits = call_iter_sentinel_bits(ptr);
                    let val_bits = call_callable0(_py, call_bits);
                    if exception_pending(_py) {
                        dec_ref_bits(_py, val_bits);
                        return MoltObject::none().bits();
                    }
                    if obj_eq(_py, obj_from_bits(val_bits), obj_from_bits(sentinel_bits)) {
                        dec_ref_bits(_py, val_bits);
                        return generator_done_tuple(_py, MoltObject::none().bits());
                    }
                    let done_bits = MoltObject::from_bool(false).bits();
                    let tuple_ptr = alloc_tuple(_py, &[val_bits, done_bits]);
                    if tuple_ptr.is_null() {
                        dec_ref_bits(_py, val_bits);
                        return MoltObject::none().bits();
                    }
                    dec_ref_bits(_py, val_bits);
                    return MoltObject::from_ptr(tuple_ptr).bits();
                }
                if object_type_id(ptr) == TYPE_ID_MAP {
                    let func_bits = map_func_bits(ptr);
                    let iters_ptr = map_iters_ptr(ptr);
                    if iters_ptr.is_null() {
                        return generator_done_tuple(_py, MoltObject::none().bits());
                    }
                    let iters = &mut *iters_ptr;
                    if iters.is_empty() {
                        return generator_done_tuple(_py, MoltObject::none().bits());
                    }
                    let mut vals = Vec::with_capacity(iters.len());
                    for &iter_bits in iters.iter() {
                        let pair_bits = molt_iter_next(iter_bits);
                        let pair_obj = obj_from_bits(pair_bits);
                        let Some(pair_ptr) = pair_obj.as_ptr() else {
                            return MoltObject::none().bits();
                        };
                        if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                            return raise_exception::<_>(
                                _py,
                                "TypeError",
                                "object is not an iterator",
                            );
                        }
                        let elems = seq_vec_ref(pair_ptr);
                        if elems.len() < 2 {
                            return raise_exception::<_>(
                                _py,
                                "TypeError",
                                "object is not an iterator",
                            );
                        }
                        let val_bits = elems[0];
                        let done_bits = elems[1];
                        if is_truthy(_py, obj_from_bits(done_bits)) {
                            return generator_done_tuple(_py, MoltObject::none().bits());
                        }
                        vals.push(val_bits);
                    }
                    // Route map callable invocation through bind so Python
                    // function defaults are honored (e.g. def f(x, y=...)).
                    let builder_bits = molt_callargs_new(vals.len() as u64, 0);
                    if builder_bits == 0 {
                        return MoltObject::none().bits();
                    }
                    for &val_bits in &vals {
                        let _ = molt_callargs_push_pos(builder_bits, val_bits);
                    }
                    let res_bits = molt_call_bind(func_bits, builder_bits);
                    if exception_pending(_py) {
                        dec_ref_bits(_py, res_bits);
                        return MoltObject::none().bits();
                    }
                    let done_bits = MoltObject::from_bool(false).bits();
                    let tuple_ptr = alloc_tuple(_py, &[res_bits, done_bits]);
                    if tuple_ptr.is_null() {
                        dec_ref_bits(_py, res_bits);
                        return MoltObject::none().bits();
                    }
                    dec_ref_bits(_py, res_bits);
                    return MoltObject::from_ptr(tuple_ptr).bits();
                }
                if object_type_id(ptr) == TYPE_ID_FILTER {
                    let func_bits = filter_func_bits(ptr);
                    let iter_bits = filter_iter_bits(ptr);
                    loop {
                        let pair_bits = molt_iter_next(iter_bits);
                        let pair_obj = obj_from_bits(pair_bits);
                        let Some(pair_ptr) = pair_obj.as_ptr() else {
                            return MoltObject::none().bits();
                        };
                        if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                            return raise_exception::<_>(
                                _py,
                                "TypeError",
                                "object is not an iterator",
                            );
                        }
                        let elems = seq_vec_ref(pair_ptr);
                        if elems.len() < 2 {
                            return raise_exception::<_>(
                                _py,
                                "TypeError",
                                "object is not an iterator",
                            );
                        }
                        let val_bits = elems[0];
                        let done_bits = elems[1];
                        if is_truthy(_py, obj_from_bits(done_bits)) {
                            return generator_done_tuple(_py, MoltObject::none().bits());
                        }
                        let keep = if obj_from_bits(func_bits).is_none() {
                            is_truthy(_py, obj_from_bits(val_bits))
                        } else {
                            let pred_bits = call_callable1(_py, func_bits, val_bits);
                            if exception_pending(_py) {
                                dec_ref_bits(_py, pred_bits);
                                return MoltObject::none().bits();
                            }
                            let keep = is_truthy(_py, obj_from_bits(pred_bits));
                            dec_ref_bits(_py, pred_bits);
                            keep
                        };
                        if keep {
                            let done_bits = MoltObject::from_bool(false).bits();
                            let tuple_ptr = alloc_tuple(_py, &[val_bits, done_bits]);
                            if tuple_ptr.is_null() {
                                return MoltObject::none().bits();
                            }
                            return MoltObject::from_ptr(tuple_ptr).bits();
                        }
                    }
                }
                if object_type_id(ptr) == TYPE_ID_ZIP {
                    let iters_ptr = zip_iters_ptr(ptr);
                    if iters_ptr.is_null() {
                        return generator_done_tuple(_py, MoltObject::none().bits());
                    }
                    let iters = &mut *iters_ptr;
                    if iters.is_empty() {
                        return generator_done_tuple(_py, MoltObject::none().bits());
                    }
                    let strict = is_truthy(_py, obj_from_bits(zip_strict_bits(ptr)));
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    let mut vals = Vec::with_capacity(iters.len());
                    if strict {
                        let mut done_flags = Vec::with_capacity(iters.len());
                        for &iter_bits in iters.iter() {
                            let pair_bits = molt_iter_next(iter_bits);
                            let pair_obj = obj_from_bits(pair_bits);
                            let Some(pair_ptr) = pair_obj.as_ptr() else {
                                return MoltObject::none().bits();
                            };
                            if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                                return raise_exception::<_>(
                                    _py,
                                    "TypeError",
                                    "object is not an iterator",
                                );
                            }
                            let elems = seq_vec_ref(pair_ptr);
                            if elems.len() < 2 {
                                return raise_exception::<_>(
                                    _py,
                                    "TypeError",
                                    "object is not an iterator",
                                );
                            }
                            let val_bits = elems[0];
                            let done_bits = elems[1];
                            let done = is_truthy(_py, obj_from_bits(done_bits));
                            if exception_pending(_py) {
                                return MoltObject::none().bits();
                            }
                            vals.push(val_bits);
                            done_flags.push(done);
                        }
                        if done_flags.iter().all(|done| *done) {
                            return generator_done_tuple(_py, MoltObject::none().bits());
                        }
                        if done_flags.first().copied().unwrap_or(false) {
                            if let Some(idx) = done_flags[1..].iter().position(|done| !*done) {
                                let msg =
                                    format!("zip() argument {} is longer than argument 1", idx + 2);
                                return raise_exception::<_>(_py, "ValueError", &msg);
                            }
                            return generator_done_tuple(_py, MoltObject::none().bits());
                        }
                        if let Some(idx) = done_flags[1..].iter().position(|done| *done) {
                            let msg =
                                format!("zip() argument {} is shorter than argument 1", idx + 2);
                            return raise_exception::<_>(_py, "ValueError", &msg);
                        }
                    } else {
                        for &iter_bits in iters.iter() {
                            let pair_bits = molt_iter_next(iter_bits);
                            let pair_obj = obj_from_bits(pair_bits);
                            let Some(pair_ptr) = pair_obj.as_ptr() else {
                                return MoltObject::none().bits();
                            };
                            if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                                return raise_exception::<_>(
                                    _py,
                                    "TypeError",
                                    "object is not an iterator",
                                );
                            }
                            let elems = seq_vec_ref(pair_ptr);
                            if elems.len() < 2 {
                                return raise_exception::<_>(
                                    _py,
                                    "TypeError",
                                    "object is not an iterator",
                                );
                            }
                            let val_bits = elems[0];
                            let done_bits = elems[1];
                            if is_truthy(_py, obj_from_bits(done_bits)) {
                                return generator_done_tuple(_py, MoltObject::none().bits());
                            }
                            vals.push(val_bits);
                        }
                    }
                    let tuple_ptr = alloc_tuple(_py, vals.as_slice());
                    if tuple_ptr.is_null() {
                        return MoltObject::none().bits();
                    }
                    let val_bits = MoltObject::from_ptr(tuple_ptr).bits();
                    let done_bits = MoltObject::from_bool(false).bits();
                    let out_ptr = alloc_tuple(_py, &[val_bits, done_bits]);
                    if out_ptr.is_null() {
                        dec_ref_bits(_py, val_bits);
                        return MoltObject::none().bits();
                    }
                    dec_ref_bits(_py, val_bits);
                    return MoltObject::from_ptr(out_ptr).bits();
                }
                if object_type_id(ptr) == TYPE_ID_REVERSED {
                    let target_bits = reversed_target_bits(ptr);
                    let target_obj = obj_from_bits(target_bits);
                    let idx = reversed_index(ptr);
                    let (next_idx, val_bits, needs_drop) = if let Some(target_ptr) =
                        target_obj.as_ptr()
                    {
                        let target_type = object_type_id(target_ptr);
                        if target_type == TYPE_ID_LIST || target_type == TYPE_ID_TUPLE {
                            let elems = seq_vec_ref(target_ptr);
                            let len = elems.len();
                            let idx = idx.min(len);
                            if idx == 0 {
                                (0, None, false)
                            } else {
                                (idx - 1, Some(elems[idx - 1]), false)
                            }
                        } else if target_type == TYPE_ID_RANGE {
                            let Some((start, stop, step)) = range_components_bigint(target_ptr)
                            else {
                                return MoltObject::none().bits();
                            };
                            let len = range_len_bigint(&start, &stop, &step);
                            let len_usize = len.to_usize().unwrap_or(idx);
                            let idx = idx.min(len_usize);
                            if idx == 0 {
                                (0, None, false)
                            } else {
                                let pos = BigInt::from((idx - 1) as u64);
                                let val = start + step * pos;
                                let bits = int_bits_from_bigint(_py, val);
                                if obj_from_bits(bits).is_none() {
                                    return MoltObject::none().bits();
                                }
                                (idx - 1, Some(bits), false)
                            }
                        } else if target_type == TYPE_ID_STRING {
                            let bytes = std::slice::from_raw_parts(
                                string_bytes(target_ptr),
                                string_len(target_ptr),
                            );
                            let idx = idx.min(bytes.len());
                            if idx == 0 {
                                (0, None, false)
                            } else {
                                let Ok(text) = std::str::from_utf8(&bytes[..idx]) else {
                                    return MoltObject::none().bits();
                                };
                                if let Some(ch) = text.chars().next_back() {
                                    let mut buf = [0u8; 4];
                                    let out = ch.encode_utf8(&mut buf);
                                    let out_ptr = alloc_string(_py, out.as_bytes());
                                    if out_ptr.is_null() {
                                        return MoltObject::none().bits();
                                    }
                                    let val_bits = MoltObject::from_ptr(out_ptr).bits();
                                    let next_idx = idx - ch.len_utf8();
                                    (next_idx, Some(val_bits), true)
                                } else {
                                    (0, None, false)
                                }
                            }
                        } else if target_type == TYPE_ID_BYTES || target_type == TYPE_ID_BYTEARRAY {
                            let bytes = std::slice::from_raw_parts(
                                bytes_data(target_ptr),
                                bytes_len(target_ptr),
                            );
                            let idx = idx.min(bytes.len());
                            if idx == 0 {
                                (0, None, false)
                            } else {
                                let pos = idx - 1;
                                let val_bits = MoltObject::from_int(bytes[pos] as i64).bits();
                                (idx - 1, Some(val_bits), false)
                            }
                        } else if target_type == TYPE_ID_DICT {
                            let order = dict_order(target_ptr);
                            let len = order.len() / 2;
                            let idx = idx.min(len);
                            if idx == 0 {
                                (0, None, false)
                            } else {
                                let entry = (idx - 1) * 2;
                                (idx - 1, Some(order[entry]), false)
                            }
                        } else if target_type == TYPE_ID_DICT_KEYS_VIEW
                            || target_type == TYPE_ID_DICT_VALUES_VIEW
                            || target_type == TYPE_ID_DICT_ITEMS_VIEW
                        {
                            let len = dict_view_len(target_ptr);
                            let idx = idx.min(len);
                            if idx == 0 {
                                (0, None, false)
                            } else if let Some((key_bits, val_bits)) =
                                dict_view_entry(target_ptr, idx - 1)
                            {
                                if target_type == TYPE_ID_DICT_ITEMS_VIEW {
                                    let tuple_ptr = alloc_tuple(_py, &[key_bits, val_bits]);
                                    if tuple_ptr.is_null() {
                                        return MoltObject::none().bits();
                                    }
                                    (idx - 1, Some(MoltObject::from_ptr(tuple_ptr).bits()), true)
                                } else if target_type == TYPE_ID_DICT_KEYS_VIEW {
                                    (idx - 1, Some(key_bits), false)
                                } else {
                                    (idx - 1, Some(val_bits), false)
                                }
                            } else {
                                (0, None, false)
                            }
                        } else {
                            (0, None, false)
                        }
                    } else {
                        (0, None, false)
                    };
                    if let Some(val_bits) = val_bits {
                        reversed_set_index(ptr, next_idx);
                        let done_bits = MoltObject::from_bool(false).bits();
                        let tuple_ptr = alloc_tuple(_py, &[val_bits, done_bits]);
                        if tuple_ptr.is_null() {
                            if needs_drop {
                                dec_ref_bits(_py, val_bits);
                            }
                            return MoltObject::none().bits();
                        }
                        if needs_drop {
                            dec_ref_bits(_py, val_bits);
                        }
                        return MoltObject::from_ptr(tuple_ptr).bits();
                    }
                    reversed_set_index(ptr, 0);
                    return generator_done_tuple(_py, MoltObject::none().bits());
                }
                if object_type_id(ptr) != TYPE_ID_ITER {
                    if let Some(name_bits) = attr_name_bits_from_bytes(_py, b"__next__") {
                        if let Some(call_bits) = attr_lookup_ptr(_py, ptr, name_bits) {
                            dec_ref_bits(_py, name_bits);
                            exception_stack_push();
                            let val_bits = call_callable0(_py, call_bits);
                            dec_ref_bits(_py, call_bits);
                            if exception_pending(_py) {
                                let exc_bits = molt_exception_last();
                                let kind_bits = molt_exception_kind(exc_bits);
                                let kind = string_obj_to_owned(obj_from_bits(kind_bits));
                                dec_ref_bits(_py, kind_bits);
                                if kind.as_deref() == Some("StopIteration") {
                                    let value_bits =
                                        if let Some(exc_ptr) = maybe_ptr_from_bits(exc_bits) {
                                            if object_type_id(exc_ptr) == TYPE_ID_EXCEPTION {
                                                exception_value_bits(exc_ptr)
                                            } else {
                                                MoltObject::none().bits()
                                            }
                                        } else {
                                            MoltObject::none().bits()
                                        };
                                    molt_exception_clear();
                                    exception_stack_pop(_py);
                                    let out_bits = generator_done_tuple(_py, value_bits);
                                    dec_ref_bits(_py, exc_bits);
                                    return out_bits;
                                }
                                dec_ref_bits(_py, exc_bits);
                                exception_stack_pop(_py);
                                return MoltObject::none().bits();
                            }
                            exception_stack_pop(_py);
                            let done_bits = MoltObject::from_bool(false).bits();
                            let tuple_ptr = alloc_tuple(_py, &[val_bits, done_bits]);
                            if tuple_ptr.is_null() {
                                return MoltObject::none().bits();
                            }
                            return MoltObject::from_ptr(tuple_ptr).bits();
                        }
                        dec_ref_bits(_py, name_bits);
                    }
                    return MoltObject::none().bits();
                }
                let target_bits = iter_target_bits(ptr);
                let target_obj = obj_from_bits(target_bits);
                let idx = iter_index(ptr);
                if let Some(target_ptr) = target_obj.as_ptr() {
                    let target_type = object_type_id(target_ptr);
                    if target_type == TYPE_ID_SET || target_type == TYPE_ID_FROZENSET {
                        let table = set_table(target_ptr);
                        let order = set_order(target_ptr);
                        let mut slot = idx;
                        while slot < table.len() && table[slot] == 0 {
                            slot += 1;
                        }
                        if slot >= table.len() {
                            iter_set_index(ptr, table.len());
                            let none_bits = MoltObject::none().bits();
                            let done_bits = MoltObject::from_bool(true).bits();
                            let tuple_ptr = alloc_tuple(_py, &[none_bits, done_bits]);
                            if tuple_ptr.is_null() {
                                return MoltObject::none().bits();
                            }
                            return MoltObject::from_ptr(tuple_ptr).bits();
                        }
                        let entry_idx = table[slot] - 1;
                        let val_bits = order[entry_idx];
                        iter_set_index(ptr, slot + 1);
                        let done_bits = MoltObject::from_bool(false).bits();
                        let tuple_ptr = alloc_tuple(_py, &[val_bits, done_bits]);
                        if tuple_ptr.is_null() {
                            return MoltObject::none().bits();
                        }
                        return MoltObject::from_ptr(tuple_ptr).bits();
                    }
                }
                if let Some(target_ptr) = target_obj.as_ptr() {
                    let target_type = object_type_id(target_ptr);
                    if target_type == TYPE_ID_STRING {
                        let bytes = std::slice::from_raw_parts(
                            string_bytes(target_ptr),
                            string_len(target_ptr),
                        );
                        if idx >= bytes.len() {
                            let none_bits = MoltObject::none().bits();
                            let done_bits = MoltObject::from_bool(true).bits();
                            let tuple_ptr = alloc_tuple(_py, &[none_bits, done_bits]);
                            if tuple_ptr.is_null() {
                                return MoltObject::none().bits();
                            }
                            return MoltObject::from_ptr(tuple_ptr).bits();
                        }
                        let tail = &bytes[idx..];
                        let Ok(text) = std::str::from_utf8(tail) else {
                            return MoltObject::none().bits();
                        };
                        let Some(ch) = text.chars().next() else {
                            let none_bits = MoltObject::none().bits();
                            let done_bits = MoltObject::from_bool(true).bits();
                            let tuple_ptr = alloc_tuple(_py, &[none_bits, done_bits]);
                            if tuple_ptr.is_null() {
                                return MoltObject::none().bits();
                            }
                            return MoltObject::from_ptr(tuple_ptr).bits();
                        };
                        let mut buf = [0u8; 4];
                        let out = ch.encode_utf8(&mut buf);
                        let out_ptr = alloc_string(_py, out.as_bytes());
                        if out_ptr.is_null() {
                            return MoltObject::none().bits();
                        }
                        let val_bits = MoltObject::from_ptr(out_ptr).bits();
                        let next_idx = idx + ch.len_utf8();
                        iter_set_index(ptr, next_idx);
                        let done_bits = MoltObject::from_bool(false).bits();
                        let tuple_ptr = alloc_tuple(_py, &[val_bits, done_bits]);
                        if tuple_ptr.is_null() {
                            dec_ref_bits(_py, val_bits);
                            return MoltObject::none().bits();
                        }
                        dec_ref_bits(_py, val_bits);
                        return MoltObject::from_ptr(tuple_ptr).bits();
                    }
                    if target_type == TYPE_ID_BYTES || target_type == TYPE_ID_BYTEARRAY {
                        let bytes = std::slice::from_raw_parts(
                            bytes_data(target_ptr),
                            bytes_len(target_ptr),
                        );
                        if idx >= bytes.len() {
                            let none_bits = MoltObject::none().bits();
                            let done_bits = MoltObject::from_bool(true).bits();
                            let tuple_ptr = alloc_tuple(_py, &[none_bits, done_bits]);
                            if tuple_ptr.is_null() {
                                return MoltObject::none().bits();
                            }
                            return MoltObject::from_ptr(tuple_ptr).bits();
                        }
                        let val_bits = MoltObject::from_int(bytes[idx] as i64).bits();
                        iter_set_index(ptr, idx + 1);
                        let done_bits = MoltObject::from_bool(false).bits();
                        let tuple_ptr = alloc_tuple(_py, &[val_bits, done_bits]);
                        if tuple_ptr.is_null() {
                            return MoltObject::none().bits();
                        }
                        return MoltObject::from_ptr(tuple_ptr).bits();
                    }
                    if target_type == TYPE_ID_LIST {
                        let elems = seq_vec_ref(target_ptr);
                        if idx == ITER_EXHAUSTED || idx >= elems.len() {
                            iter_set_index(ptr, ITER_EXHAUSTED);
                            let none_bits = MoltObject::none().bits();
                            let done_bits = MoltObject::from_bool(true).bits();
                            let tuple_ptr = alloc_tuple(_py, &[none_bits, done_bits]);
                            if tuple_ptr.is_null() {
                                return MoltObject::none().bits();
                            }
                            return MoltObject::from_ptr(tuple_ptr).bits();
                        }
                        let val_bits = elems[idx];
                        iter_set_index(ptr, idx + 1);
                        let done_bits = MoltObject::from_bool(false).bits();
                        let tuple_ptr = alloc_tuple(_py, &[val_bits, done_bits]);
                        if tuple_ptr.is_null() {
                            return MoltObject::none().bits();
                        }
                        return MoltObject::from_ptr(tuple_ptr).bits();
                    }
                    if target_type == TYPE_ID_RANGE {
                        if let Some((start_i64, stop_i64, step_i64)) =
                            range_components_i64(target_ptr)
                        {
                            if idx == ITER_EXHAUSTED {
                                let none_bits = MoltObject::none().bits();
                                let done_bits = MoltObject::from_bool(true).bits();
                                let tuple_ptr = alloc_tuple(_py, &[none_bits, done_bits]);
                                if tuple_ptr.is_null() {
                                    return MoltObject::none().bits();
                                }
                                return MoltObject::from_ptr(tuple_ptr).bits();
                            }
                            if let Some(value) =
                                range_value_at_index_i64(start_i64, stop_i64, step_i64, idx as i128)
                            {
                                let val_bits = MoltObject::from_int(value).bits();
                                let next_idx = idx.checked_add(1).unwrap_or(ITER_EXHAUSTED);
                                iter_set_index(ptr, next_idx);
                                let done_bits = MoltObject::from_bool(false).bits();
                                let tuple_ptr = alloc_tuple(_py, &[val_bits, done_bits]);
                                if tuple_ptr.is_null() {
                                    return MoltObject::none().bits();
                                }
                                return MoltObject::from_ptr(tuple_ptr).bits();
                            }
                            let len = range_len_i128(start_i64, stop_i64, step_i64);
                            let len_usize = usize::try_from(len).unwrap_or(ITER_EXHAUSTED);
                            iter_set_index(ptr, len_usize);
                            let none_bits = MoltObject::none().bits();
                            let done_bits = MoltObject::from_bool(true).bits();
                            let tuple_ptr = alloc_tuple(_py, &[none_bits, done_bits]);
                            if tuple_ptr.is_null() {
                                return MoltObject::none().bits();
                            }
                            return MoltObject::from_ptr(tuple_ptr).bits();
                        }
                        let Some((start, stop, step)) = range_components_bigint(target_ptr) else {
                            return MoltObject::none().bits();
                        };
                        if idx == ITER_EXHAUSTED {
                            let none_bits = MoltObject::none().bits();
                            let done_bits = MoltObject::from_bool(true).bits();
                            let tuple_ptr = alloc_tuple(_py, &[none_bits, done_bits]);
                            if tuple_ptr.is_null() {
                                return MoltObject::none().bits();
                            }
                            return MoltObject::from_ptr(tuple_ptr).bits();
                        }
                        if step.is_zero() {
                            let none_bits = MoltObject::none().bits();
                            let done_bits = MoltObject::from_bool(true).bits();
                            let tuple_ptr = alloc_tuple(_py, &[none_bits, done_bits]);
                            if tuple_ptr.is_null() {
                                return MoltObject::none().bits();
                            }
                            return MoltObject::from_ptr(tuple_ptr).bits();
                        }
                        let len = range_len_bigint(&start, &stop, &step);
                        let idx_big = BigInt::from(idx as u64);
                        if idx_big >= len {
                            let len_usize = len.to_usize().unwrap_or(ITER_EXHAUSTED);
                            iter_set_index(ptr, len_usize);
                            let none_bits = MoltObject::none().bits();
                            let done_bits = MoltObject::from_bool(true).bits();
                            let tuple_ptr = alloc_tuple(_py, &[none_bits, done_bits]);
                            if tuple_ptr.is_null() {
                                return MoltObject::none().bits();
                            }
                            return MoltObject::from_ptr(tuple_ptr).bits();
                        }
                        let val = start + step * idx_big;
                        let val_bits = int_bits_from_bigint(_py, val);
                        if obj_from_bits(val_bits).is_none() {
                            return MoltObject::none().bits();
                        }
                        let next_idx = idx.checked_add(1).unwrap_or(ITER_EXHAUSTED);
                        iter_set_index(ptr, next_idx);
                        let done_bits = MoltObject::from_bool(false).bits();
                        let tuple_ptr = alloc_tuple(_py, &[val_bits, done_bits]);
                        if tuple_ptr.is_null() {
                            return MoltObject::none().bits();
                        }
                        dec_ref_bits(_py, val_bits);
                        return MoltObject::from_ptr(tuple_ptr).bits();
                    }
                    if target_type != TYPE_ID_TUPLE
                        && target_type != TYPE_ID_RANGE
                        && target_type != TYPE_ID_DICT_KEYS_VIEW
                        && target_type != TYPE_ID_DICT_VALUES_VIEW
                        && target_type != TYPE_ID_DICT_ITEMS_VIEW
                    {
                        if let Some(name_bits) = attr_name_bits_from_bytes(_py, b"__getitem__") {
                            if let Some(call_bits) =
                                attr_lookup_ptr_allow_missing(_py, target_ptr, name_bits)
                            {
                                dec_ref_bits(_py, name_bits);
                                exception_stack_push();
                                let idx_bits = MoltObject::from_int(idx as i64).bits();
                                let val_bits = call_callable1(_py, call_bits, idx_bits);
                                dec_ref_bits(_py, call_bits);
                                if exception_pending(_py) {
                                    let exc_bits = molt_exception_last();
                                    let kind_bits = molt_exception_kind(exc_bits);
                                    let kind = string_obj_to_owned(obj_from_bits(kind_bits));
                                    dec_ref_bits(_py, kind_bits);
                                    if kind.as_deref() == Some("IndexError") {
                                        molt_exception_clear();
                                        exception_stack_pop(_py);
                                        let none_bits = MoltObject::none().bits();
                                        let done_bits = MoltObject::from_bool(true).bits();
                                        let tuple_ptr = alloc_tuple(_py, &[none_bits, done_bits]);
                                        if tuple_ptr.is_null() {
                                            dec_ref_bits(_py, exc_bits);
                                            return MoltObject::none().bits();
                                        }
                                        dec_ref_bits(_py, exc_bits);
                                        return MoltObject::from_ptr(tuple_ptr).bits();
                                    }
                                    dec_ref_bits(_py, exc_bits);
                                    exception_stack_pop(_py);
                                    return MoltObject::none().bits();
                                }
                                exception_stack_pop(_py);
                                iter_set_index(ptr, idx + 1);
                                let done_bits = MoltObject::from_bool(false).bits();
                                let tuple_ptr = alloc_tuple(_py, &[val_bits, done_bits]);
                                if tuple_ptr.is_null() {
                                    return MoltObject::none().bits();
                                }
                                return MoltObject::from_ptr(tuple_ptr).bits();
                            }
                            dec_ref_bits(_py, name_bits);
                        }
                    }
                }
                let (len, next_val, needs_drop) = if let Some(target_ptr) = target_obj.as_ptr() {
                    let target_type = object_type_id(target_ptr);
                    if target_type == TYPE_ID_TUPLE {
                        let elems = seq_vec_ref(target_ptr);
                        if idx >= elems.len() {
                            (elems.len(), None, false)
                        } else {
                            (elems.len(), Some(elems[idx]), false)
                        }
                    } else if target_type == TYPE_ID_RANGE {
                        (0, None, false)
                    } else if target_type == TYPE_ID_DICT_KEYS_VIEW
                        || target_type == TYPE_ID_DICT_VALUES_VIEW
                        || target_type == TYPE_ID_DICT_ITEMS_VIEW
                    {
                        let len = dict_view_len(target_ptr);
                        if idx >= len {
                            (len, None, false)
                        } else if let Some((key_bits, val_bits)) = dict_view_entry(target_ptr, idx)
                        {
                            if target_type == TYPE_ID_DICT_ITEMS_VIEW {
                                let tuple_ptr = alloc_tuple(_py, &[key_bits, val_bits]);
                                if tuple_ptr.is_null() {
                                    return MoltObject::none().bits();
                                }
                                (len, Some(MoltObject::from_ptr(tuple_ptr).bits()), true)
                            } else if target_type == TYPE_ID_DICT_KEYS_VIEW {
                                (len, Some(key_bits), false)
                            } else {
                                (len, Some(val_bits), false)
                            }
                        } else {
                            (len, None, false)
                        }
                    } else {
                        (0, None, false)
                    }
                } else {
                    (0, None, false)
                };

                if let Some(val_bits) = next_val {
                    iter_set_index(ptr, idx + 1);
                    let done_bits = MoltObject::from_bool(false).bits();
                    let tuple_ptr = alloc_tuple(_py, &[val_bits, done_bits]);
                    if tuple_ptr.is_null() {
                        return MoltObject::none().bits();
                    }
                    if needs_drop {
                        dec_ref_bits(_py, val_bits);
                    }
                    return MoltObject::from_ptr(tuple_ptr).bits();
                }
                if idx >= len {
                    iter_set_index(ptr, len);
                }
                let none_bits = MoltObject::none().bits();
                let done_bits = MoltObject::from_bool(true).bits();
                let tuple_ptr = alloc_tuple(_py, &[none_bits, done_bits]);
                if tuple_ptr.is_null() {
                    return MoltObject::none().bits();
                }
                return MoltObject::from_ptr(tuple_ptr).bits();
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_anext(obj_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        unsafe {
            let obj = obj_from_bits(obj_bits);
            let Some(name_bits) = attr_name_bits_from_bytes(_py, b"__anext__") else {
                return MoltObject::none().bits();
            };
            let Some(obj_ptr) = maybe_ptr_from_bits(obj_bits) else {
                dec_ref_bits(_py, name_bits);
                let msg = format!("'{}' object is not an async iterator", type_name(_py, obj));
                return raise_exception::<_>(_py, "TypeError", &msg);
            };
            let Some(call_bits) = attr_lookup_ptr(_py, obj_ptr, name_bits) else {
                dec_ref_bits(_py, name_bits);
                let msg = format!("'{}' object is not an async iterator", type_name(_py, obj));
                return raise_exception::<_>(_py, "TypeError", &msg);
            };
            dec_ref_bits(_py, name_bits);
            let res = call_callable0(_py, call_bits);
            dec_ref_bits(_py, call_bits);
            res
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_dict_keys(dict_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(dict_bits);
        let Some(ptr) = obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "dict.keys expects dict");
        };
        unsafe {
            let Some(dict_bits) = dict_like_bits_from_ptr(_py, ptr) else {
                return raise_exception::<_>(_py, "TypeError", "dict.keys expects dict");
            };
            let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() else {
                return MoltObject::none().bits();
            };
            if object_type_id(dict_ptr) != TYPE_ID_DICT {
                return raise_exception::<_>(_py, "TypeError", "dict.keys expects dict");
            }
            let total = std::mem::size_of::<MoltHeader>() + std::mem::size_of::<u64>();
            let view_ptr = alloc_object(_py, total, TYPE_ID_DICT_KEYS_VIEW);
            if view_ptr.is_null() {
                return MoltObject::none().bits();
            }
            inc_ref_bits(_py, dict_bits);
            *(view_ptr as *mut u64) = dict_bits;
            MoltObject::from_ptr(view_ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_dict_values(dict_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(dict_bits);
        let Some(ptr) = obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "dict.values expects dict");
        };
        unsafe {
            let Some(dict_bits) = dict_like_bits_from_ptr(_py, ptr) else {
                return raise_exception::<_>(_py, "TypeError", "dict.values expects dict");
            };
            let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() else {
                return MoltObject::none().bits();
            };
            if object_type_id(dict_ptr) != TYPE_ID_DICT {
                return raise_exception::<_>(_py, "TypeError", "dict.values expects dict");
            }
            let total = std::mem::size_of::<MoltHeader>() + std::mem::size_of::<u64>();
            let view_ptr = alloc_object(_py, total, TYPE_ID_DICT_VALUES_VIEW);
            if view_ptr.is_null() {
                return MoltObject::none().bits();
            }
            inc_ref_bits(_py, dict_bits);
            *(view_ptr as *mut u64) = dict_bits;
            MoltObject::from_ptr(view_ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_dict_items(dict_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(dict_bits);
        let Some(ptr) = obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "dict.items expects dict");
        };
        unsafe {
            let Some(dict_bits) = dict_like_bits_from_ptr(_py, ptr) else {
                return raise_exception::<_>(_py, "TypeError", "dict.items expects dict");
            };
            let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() else {
                return MoltObject::none().bits();
            };
            if object_type_id(dict_ptr) != TYPE_ID_DICT {
                return raise_exception::<_>(_py, "TypeError", "dict.items expects dict");
            }
            let total = std::mem::size_of::<MoltHeader>() + std::mem::size_of::<u64>();
            let view_ptr = alloc_object(_py, total, TYPE_ID_DICT_ITEMS_VIEW);
            if view_ptr.is_null() {
                return MoltObject::none().bits();
            }
            inc_ref_bits(_py, dict_bits);
            *(view_ptr as *mut u64) = dict_bits;
            MoltObject::from_ptr(view_ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_list_append(list_bits: u64, val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(list_bits);
        if let Some(ptr) = obj.as_ptr() {
            unsafe {
                if object_type_id(ptr) == TYPE_ID_LIST {
                    let elems = seq_vec(ptr);
                    elems.push(val_bits);
                    inc_ref_bits(_py, val_bits);
                    return MoltObject::none().bits();
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_list_pop(list_bits: u64, index_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let obj = obj_from_bits(list_bits);
        let index_obj = obj_from_bits(index_bits);
        if let Some(ptr) = obj.as_ptr() {
            unsafe {
                if object_type_id(ptr) == TYPE_ID_LIST {
                    let len = list_len(ptr) as i64;
                    if len == 0 {
                        return raise_exception::<_>(_py, "IndexError", "pop from empty list");
                    }
                    let mut idx = if index_obj.is_none() {
                        len - 1
                    } else {
                        index_i64_from_obj(
                            _py,
                            index_bits,
                            "list indices must be integers or have an __index__ method",
                        )
                    };
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    if idx < 0 {
                        idx += len;
                    }
                    if idx < 0 || idx >= len {
                        return raise_exception::<_>(_py, "IndexError", "pop index out of range");
                    }
                    let elems = seq_vec(ptr);
                    let idx_usize = idx as usize;
                    let value = elems.remove(idx_usize);
                    inc_ref_bits(_py, value);
                    dec_ref_bits(_py, value);
                    return value;
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_list_extend(list_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let list_obj = obj_from_bits(list_bits);
        if let Some(list_ptr) = list_obj.as_ptr() {
            unsafe {
                if object_type_id(list_ptr) != TYPE_ID_LIST {
                    return MoltObject::none().bits();
                }
                let list_elems = seq_vec(list_ptr);
                let other_obj = obj_from_bits(other_bits);
                if let Some(other_ptr) = other_obj.as_ptr() {
                    let other_type = object_type_id(other_ptr);
                    if other_type == TYPE_ID_LIST || other_type == TYPE_ID_TUPLE {
                        if other_ptr == list_ptr {
                            let snapshot = seq_vec_ref(other_ptr).clone();
                            for item in snapshot {
                                list_elems.push(item);
                                inc_ref_bits(_py, item);
                            }
                        } else {
                            let src = seq_vec_ref(other_ptr);
                            for &item in src.iter() {
                                list_elems.push(item);
                                inc_ref_bits(_py, item);
                            }
                        }
                        return MoltObject::none().bits();
                    }
                    if other_type == TYPE_ID_DICT {
                        let order = dict_order(other_ptr);
                        for idx in (0..order.len()).step_by(2) {
                            let key_bits = order[idx];
                            list_elems.push(key_bits);
                            inc_ref_bits(_py, key_bits);
                        }
                        return MoltObject::none().bits();
                    }
                    if other_type == TYPE_ID_DICT_KEYS_VIEW
                        || other_type == TYPE_ID_DICT_VALUES_VIEW
                        || other_type == TYPE_ID_DICT_ITEMS_VIEW
                    {
                        let len = dict_view_len(other_ptr);
                        for idx in 0..len {
                            if let Some((key_bits, val_bits)) = dict_view_entry(other_ptr, idx) {
                                if other_type == TYPE_ID_DICT_ITEMS_VIEW {
                                    let tuple_ptr = alloc_tuple(_py, &[key_bits, val_bits]);
                                    if tuple_ptr.is_null() {
                                        return MoltObject::none().bits();
                                    }
                                    list_elems.push(MoltObject::from_ptr(tuple_ptr).bits());
                                } else {
                                    let item = if other_type == TYPE_ID_DICT_KEYS_VIEW {
                                        key_bits
                                    } else {
                                        val_bits
                                    };
                                    list_elems.push(item);
                                    inc_ref_bits(_py, item);
                                }
                            }
                        }
                        return MoltObject::none().bits();
                    }
                }
                let iter_bits = molt_iter(other_bits);
                if obj_from_bits(iter_bits).is_none() {
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    return raise_not_iterable(_py, other_bits);
                }
                loop {
                    let pair_bits = molt_iter_next(iter_bits);
                    let pair_obj = obj_from_bits(pair_bits);
                    let Some(pair_ptr) = pair_obj.as_ptr() else {
                        return MoltObject::none().bits();
                    };
                    if object_type_id(pair_ptr) != TYPE_ID_TUPLE {
                        return MoltObject::none().bits();
                    }
                    let pair_elems = seq_vec_ref(pair_ptr);
                    if pair_elems.len() < 2 {
                        return MoltObject::none().bits();
                    }
                    let done_bits = pair_elems[1];
                    if is_truthy(_py, obj_from_bits(done_bits)) {
                        break;
                    }
                    let val_bits = pair_elems[0];
                    list_elems.push(val_bits);
                    inc_ref_bits(_py, val_bits);
                }
                return MoltObject::none().bits();
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_list_insert(list_bits: u64, index_bits: u64, val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let list_obj = obj_from_bits(list_bits);
        if let Some(list_ptr) = list_obj.as_ptr() {
            unsafe {
                if object_type_id(list_ptr) == TYPE_ID_LIST {
                    let len = list_len(list_ptr) as i64;
                    let mut idx = index_i64_from_obj(
                        _py,
                        index_bits,
                        "list indices must be integers or have an __index__ method",
                    );
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    if idx < 0 {
                        idx += len;
                    }
                    if idx < 0 {
                        idx = 0;
                    }
                    if idx > len {
                        idx = len;
                    }
                    let elems = seq_vec(list_ptr);
                    elems.insert(idx as usize, val_bits);
                    inc_ref_bits(_py, val_bits);
                    return MoltObject::none().bits();
                }
            }
        }
        MoltObject::none().bits()
    })
}

unsafe fn list_snapshot(_py: &PyToken<'_>, list_ptr: *mut u8) -> Vec<u64> {
    unsafe {
        let elems = seq_vec_ref(list_ptr);
        let mut out = Vec::with_capacity(elems.len());
        for &elem in elems.iter() {
            inc_ref_bits(_py, elem);
            out.push(elem);
        }
        out
    }
}

unsafe fn list_snapshot_release(_py: &PyToken<'_>, snapshot: Vec<u64>) {
    for elem in snapshot {
        dec_ref_bits(_py, elem);
    }
}

unsafe fn list_elem_at(list_ptr: *mut u8, idx: usize) -> Option<u64> {
    unsafe {
        let elems = seq_vec_ref(list_ptr);
        elems.get(idx).copied()
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_list_remove(list_bits: u64, val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let list_obj = obj_from_bits(list_bits);
        if let Some(list_ptr) = list_obj.as_ptr() {
            unsafe {
                if object_type_id(list_ptr) == TYPE_ID_LIST {
                    let snapshot = list_snapshot(_py, list_ptr);
                    let mut matched_idx = None;
                    for (idx, &elem_bits) in snapshot.iter().enumerate() {
                        let eq = match eq_bool_from_bits(_py, elem_bits, val_bits) {
                            Some(val) => val,
                            None => {
                                list_snapshot_release(_py, snapshot);
                                return MoltObject::none().bits();
                            }
                        };
                        if eq {
                            matched_idx = Some(idx);
                            break;
                        }
                    }
                    list_snapshot_release(_py, snapshot);
                    if let Some(target_idx) = matched_idx {
                        let elems = seq_vec(list_ptr);
                        if target_idx < elems.len() {
                            let removed = elems.remove(target_idx);
                            dec_ref_bits(_py, removed);
                            return MoltObject::none().bits();
                        }
                    }
                    return raise_exception::<_>(
                        _py,
                        "ValueError",
                        "list.remove(x): x not in list",
                    );
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_list_clear(list_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let list_obj = obj_from_bits(list_bits);
        if let Some(list_ptr) = list_obj.as_ptr() {
            unsafe {
                if object_type_id(list_ptr) == TYPE_ID_LIST {
                    let elems = seq_vec(list_ptr);
                    for &elem in elems.iter() {
                        dec_ref_bits(_py, elem);
                    }
                    elems.clear();
                    return MoltObject::none().bits();
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_list_init_method(list_bits: u64, iterable_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let list_obj = obj_from_bits(list_bits);
        let Some(list_ptr) = list_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "list.__init__ expects list");
        };
        unsafe {
            if object_type_id(list_ptr) != TYPE_ID_LIST {
                return raise_exception::<_>(_py, "TypeError", "list.__init__ expects list");
            }
        }
        let _ = molt_list_clear(list_bits);
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        if iterable_bits == missing_bits(_py) {
            return MoltObject::none().bits();
        }
        let _ = molt_list_extend(list_bits, iterable_bits);
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_list_copy(list_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let list_obj = obj_from_bits(list_bits);
        if let Some(list_ptr) = list_obj.as_ptr() {
            unsafe {
                if object_type_id(list_ptr) == TYPE_ID_LIST {
                    let elems = seq_vec_ref(list_ptr);
                    let out_ptr = alloc_list(_py, elems.as_slice());
                    if out_ptr.is_null() {
                        return MoltObject::none().bits();
                    }
                    return MoltObject::from_ptr(out_ptr).bits();
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_list_reverse(list_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let list_obj = obj_from_bits(list_bits);
        if let Some(list_ptr) = list_obj.as_ptr() {
            unsafe {
                if object_type_id(list_ptr) == TYPE_ID_LIST {
                    let elems = seq_vec(list_ptr);
                    elems.reverse();
                    return MoltObject::none().bits();
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_list_sort(list_bits: u64, key_bits: u64, reverse_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let list_obj = obj_from_bits(list_bits);
        if let Some(list_ptr) = list_obj.as_ptr() {
            unsafe {
                if object_type_id(list_ptr) != TYPE_ID_LIST {
                    return MoltObject::none().bits();
                }
                let use_key = !obj_from_bits(key_bits).is_none();
                let reverse = is_truthy(_py, obj_from_bits(reverse_bits));
                let elems = seq_vec_ref(list_ptr);
                let mut items: Vec<SortItem> = Vec::with_capacity(elems.len());
                for &val_bits in elems.iter() {
                    let key_val_bits = if use_key {
                        let res_bits = call_callable1(_py, key_bits, val_bits);
                        if exception_pending(_py) {
                            dec_ref_bits(_py, res_bits);
                            for item in items.drain(..) {
                                dec_ref_bits(_py, item.key_bits);
                            }
                            return MoltObject::none().bits();
                        }
                        res_bits
                    } else {
                        val_bits
                    };
                    items.push(SortItem {
                        key_bits: key_val_bits,
                        value_bits: val_bits,
                    });
                }
                let mut error: Option<SortError> = None;
                items.sort_by(|left, right| {
                    if error.is_some() {
                        return Ordering::Equal;
                    }
                    let outcome = compare_objects(
                        _py,
                        obj_from_bits(left.key_bits),
                        obj_from_bits(right.key_bits),
                    );
                    match outcome {
                        CompareOutcome::Ordered(ordering) => {
                            if reverse {
                                ordering.reverse()
                            } else {
                                ordering
                            }
                        }
                        CompareOutcome::Unordered => Ordering::Equal,
                        CompareOutcome::NotComparable => {
                            error = Some(SortError::NotComparable(left.key_bits, right.key_bits));
                            Ordering::Equal
                        }
                        CompareOutcome::Error => {
                            error = Some(SortError::Exception);
                            Ordering::Equal
                        }
                    }
                });
                if let Some(error) = error {
                    if use_key {
                        for item in items.drain(..) {
                            dec_ref_bits(_py, item.key_bits);
                        }
                    }
                    match error {
                        SortError::NotComparable(left_bits, right_bits) => {
                            let msg = format!(
                                "'<' not supported between instances of '{}' and '{}'",
                                type_name(_py, obj_from_bits(left_bits)),
                                type_name(_py, obj_from_bits(right_bits)),
                            );
                            return raise_exception::<_>(_py, "TypeError", &msg);
                        }
                        SortError::Exception => {
                            return MoltObject::none().bits();
                        }
                    }
                }
                let mut new_elems: Vec<u64> = Vec::with_capacity(items.len());
                for item in items.iter() {
                    new_elems.push(item.value_bits);
                }
                if use_key {
                    for item in items.drain(..) {
                        dec_ref_bits(_py, item.key_bits);
                    }
                }
                let elems_mut = seq_vec(list_ptr);
                *elems_mut = new_elems;
                return MoltObject::none().bits();
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_list_add_method(list_bits: u64, other_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let list_obj = obj_from_bits(list_bits);
        let Some(list_ptr) = list_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "list.__add__ expects list");
        };
        unsafe {
            if object_type_id(list_ptr) != TYPE_ID_LIST {
                return raise_exception::<_>(_py, "TypeError", "list.__add__ expects list");
            }
            let other_obj = obj_from_bits(other_bits);
            let Some(other_ptr) = other_obj.as_ptr() else {
                let msg = format!(
                    "can only concatenate list (not \"{}\") to list",
                    type_name(_py, other_obj)
                );
                return raise_exception::<_>(_py, "TypeError", &msg);
            };
            if object_type_id(other_ptr) != TYPE_ID_LIST {
                let msg = format!(
                    "can only concatenate list (not \"{}\") to list",
                    type_name(_py, other_obj)
                );
                return raise_exception::<_>(_py, "TypeError", &msg);
            }
            let l_len = list_len(list_ptr);
            let r_len = list_len(other_ptr);
            let l_elems = seq_vec_ref(list_ptr);
            let r_elems = seq_vec_ref(other_ptr);
            let mut combined = Vec::with_capacity(l_len + r_len);
            combined.extend_from_slice(l_elems);
            combined.extend_from_slice(r_elems);
            let ptr = alloc_list(_py, &combined);
            if ptr.is_null() {
                return raise_exception::<_>(_py, "MemoryError", "out of memory");
            }
            MoltObject::from_ptr(ptr).bits()
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_list_mul_method(list_bits: u64, count_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let list_obj = obj_from_bits(list_bits);
        let Some(list_ptr) = list_obj.as_ptr() else {
            return raise_exception::<_>(_py, "TypeError", "list.__mul__ expects list");
        };
        unsafe {
            if object_type_id(list_ptr) != TYPE_ID_LIST {
                return raise_exception::<_>(_py, "TypeError", "list.__mul__ expects list");
            }
        }
        let rhs_type = type_name(_py, obj_from_bits(count_bits));
        let msg = format!("can't multiply sequence by non-int of type '{rhs_type}'");
        let count = index_i64_from_obj(_py, count_bits, &msg);
        if exception_pending(_py) {
            return MoltObject::none().bits();
        }
        let Some(bits) = repeat_sequence(_py, list_ptr, count) else {
            return MoltObject::none().bits();
        };
        bits
    })
}

fn heapq_lt(_py: &PyToken<'_>, a_bits: u64, b_bits: u64) -> Option<bool> {
    let res_bits = molt_lt(a_bits, b_bits);
    if exception_pending(_py) {
        return None;
    }
    let truthy = is_truthy(_py, obj_from_bits(res_bits));
    let had_exc = exception_pending(_py);
    dec_ref_bits(_py, res_bits);
    if had_exc {
        return None;
    }
    Some(truthy)
}

unsafe fn heapq_siftdown(
    _py: &PyToken<'_>,
    heap: &mut [u64],
    startpos: usize,
    mut pos: usize,
) -> bool {
    let newitem = heap[pos];
    while pos > startpos {
        let parentpos = (pos - 1) / 2;
        let parent = heap[parentpos];
        let lt = match heapq_lt(_py, newitem, parent) {
            Some(val) => val,
            None => return false,
        };
        if lt {
            heap[pos] = parent;
            pos = parentpos;
            continue;
        }
        break;
    }
    heap[pos] = newitem;
    true
}

unsafe fn heapq_siftup(_py: &PyToken<'_>, heap: &mut [u64], mut pos: usize) -> bool {
    unsafe {
        let endpos = heap.len();
        let startpos = pos;
        let newitem = heap[pos];
        let mut childpos = 2 * pos + 1;
        while childpos < endpos {
            let rightpos = childpos + 1;
            if rightpos < endpos {
                let left_lt_right = match heapq_lt(_py, heap[childpos], heap[rightpos]) {
                    Some(val) => val,
                    None => return false,
                };
                if !left_lt_right {
                    childpos = rightpos;
                }
            }
            heap[pos] = heap[childpos];
            pos = childpos;
            childpos = 2 * pos + 1;
        }
        heap[pos] = newitem;
        heapq_siftdown(_py, heap, startpos, pos)
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_heapq_heapify(list_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let list_obj = obj_from_bits(list_bits);
        let Some(list_ptr) = list_obj.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(list_ptr) != TYPE_ID_LIST {
                return MoltObject::none().bits();
            }
            let elems = seq_vec(list_ptr);
            let len = elems.len();
            if len < 2 {
                return MoltObject::none().bits();
            }
            for idx in (0..len / 2).rev() {
                if !heapq_siftup(_py, elems, idx) {
                    return MoltObject::none().bits();
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_heapq_heappush(list_bits: u64, item_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let list_obj = obj_from_bits(list_bits);
        let Some(list_ptr) = list_obj.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(list_ptr) != TYPE_ID_LIST {
                return MoltObject::none().bits();
            }
            let elems = seq_vec(list_ptr);
            elems.push(item_bits);
            inc_ref_bits(_py, item_bits);
            let len = elems.len();
            if len > 1 && !heapq_siftdown(_py, elems, 0, len - 1) {
                return MoltObject::none().bits();
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_heapq_heappop(list_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let list_obj = obj_from_bits(list_bits);
        let Some(list_ptr) = list_obj.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(list_ptr) != TYPE_ID_LIST {
                return MoltObject::none().bits();
            }
            let elems = seq_vec(list_ptr);
            if elems.is_empty() {
                return raise_exception::<_>(_py, "IndexError", "index out of range");
            }
            let last = elems.pop().unwrap();
            if elems.is_empty() {
                inc_ref_bits(_py, last);
                dec_ref_bits(_py, last);
                return last;
            }
            let return_bits = elems[0];
            elems[0] = last;
            if !heapq_siftup(_py, elems, 0) {
                return MoltObject::none().bits();
            }
            inc_ref_bits(_py, return_bits);
            dec_ref_bits(_py, return_bits);
            return_bits
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_heapq_heapreplace(list_bits: u64, item_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let list_obj = obj_from_bits(list_bits);
        let Some(list_ptr) = list_obj.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(list_ptr) != TYPE_ID_LIST {
                return MoltObject::none().bits();
            }
            let elems = seq_vec(list_ptr);
            if elems.is_empty() {
                return raise_exception::<_>(_py, "IndexError", "index out of range");
            }
            let return_bits = elems[0];
            elems[0] = item_bits;
            inc_ref_bits(_py, item_bits);
            if !heapq_siftup(_py, elems, 0) {
                return MoltObject::none().bits();
            }
            inc_ref_bits(_py, return_bits);
            dec_ref_bits(_py, return_bits);
            return_bits
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_heapq_heappushpop(list_bits: u64, item_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let list_obj = obj_from_bits(list_bits);
        let Some(list_ptr) = list_obj.as_ptr() else {
            return MoltObject::none().bits();
        };
        unsafe {
            if object_type_id(list_ptr) != TYPE_ID_LIST {
                return MoltObject::none().bits();
            }
            let elems = seq_vec(list_ptr);
            if elems.is_empty() {
                inc_ref_bits(_py, item_bits);
                return item_bits;
            }
            let lt = match heapq_lt(_py, elems[0], item_bits) {
                Some(val) => val,
                None => return MoltObject::none().bits(),
            };
            if lt {
                let return_bits = elems[0];
                elems[0] = item_bits;
                inc_ref_bits(_py, item_bits);
                if !heapq_siftup(_py, elems, 0) {
                    return MoltObject::none().bits();
                }
                inc_ref_bits(_py, return_bits);
                dec_ref_bits(_py, return_bits);
                return return_bits;
            }
            inc_ref_bits(_py, item_bits);
            item_bits
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_list_count(list_bits: u64, val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let list_obj = obj_from_bits(list_bits);
        if let Some(ptr) = list_obj.as_ptr() {
            unsafe {
                if object_type_id(ptr) == TYPE_ID_LIST {
                    let mut count = 0i64;
                    let mut idx = 0usize;
                    loop {
                        let elem_bits = match list_elem_at(ptr, idx) {
                            Some(val) => val,
                            None => break,
                        };
                        inc_ref_bits(_py, elem_bits);
                        let eq = match eq_bool_from_bits(_py, elem_bits, val_bits) {
                            Some(val) => val,
                            None => {
                                dec_ref_bits(_py, elem_bits);
                                return MoltObject::none().bits();
                            }
                        };
                        dec_ref_bits(_py, elem_bits);
                        if eq {
                            count += 1;
                        }
                        idx += 1;
                    }
                    return MoltObject::from_int(count).bits();
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_list_index_range(
    list_bits: u64,
    val_bits: u64,
    start_bits: u64,
    stop_bits: u64,
) -> u64 {
    crate::with_gil_entry!(_py, {
        let list_obj = obj_from_bits(list_bits);
        if let Some(ptr) = list_obj.as_ptr() {
            unsafe {
                if object_type_id(ptr) == TYPE_ID_LIST {
                    let len = list_len(ptr) as i64;
                    let missing = missing_bits(_py);
                    let err = "slice indices must be integers or have an __index__ method";
                    let mut start = if start_bits == missing {
                        0
                    } else {
                        index_i64_from_obj(_py, start_bits, err)
                    };
                    let mut stop = if stop_bits == missing {
                        len
                    } else {
                        index_i64_from_obj(_py, stop_bits, err)
                    };
                    if exception_pending(_py) {
                        return MoltObject::none().bits();
                    }
                    if start < 0 {
                        start += len;
                    }
                    if stop < 0 {
                        stop += len;
                    }
                    if start < 0 {
                        start = 0;
                    }
                    if stop < 0 {
                        stop = 0;
                    }
                    if start > len {
                        start = len;
                    }
                    if stop > len {
                        stop = len;
                    }
                    if start < stop {
                        let mut idx = start;
                        while idx < stop {
                            let elem_bits = match list_elem_at(ptr, idx as usize) {
                                Some(val) => val,
                                None => break,
                            };
                            inc_ref_bits(_py, elem_bits);
                            let eq = match eq_bool_from_bits(_py, elem_bits, val_bits) {
                                Some(val) => val,
                                None => {
                                    dec_ref_bits(_py, elem_bits);
                                    return MoltObject::none().bits();
                                }
                            };
                            dec_ref_bits(_py, elem_bits);
                            if eq {
                                return MoltObject::from_int(idx).bits();
                            }
                            idx += 1;
                        }
                    }
                    return raise_exception::<_>(_py, "ValueError", "list.index(x): x not in list");
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_list_index(list_bits: u64, val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let missing = missing_bits(_py);
        molt_list_index_range(list_bits, val_bits, missing, missing)
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_tuple_count(tuple_bits: u64, val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let tuple_obj = obj_from_bits(tuple_bits);
        if let Some(ptr) = tuple_obj.as_ptr() {
            unsafe {
                if object_type_id(ptr) == TYPE_ID_TUPLE {
                    let elems = seq_vec_ref(ptr);
                    let mut count = 0i64;
                    for &elem in elems.iter() {
                        let eq = match eq_bool_from_bits(_py, elem, val_bits) {
                            Some(val) => val,
                            None => return MoltObject::none().bits(),
                        };
                        if eq {
                            count += 1;
                        }
                    }
                    return MoltObject::from_int(count).bits();
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_tuple_index(tuple_bits: u64, val_bits: u64) -> u64 {
    crate::with_gil_entry!(_py, {
        let tuple_obj = obj_from_bits(tuple_bits);
        if let Some(ptr) = tuple_obj.as_ptr() {
            unsafe {
                if object_type_id(ptr) == TYPE_ID_TUPLE {
                    let elems = seq_vec_ref(ptr);
                    for (idx, elem) in elems.iter().enumerate() {
                        let eq = match eq_bool_from_bits(_py, *elem, val_bits) {
                            Some(val) => val,
                            None => return MoltObject::none().bits(),
                        };
                        if eq {
                            return MoltObject::from_int(idx as i64).bits();
                        }
                    }
                    return MoltObject::none().bits();
                }
            }
        }
        MoltObject::none().bits()
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_print_obj(val: u64) {
    crate::with_gil_entry!(_py, {
        let args_ptr = alloc_tuple(_py, &[val]);
        if args_ptr.is_null() {
            return;
        }
        let args_bits = MoltObject::from_ptr(args_ptr).bits();
        let none_bits = MoltObject::none().bits();
        let flush_bits = MoltObject::from_bool(true).bits();
        let res_bits = molt_print_builtin(args_bits, none_bits, none_bits, none_bits, flush_bits);
        dec_ref_bits(_py, res_bits);
        dec_ref_bits(_py, args_bits);
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_print_newline() {
    crate::with_gil_entry!(_py, {
        let args_ptr = alloc_tuple(_py, &[]);
        if args_ptr.is_null() {
            return;
        }
        let args_bits = MoltObject::from_ptr(args_ptr).bits();
        let none_bits = MoltObject::none().bits();
        let flush_bits = MoltObject::from_bool(true).bits();
        let res_bits = molt_print_builtin(args_bits, none_bits, none_bits, none_bits, flush_bits);
        dec_ref_bits(_py, res_bits);
        dec_ref_bits(_py, args_bits);
    })
}

fn format_float(f: f64) -> String {
    if f.is_nan() {
        return "nan".to_string();
    }
    if f.is_infinite() {
        if f.is_sign_negative() {
            return "-inf".to_string();
        }
        return "inf".to_string();
    }
    let abs = f.abs();
    if abs != 0.0 && !(1e-4..1e16).contains(&abs) {
        return format_float_scientific(f);
    }
    if f.fract() == 0.0 {
        format!("{f:.1}")
    } else {
        f.to_string()
    }
}

fn format_float_scientific(f: f64) -> String {
    let raw = f.to_string();
    if raw.contains('e') || raw.contains('E') {
        return normalize_scientific(&raw);
    }
    let mut digits = raw.as_str();
    if let Some(rest) = digits.strip_prefix('-') {
        digits = rest;
    }
    let digits_only: String = digits.chars().filter(|ch| *ch != '.').collect();
    let sig_digits = digits_only.trim_start_matches('0').len().max(1);
    let precision = sig_digits.saturating_sub(1).min(16);
    let formatted = format!("{:.*e}", precision, f);
    normalize_scientific(&formatted)
}

fn normalize_scientific(formatted: &str) -> String {
    let normalized = formatted.to_lowercase();
    let Some(exp_pos) = normalized.find('e') else {
        return normalized;
    };
    let (mantissa, exp) = normalized.split_at(exp_pos);
    let mut mant = mantissa.to_string();
    if mant.contains('.') {
        while mant.ends_with('0') {
            mant.pop();
        }
        if mant.ends_with('.') {
            mant.pop();
        }
    }
    let exp_val: i32 = exp[1..].parse().unwrap_or(0);
    let sign = if exp_val < 0 { "-" } else { "+" };
    let exp_abs = exp_val.unsigned_abs();
    let exp_text = format!("{exp_abs:02}");
    format!("{mant}e{sign}{exp_text}")
}

fn format_complex_float(f: f64) -> String {
    let text = format_float(f);
    if let Some(stripped) = text.strip_suffix(".0") {
        stripped.to_string()
    } else {
        text
    }
}

fn format_complex(re: f64, im: f64) -> String {
    let re_zero = re == 0.0 && !re.is_sign_negative();
    let re_text = format_complex_float(re);
    if re_zero {
        let im_text = format_complex_float(im);
        return format!("{im_text}j");
    }
    let sign = if im.is_sign_negative() { "-" } else { "+" };
    let im_text = format_complex_float(im.abs());
    format!("({re_text}{sign}{im_text}j)")
}

fn format_range(start: &BigInt, stop: &BigInt, step: &BigInt) -> String {
    if step == &BigInt::from(1) {
        format!("range({start}, {stop})")
    } else {
        format!("range({start}, {stop}, {step})")
    }
}

fn format_slice(_py: &PyToken<'_>, ptr: *mut u8) -> String {
    unsafe {
        let start = format_obj(_py, obj_from_bits(slice_start_bits(ptr)));
        let stop = format_obj(_py, obj_from_bits(slice_stop_bits(ptr)));
        let step = format_obj(_py, obj_from_bits(slice_step_bits(ptr)));
        format!("slice({start}, {stop}, {step})")
    }
}

fn format_generic_alias(_py: &PyToken<'_>, ptr: *mut u8) -> String {
    unsafe {
        let origin_bits = generic_alias_origin_bits(ptr);
        let args_bits = generic_alias_args_bits(ptr);
        let origin_obj = obj_from_bits(origin_bits);
        let render_arg = |arg_bits: u64| {
            let arg_obj = obj_from_bits(arg_bits);
            if let Some(arg_ptr) = arg_obj.as_ptr() {
                if object_type_id(arg_ptr) == TYPE_ID_TYPE {
                    let name = string_obj_to_owned(obj_from_bits(class_name_bits(arg_ptr)))
                        .unwrap_or_default();
                    if !name.is_empty() {
                        return name;
                    }
                }
            }
            format_obj(_py, arg_obj)
        };
        let origin_repr = if let Some(origin_ptr) = origin_obj.as_ptr() {
            if object_type_id(origin_ptr) == TYPE_ID_TYPE {
                let name = string_obj_to_owned(obj_from_bits(class_name_bits(origin_ptr)))
                    .unwrap_or_default();
                if name.is_empty() {
                    format_obj(_py, origin_obj)
                } else {
                    name
                }
            } else {
                format_obj(_py, origin_obj)
            }
        } else {
            format_obj(_py, origin_obj)
        };
        let mut out = String::new();
        out.push_str(&origin_repr);
        out.push('[');
        let args_obj = obj_from_bits(args_bits);
        if let Some(args_ptr) = args_obj.as_ptr() {
            if object_type_id(args_ptr) == TYPE_ID_TUPLE {
                let elems = seq_vec_ref(args_ptr);
                for (idx, elem_bits) in elems.iter().enumerate() {
                    if idx > 0 {
                        out.push_str(", ");
                    }
                    out.push_str(&render_arg(*elem_bits));
                }
            } else {
                out.push_str(&render_arg(args_bits));
            }
        } else {
            out.push_str(&render_arg(args_bits));
        }
        out.push(']');
        out
    }
}

fn format_union_type(_py: &PyToken<'_>, ptr: *mut u8) -> String {
    unsafe {
        let args_bits = union_type_args_bits(ptr);
        let render_arg = |arg_bits: u64| {
            let arg_obj = obj_from_bits(arg_bits);
            if let Some(arg_ptr) = arg_obj.as_ptr() {
                if object_type_id(arg_ptr) == TYPE_ID_TYPE {
                    let name = string_obj_to_owned(obj_from_bits(class_name_bits(arg_ptr)))
                        .unwrap_or_default();
                    if !name.is_empty() {
                        return name;
                    }
                }
            }
            format_obj(_py, arg_obj)
        };
        let mut out = String::new();
        let args_obj = obj_from_bits(args_bits);
        if let Some(args_ptr) = args_obj.as_ptr() {
            if object_type_id(args_ptr) == TYPE_ID_TUPLE {
                let elems = seq_vec_ref(args_ptr);
                for (idx, elem_bits) in elems.iter().enumerate() {
                    if idx > 0 {
                        out.push_str(" | ");
                    }
                    out.push_str(&render_arg(*elem_bits));
                }
                return out;
            }
        }
        out.push_str(&render_arg(args_bits));
        out
    }
}

pub(crate) fn string_obj_to_owned(obj: MoltObject) -> Option<String> {
    let ptr = obj.as_ptr()?;
    unsafe {
        if object_type_id(ptr) != TYPE_ID_STRING {
            return None;
        }
        let len = string_len(ptr);
        let bytes = std::slice::from_raw_parts(string_bytes(ptr), len);
        Some(String::from_utf8_lossy(bytes).to_string())
    }
}

pub(crate) fn decode_string_list(obj: MoltObject) -> Option<Vec<String>> {
    let ptr = obj.as_ptr()?;
    unsafe {
        let type_id = object_type_id(ptr);
        if type_id != TYPE_ID_LIST && type_id != TYPE_ID_TUPLE {
            return None;
        }
        let elems = seq_vec_ref(ptr);
        let mut out = Vec::with_capacity(elems.len());
        for &elem_bits in elems.iter() {
            let elem_obj = obj_from_bits(elem_bits);
            let s = string_obj_to_owned(elem_obj)?;
            out.push(s);
        }
        Some(out)
    }
}

pub(crate) fn decode_value_list(obj: MoltObject) -> Option<Vec<u64>> {
    let ptr = obj.as_ptr()?;
    unsafe {
        let type_id = object_type_id(ptr);
        if type_id != TYPE_ID_LIST && type_id != TYPE_ID_TUPLE {
            return None;
        }
        let elems = seq_vec_ref(ptr);
        Some(elems.to_vec())
    }
}

fn format_dataclass(_py: &PyToken<'_>, ptr: *mut u8) -> String {
    unsafe {
        let desc_ptr = dataclass_desc_ptr(ptr);
        if desc_ptr.is_null() {
            return "<dataclass>".to_string();
        }
        let desc = &*desc_ptr;
        let fields = dataclass_fields_ref(ptr);
        let mut out = String::new();
        out.push_str(&desc.name);
        out.push('(');
        let mut first = true;
        for (idx, name) in desc.field_names.iter().enumerate() {
            let flag = desc.field_flags.get(idx).copied().unwrap_or(0x7);
            if (flag & 0x1) == 0 {
                continue;
            }
            if !first {
                out.push_str(", ");
            }
            first = false;
            out.push_str(name);
            out.push('=');
            let val = fields
                .get(idx)
                .copied()
                .unwrap_or(MoltObject::none().bits());
            if is_missing_bits(_py, val) {
                let type_label = if desc.name.is_empty() {
                    "dataclass"
                } else {
                    desc.name.as_str()
                };
                let _ = attr_error(_py, type_label, name);
                return "<dataclass>".to_string();
            }
            out.push_str(&format_obj(_py, obj_from_bits(val)));
        }
        out.push(')');
        out
    }
}

struct ReprGuard {
    ptr: *mut u8,
    active: bool,
    depth_active: bool,
}

impl ReprGuard {
    fn new(_py: &PyToken<'_>, ptr: *mut u8) -> Self {
        if !repr_depth_enter() {
            let _ = raise_exception::<u64>(
                _py,
                "RecursionError",
                "maximum recursion depth exceeded while getting the repr of an object",
            );
            return Self {
                ptr,
                active: false,
                depth_active: false,
            };
        }
        let active = REPR_STACK.with(|stack| {
            let mut stack = stack.borrow_mut();
            if stack.iter().any(|slot| slot.0 == ptr) {
                return false;
            }
            stack.push(PtrSlot(ptr));
            true
        });
        if !active {
            repr_depth_exit();
        }
        Self {
            ptr,
            active,
            depth_active: active,
        }
    }

    fn active(&self) -> bool {
        self.active
    }
}

impl Drop for ReprGuard {
    fn drop(&mut self) {
        if self.active {
            REPR_STACK.with(|stack| {
                let mut stack = stack.borrow_mut();
                if let Some(pos) = stack.iter().rposition(|slot| slot.0 == self.ptr) {
                    stack.remove(pos);
                }
            });
        }
        if self.depth_active {
            repr_depth_exit();
        }
    }
}

fn repr_depth_enter() -> bool {
    let limit = recursion_limit_get();
    REPR_DEPTH.with(|depth| {
        let current = depth.get();
        if current + 1 > limit {
            false
        } else {
            depth.set(current + 1);
            true
        }
    })
}

fn repr_depth_exit() {
    REPR_DEPTH.with(|depth| {
        let current = depth.get();
        if current > 0 {
            depth.set(current - 1);
        }
    });
}

fn format_default_object_repr(_py: &PyToken<'_>, ptr: *mut u8) -> String {
    let class_bits = unsafe {
        if object_type_id(ptr) == TYPE_ID_OBJECT || object_type_id(ptr) == TYPE_ID_DATACLASS {
            object_class_bits(ptr)
        } else {
            type_of_bits(_py, MoltObject::from_ptr(ptr).bits())
        }
    };
    let class_name = class_name_for_error(class_bits);
    format!("<{class_name} object at 0x{:x}>", ptr as usize)
}

fn call_bits_is_default_object_repr(call_bits: u64) -> bool {
    let call_obj = obj_from_bits(call_bits);
    let Some(mut call_ptr) = call_obj.as_ptr() else {
        return false;
    };
    unsafe {
        if object_type_id(call_ptr) == TYPE_ID_BOUND_METHOD {
            let func_bits = bound_method_func_bits(call_ptr);
            let Some(func_ptr) = obj_from_bits(func_bits).as_ptr() else {
                return false;
            };
            call_ptr = func_ptr;
        }
        object_type_id(call_ptr) == TYPE_ID_FUNCTION
            && function_fn_ptr(call_ptr) == fn_addr!(molt_repr_from_obj)
    }
}

fn call_bits_is_default_object_str(call_bits: u64) -> bool {
    let call_obj = obj_from_bits(call_bits);
    let Some(mut call_ptr) = call_obj.as_ptr() else {
        return false;
    };
    unsafe {
        if object_type_id(call_ptr) == TYPE_ID_BOUND_METHOD {
            let func_bits = bound_method_func_bits(call_ptr);
            let Some(func_ptr) = obj_from_bits(func_bits).as_ptr() else {
                return false;
            };
            call_ptr = func_ptr;
        }
        object_type_id(call_ptr) == TYPE_ID_FUNCTION
            && function_fn_ptr(call_ptr) == fn_addr!(molt_str_from_obj)
    }
}

pub(crate) fn format_obj_str(_py: &PyToken<'_>, obj: MoltObject) -> String {
    if let Some(ptr) = maybe_ptr_from_bits(obj.bits()) {
        unsafe {
            let type_id = object_type_id(ptr);
            if type_id == TYPE_ID_TYPE {
                return format_obj(_py, obj);
            }
            if type_id == TYPE_ID_STRING {
                let len = string_len(ptr);
                let bytes = std::slice::from_raw_parts(string_bytes(ptr), len);
                return String::from_utf8_lossy(bytes).into_owned();
            }
            if type_id == TYPE_ID_EXCEPTION {
                return format_exception_message(_py, ptr);
            }
            let str_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.str_name, b"__str__");
            if let Some(call_bits) = attr_lookup_ptr_allow_missing(_py, ptr, str_name_bits) {
                if call_bits_is_default_object_str(call_bits) {
                    dec_ref_bits(_py, call_bits);
                    // CPython's default object.__str__ delegates to __repr__;
                    // preserve that path so custom __repr__ methods render correctly.
                    return format_obj(_py, obj);
                }
                if call_bits_is_default_object_repr(call_bits) {
                    dec_ref_bits(_py, call_bits);
                    // object.__str__ delegates to repr; use format_obj so custom
                    // __repr__ overrides participate instead of forcing default
                    // pointer-style formatting.
                    return format_obj(_py, obj);
                }
                let res_bits = call_callable0(_py, call_bits);
                dec_ref_bits(_py, call_bits);
                let res_obj = obj_from_bits(res_bits);
                if let Some(rendered) = string_obj_to_owned(res_obj) {
                    dec_ref_bits(_py, res_bits);
                    return rendered;
                }
                dec_ref_bits(_py, res_bits);
            }
            if exception_pending(_py) {
                return "<object>".to_string();
            }
        }
    }
    format_obj(_py, obj)
}

pub(crate) fn format_obj(_py: &PyToken<'_>, obj: MoltObject) -> String {
    if let Some(b) = obj.as_bool() {
        return if b {
            "True".to_string()
        } else {
            "False".to_string()
        };
    }
    if let Some(i) = obj.as_int() {
        return i.to_string();
    }
    if let Some(f) = obj.as_float() {
        return format_float(f);
    }
    if obj.is_none() {
        return "None".to_string();
    }
    if obj.is_pending() {
        return "<pending>".to_string();
    }
    if obj.bits() == ellipsis_bits(_py) {
        return "Ellipsis".to_string();
    }
    if let Some(ptr) = maybe_ptr_from_bits(obj.bits()) {
        unsafe {
            let type_id = object_type_id(ptr);
            if type_id == TYPE_ID_STRING {
                let len = string_len(ptr);
                let bytes = std::slice::from_raw_parts(string_bytes(ptr), len);
                return format_string_repr_bytes(bytes);
            }
            if type_id == TYPE_ID_BIGINT {
                return bigint_ref(ptr).to_string();
            }
            if type_id == TYPE_ID_COMPLEX {
                let value = *complex_ref(ptr);
                return format_complex(value.re, value.im);
            }
            if type_id == TYPE_ID_BYTES {
                let len = bytes_len(ptr);
                let bytes = std::slice::from_raw_parts(bytes_data(ptr), len);
                return format_bytes(bytes);
            }
            if type_id == TYPE_ID_BYTEARRAY {
                let len = bytes_len(ptr);
                let bytes = std::slice::from_raw_parts(bytes_data(ptr), len);
                return format!("bytearray({})", format_bytes(bytes));
            }
            if type_id == TYPE_ID_RANGE {
                if let Some((start, stop, step)) = range_components_bigint(ptr) {
                    return format_range(&start, &stop, &step);
                }
                return "range(?)".to_string();
            }
            if type_id == TYPE_ID_SLICE {
                return format_slice(_py, ptr);
            }
            if type_id == TYPE_ID_GENERIC_ALIAS {
                let guard = ReprGuard::new(_py, ptr);
                if !guard.active() {
                    return "...".to_string();
                }
                return format_generic_alias(_py, ptr);
            }
            if type_id == TYPE_ID_UNION {
                let guard = ReprGuard::new(_py, ptr);
                if !guard.active() {
                    return "...".to_string();
                }
                return format_union_type(_py, ptr);
            }
            if type_id == TYPE_ID_NOT_IMPLEMENTED {
                return "NotImplemented".to_string();
            }
            if type_id == TYPE_ID_ELLIPSIS {
                return "Ellipsis".to_string();
            }
            if type_id == TYPE_ID_EXCEPTION {
                return format_exception(_py, ptr);
            }
            if type_id == TYPE_ID_CONTEXT_MANAGER {
                return "<context_manager>".to_string();
            }
            if type_id == TYPE_ID_FILE_HANDLE {
                return "<file_handle>".to_string();
            }
            if type_id == TYPE_ID_FUNCTION {
                return "<function>".to_string();
            }
            if type_id == TYPE_ID_CODE {
                let name =
                    string_obj_to_owned(obj_from_bits(code_name_bits(ptr))).unwrap_or_default();
                if name.is_empty() {
                    return "<code>".to_string();
                }
                return format!("<code {name}>");
            }
            if type_id == TYPE_ID_BOUND_METHOD {
                return "<bound_method>".to_string();
            }
            if type_id == TYPE_ID_GENERATOR {
                return "<generator>".to_string();
            }
            if type_id == TYPE_ID_ASYNC_GENERATOR {
                return "<async_generator>".to_string();
            }
            if type_id == TYPE_ID_MODULE {
                let name =
                    string_obj_to_owned(obj_from_bits(module_name_bits(ptr))).unwrap_or_default();
                if name.is_empty() {
                    return "<module>".to_string();
                }
                return format!("<module '{name}'>");
            }
            if type_id == TYPE_ID_TYPE {
                let name =
                    string_obj_to_owned(obj_from_bits(class_name_bits(ptr))).unwrap_or_default();
                if name.is_empty() {
                    return "<type>".to_string();
                }
                let mut qualname = name.clone();
                let mut module_name: Option<String> = None;
                if !exception_pending(_py) {
                    let dict_bits = class_dict_bits(ptr);
                    if let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() {
                        if object_type_id(dict_ptr) == TYPE_ID_DICT {
                            if let Some(module_key) = attr_name_bits_from_bytes(_py, b"__module__")
                            {
                                if let Some(bits) = dict_get_in_place(_py, dict_ptr, module_key) {
                                    if let Some(val) = string_obj_to_owned(obj_from_bits(bits)) {
                                        module_name = Some(val);
                                    }
                                }
                            }
                            if let Some(qual_key) = attr_name_bits_from_bytes(_py, b"__qualname__")
                            {
                                if let Some(bits) = dict_get_in_place(_py, dict_ptr, qual_key) {
                                    if let Some(val) = string_obj_to_owned(obj_from_bits(bits)) {
                                        qualname = val;
                                    }
                                }
                            }
                        }
                    }
                }
                if let Some(module) = module_name {
                    if !module.is_empty() && module != "builtins" {
                        return format!("<class '{module}.{qualname}'>");
                    }
                }
                return format!("<class '{qualname}'>");
            }
            if type_id == TYPE_ID_CLASSMETHOD {
                return "<classmethod>".to_string();
            }
            if type_id == TYPE_ID_STATICMETHOD {
                return "<staticmethod>".to_string();
            }
            if type_id == TYPE_ID_PROPERTY {
                return "<property>".to_string();
            }
            if type_id == TYPE_ID_SUPER {
                return "<super>".to_string();
            }
            if type_id == TYPE_ID_DATACLASS {
                let desc_ptr = dataclass_desc_ptr(ptr);
                if !desc_ptr.is_null() && (*desc_ptr).repr {
                    return format_dataclass(_py, ptr);
                }
            }
            if type_id == TYPE_ID_BUFFER2D {
                let buf_ptr = buffer2d_ptr(ptr);
                if buf_ptr.is_null() {
                    return "<buffer2d>".to_string();
                }
                let buf = &*buf_ptr;
                return format!("<buffer2d {}x{}>", buf.rows, buf.cols);
            }
            if type_id == TYPE_ID_MEMORYVIEW {
                let len = memoryview_len(ptr);
                let stride = memoryview_stride(ptr);
                let readonly = memoryview_readonly(ptr);
                return format!("<memoryview len={len} stride={stride} readonly={readonly}>");
            }
            if type_id == TYPE_ID_INTARRAY {
                let elems = intarray_slice(ptr);
                let mut out = String::from("intarray([");
                for (idx, val) in elems.iter().enumerate() {
                    if idx > 0 {
                        out.push_str(", ");
                    }
                    out.push_str(&val.to_string());
                }
                out.push_str("])");
                return out;
            }
            if type_id == TYPE_ID_LIST {
                let guard = ReprGuard::new(_py, ptr);
                if !guard.active() {
                    return "[...]".to_string();
                }
                let elems = seq_vec_ref(ptr);
                let mut out = String::from("[");
                for (idx, elem) in elems.iter().enumerate() {
                    if idx > 0 {
                        out.push_str(", ");
                    }
                    out.push_str(&format_obj(_py, obj_from_bits(*elem)));
                }
                out.push(']');
                return out;
            }
            if type_id == TYPE_ID_TUPLE {
                let elems = seq_vec_ref(ptr);
                let mut out = String::from("(");
                for (idx, elem) in elems.iter().enumerate() {
                    if idx > 0 {
                        out.push_str(", ");
                    }
                    out.push_str(&format_obj(_py, obj_from_bits(*elem)));
                }
                if elems.len() == 1 {
                    out.push(',');
                }
                out.push(')');
                return out;
            }
            if type_id == TYPE_ID_DICT {
                let guard = ReprGuard::new(_py, ptr);
                if !guard.active() {
                    return "{...}".to_string();
                }
                let pairs = dict_order(ptr);
                let mut out = String::from("{");
                let mut idx = 0;
                let mut first = true;
                while idx + 1 < pairs.len() {
                    if !first {
                        out.push_str(", ");
                    }
                    first = false;
                    out.push_str(&format_obj(_py, obj_from_bits(pairs[idx])));
                    out.push_str(": ");
                    out.push_str(&format_obj(_py, obj_from_bits(pairs[idx + 1])));
                    idx += 2;
                }
                out.push('}');
                return out;
            }
            if type_id == TYPE_ID_SET {
                let guard = ReprGuard::new(_py, ptr);
                if !guard.active() {
                    return "{...}".to_string();
                }
                let order = set_order(ptr);
                if order.is_empty() {
                    return "set()".to_string();
                }
                let table = set_table(ptr);
                let mut out = String::from("{");
                let mut first = true;
                for &entry in table.iter() {
                    if entry == 0 {
                        continue;
                    }
                    if !first {
                        out.push_str(", ");
                    }
                    first = false;
                    let elem = order[entry - 1];
                    out.push_str(&format_obj(_py, obj_from_bits(elem)));
                }
                out.push('}');
                return out;
            }
            if type_id == TYPE_ID_FROZENSET {
                let guard = ReprGuard::new(_py, ptr);
                if !guard.active() {
                    return "frozenset({...})".to_string();
                }
                let order = set_order(ptr);
                if order.is_empty() {
                    return "frozenset()".to_string();
                }
                let table = set_table(ptr);
                let mut out = String::from("frozenset({");
                let mut first = true;
                for &entry in table.iter() {
                    if entry == 0 {
                        continue;
                    }
                    if !first {
                        out.push_str(", ");
                    }
                    first = false;
                    let elem = order[entry - 1];
                    out.push_str(&format_obj(_py, obj_from_bits(elem)));
                }
                out.push_str("})");
                return out;
            }
            if type_id == TYPE_ID_DICT_KEYS_VIEW
                || type_id == TYPE_ID_DICT_VALUES_VIEW
                || type_id == TYPE_ID_DICT_ITEMS_VIEW
            {
                let dict_bits = dict_view_dict_bits(ptr);
                let dict_obj = obj_from_bits(dict_bits);
                if let Some(dict_ptr) = dict_obj.as_ptr() {
                    if object_type_id(dict_ptr) == TYPE_ID_DICT {
                        let pairs = dict_order(dict_ptr);
                        let mut out = if type_id == TYPE_ID_DICT_KEYS_VIEW {
                            String::from("dict_keys([")
                        } else if type_id == TYPE_ID_DICT_VALUES_VIEW {
                            String::from("dict_values([")
                        } else {
                            String::from("dict_items([")
                        };
                        let mut idx = 0;
                        let mut first = true;
                        while idx + 1 < pairs.len() {
                            if !first {
                                out.push_str(", ");
                            }
                            first = false;
                            if type_id == TYPE_ID_DICT_ITEMS_VIEW {
                                out.push('(');
                                out.push_str(&format_obj(_py, obj_from_bits(pairs[idx])));
                                out.push_str(", ");
                                out.push_str(&format_obj(_py, obj_from_bits(pairs[idx + 1])));
                                out.push(')');
                            } else {
                                let val = if type_id == TYPE_ID_DICT_KEYS_VIEW {
                                    pairs[idx]
                                } else {
                                    pairs[idx + 1]
                                };
                                out.push_str(&format_obj(_py, obj_from_bits(val)));
                            }
                            idx += 2;
                        }
                        out.push_str("])");
                        return out;
                    }
                }
            }
            if type_id == TYPE_ID_ITER {
                return "<iter>".to_string();
            }
            let repr_name_bits =
                intern_static_name(_py, &runtime_state(_py).interned.repr_name, b"__repr__");
            if let Some(call_bits) = attr_lookup_ptr_allow_missing(_py, ptr, repr_name_bits) {
                if call_bits_is_default_object_repr(call_bits) {
                    dec_ref_bits(_py, call_bits);
                    return format_default_object_repr(_py, ptr);
                }
                let res_bits = call_callable0(_py, call_bits);
                dec_ref_bits(_py, call_bits);
                let res_obj = obj_from_bits(res_bits);
                if let Some(rendered) = string_obj_to_owned(res_obj) {
                    dec_ref_bits(_py, res_bits);
                    return rendered;
                }
                dec_ref_bits(_py, res_bits);
                return "<object>".to_string();
            }
            if exception_pending(_py) {
                return "<object>".to_string();
            }
        }
    }
    "<object>".to_string()
}

fn format_bytes(bytes: &[u8]) -> String {
    let mut out = String::from("b'");
    for &b in bytes {
        match b {
            b'\\' => out.push_str("\\\\"),
            b'\'' => out.push_str("\\'"),
            b'\n' => out.push_str("\\n"),
            b'\r' => out.push_str("\\r"),
            b'\t' => out.push_str("\\t"),
            0x20..=0x7e => out.push(b as char),
            _ => out.push_str(&format!("\\x{:02x}", b)),
        }
    }
    out.push('\'');
    out
}

fn format_string_repr_bytes(bytes: &[u8]) -> String {
    let use_double = bytes.contains(&b'\'') && !bytes.contains(&b'"');
    let quote = if use_double { '"' } else { '\'' };
    let mut out = String::new();
    out.push(quote);
    for cp in wtf8_from_bytes(bytes).code_points() {
        let code = cp.to_u32();
        match code {
            0x5C => out.push_str("\\\\"),
            0x0A => out.push_str("\\n"),
            0x0D => out.push_str("\\r"),
            0x09 => out.push_str("\\t"),
            0x2028 => out.push_str("\\u2028"),
            0x2029 => out.push_str("\\u2029"),
            _ if code == quote as u32 => {
                out.push('\\');
                out.push(quote);
            }
            _ if is_surrogate(code) => {
                out.push_str(&format!("\\u{code:04x}"));
            }
            _ => {
                let ch = char::from_u32(code).unwrap_or('\u{FFFD}');
                if ch.is_control() {
                    out.push_str(&unicode_escape(ch));
                } else {
                    out.push(ch);
                }
            }
        }
    }
    out.push(quote);
    out
}

#[allow(dead_code)]
fn format_string_repr(s: &str) -> String {
    let use_double = s.contains('\'') && !s.contains('"');
    let quote = if use_double { '"' } else { '\'' };
    let mut out = String::new();
    out.push(quote);
    for ch in s.chars() {
        match ch {
            '\\' => out.push_str("\\\\"),
            '\n' => out.push_str("\\n"),
            '\r' => out.push_str("\\r"),
            '\t' => out.push_str("\\t"),
            '\u{2028}' => out.push_str("\\u2028"),
            '\u{2029}' => out.push_str("\\u2029"),
            c if c == quote => {
                out.push('\\');
                out.push(c);
            }
            c if c.is_control() => {
                let code = c as u32;
                if code <= 0xff {
                    out.push_str(&format!("\\x{:02x}", code));
                } else if code <= 0xffff {
                    out.push_str(&format!("\\u{:04x}", code));
                } else {
                    out.push_str(&format!("\\U{:08x}", code));
                }
            }
            _ => out.push(ch),
        }
    }
    out.push(quote);
    out
}

struct FormatSpec {
    fill: char,
    align: Option<char>,
    sign: Option<char>,
    alternate: bool,
    width: Option<usize>,
    grouping: Option<char>,
    precision: Option<usize>,
    ty: Option<char>,
}

type FormatError = (&'static str, Cow<'static, str>);

fn parse_format_spec(spec: &str) -> Result<FormatSpec, &'static str> {
    if spec.is_empty() {
        return Ok(FormatSpec {
            fill: ' ',
            align: None,
            sign: None,
            alternate: false,
            width: None,
            grouping: None,
            precision: None,
            ty: None,
        });
    }
    let mut chars = spec.chars().peekable();
    let mut fill = ' ';
    let mut align = None;
    let mut sign = None;
    let mut alternate = false;
    let mut grouping = None;
    let mut peeked = chars.clone();
    let first = peeked.next();
    let second = peeked.next();
    if let (Some(c1), Some(c2)) = (first, second) {
        if matches!(c2, '<' | '>' | '^' | '=') {
            fill = c1;
            align = Some(c2);
            chars.next();
            chars.next();
        } else if matches!(c1, '<' | '>' | '^' | '=') {
            align = Some(c1);
            chars.next();
        }
    } else if let Some(c1) = first {
        if matches!(c1, '<' | '>' | '^' | '=') {
            align = Some(c1);
            chars.next();
        }
    }

    if let Some(ch) = chars.peek().copied() {
        if matches!(ch, '+' | '-' | ' ') {
            sign = Some(ch);
            chars.next();
        }
    }

    if matches!(chars.peek(), Some('#')) {
        alternate = true;
        chars.next();
    }

    if align.is_none() && matches!(chars.peek(), Some('0')) {
        fill = '0';
        align = Some('=');
        chars.next();
    }

    let mut width_text = String::new();
    while let Some(ch) = chars.peek().copied() {
        if ch.is_ascii_digit() {
            width_text.push(ch);
            chars.next();
        } else {
            break;
        }
    }
    let width = if width_text.is_empty() {
        None
    } else {
        Some(
            width_text
                .parse::<usize>()
                .map_err(|_| "Invalid format width")?,
        )
    };

    if let Some(ch) = chars.peek().copied() {
        if ch == ',' || ch == '_' {
            grouping = Some(ch);
            chars.next();
        }
    }

    let mut precision = None;
    if matches!(chars.peek(), Some('.')) {
        chars.next();
        let mut prec_text = String::new();
        while let Some(ch) = chars.peek().copied() {
            if ch.is_ascii_digit() {
                prec_text.push(ch);
                chars.next();
            } else {
                break;
            }
        }
        if prec_text.is_empty() {
            return Err("Invalid format precision");
        }
        precision = Some(
            prec_text
                .parse::<usize>()
                .map_err(|_| "Invalid format precision")?,
        );
    }

    let remaining: String = chars.collect();
    if remaining.len() > 1 {
        return Err("Invalid format spec");
    }
    let ty = if remaining.is_empty() {
        None
    } else {
        Some(remaining.chars().next().unwrap())
    };

    Ok(FormatSpec {
        fill,
        align,
        sign,
        alternate,
        width,
        grouping,
        precision,
        ty,
    })
}

fn apply_grouping(text: &str, group: usize, sep: char) -> String {
    let mut out = String::with_capacity(text.len() + text.len() / group);
    for (count, ch) in text.chars().rev().enumerate() {
        if count > 0 && count.is_multiple_of(group) {
            out.push(sep);
        }
        out.push(ch);
    }
    out.chars().rev().collect()
}

fn apply_alignment(prefix: &str, body: &str, spec: &FormatSpec, default_align: char) -> String {
    let text = format!("{prefix}{body}");
    let width = match spec.width {
        Some(val) => val,
        None => return text,
    };
    let len = text.chars().count();
    if len >= width {
        return text;
    }
    let pad_len = width - len;
    let align = spec.align.unwrap_or(default_align);
    let fill = spec.fill;
    if align == '=' {
        let padding = fill.to_string().repeat(pad_len);
        return format!("{prefix}{padding}{body}");
    }
    let padding = fill.to_string().repeat(pad_len);
    match align {
        '<' => format!("{text}{padding}"),
        '>' => format!("{padding}{text}"),
        '^' => {
            let left = pad_len / 2;
            let right = pad_len - left;
            format!(
                "{}{}{}",
                fill.to_string().repeat(left),
                text,
                fill.to_string().repeat(right)
            )
        }
        _ => text,
    }
}

fn trim_float_trailing(text: &str, alternate: bool) -> String {
    if alternate {
        return text.to_string();
    }
    let exp_pos = text.find(['e', 'E']).unwrap_or(text.len());
    let (mantissa, exp) = text.split_at(exp_pos);
    let mut end = mantissa.len();
    if let Some(dot) = mantissa.find('.') {
        let bytes = mantissa.as_bytes();
        while end > dot + 1 && bytes[end - 1] == b'0' {
            end -= 1;
        }
        if end == dot + 1 {
            end = dot;
        }
    }
    let trimmed = &mantissa[..end];
    format!("{trimmed}{exp}")
}

fn normalize_exponent(text: &str, upper: bool) -> String {
    let (exp_pos, exp_char) = if let Some(pos) = text.find('e') {
        (pos, 'e')
    } else if let Some(pos) = text.find('E') {
        (pos, 'E')
    } else {
        return text.to_string();
    };
    let (mantissa, exp) = text.split_at(exp_pos);
    let mut exp_text = &exp[1..];
    let mut sign = '+';
    if let Some(first) = exp_text.chars().next() {
        if first == '+' || first == '-' {
            sign = first;
            exp_text = &exp_text[1..];
        }
    }
    let digits = if exp_text.is_empty() { "0" } else { exp_text };
    let mut padded = String::from(digits);
    if padded.len() == 1 {
        padded.insert(0, '0');
    }
    let exp_out = if upper { 'E' } else { exp_char };
    format!("{mantissa}{exp_out}{sign}{padded}")
}

fn format_string_with_spec(text: String, spec: &FormatSpec) -> String {
    let mut out = text;
    if let Some(prec) = spec.precision {
        out = out.chars().take(prec).collect();
    }
    apply_alignment("", &out, spec, '<')
}

fn format_int_with_spec(obj: MoltObject, spec: &FormatSpec) -> Result<String, FormatError> {
    if spec.precision.is_some() {
        return Err((
            "ValueError",
            Cow::Borrowed("precision not allowed in integer format"),
        ));
    }
    let ty = spec.ty.unwrap_or('d');
    let mut value = if let Some(i) = obj.as_int() {
        BigInt::from(i)
    } else if let Some(b) = obj.as_bool() {
        BigInt::from(if b { 1 } else { 0 })
    } else if let Some(ptr) = bigint_ptr_from_bits(obj.bits()) {
        unsafe { bigint_ref(ptr).clone() }
    } else {
        return Err(("TypeError", Cow::Borrowed("format requires int")));
    };
    if ty == 'c' {
        if value.is_negative() {
            return Err((
                "ValueError",
                Cow::Borrowed("format c requires non-negative int"),
            ));
        }
        let code = value
            .to_u32()
            .ok_or(("ValueError", Cow::Borrowed("format c out of range")))?;
        let ch = std::char::from_u32(code)
            .ok_or(("ValueError", Cow::Borrowed("format c out of range")))?;
        return Ok(format_string_with_spec(ch.to_string(), spec));
    }
    let base = match ty {
        'b' => 2,
        'o' => 8,
        'x' | 'X' => 16,
        'd' | 'n' => 10,
        _ => return Err(("ValueError", Cow::Borrowed("unsupported int format type"))),
    };
    let negative = value.is_negative();
    if negative {
        value = -value;
    }
    let mut digits = value.to_str_radix(base);
    if ty == 'X' {
        digits = digits.to_uppercase();
    }
    if let Some(sep) = spec.grouping {
        let group = match base {
            2 | 16 => 4,
            8 => 3,
            _ => 3,
        };
        digits = apply_grouping(&digits, group, sep);
    }
    let mut prefix = String::new();
    if negative {
        prefix.push('-');
    } else if let Some(sign) = spec.sign {
        if sign == '+' || sign == ' ' {
            prefix.push(sign);
        }
    }
    if spec.alternate {
        match ty {
            'b' => prefix.push_str("0b"),
            'o' => prefix.push_str("0o"),
            'x' => prefix.push_str("0x"),
            'X' => prefix.push_str("0X"),
            _ => {}
        }
    }
    Ok(apply_alignment(&prefix, &digits, spec, '>'))
}

fn format_float_with_spec(obj: MoltObject, spec: &FormatSpec) -> Result<String, FormatError> {
    let val = if let Some(f) = obj.as_float() {
        f
    } else if let Some(i) = obj.as_int() {
        i as f64
    } else if let Some(b) = obj.as_bool() {
        if b { 1.0 } else { 0.0 }
    } else {
        return Err(("TypeError", Cow::Borrowed("format requires float")));
    };
    let use_default = spec.ty.is_none() && spec.precision.is_none();
    let ty = spec.ty.unwrap_or('g');
    let upper = matches!(ty, 'F' | 'E' | 'G');
    if val.is_nan() {
        let text = if upper { "NAN" } else { "nan" };
        let prefix = if val.is_sign_negative() { "-" } else { "" };
        return Ok(apply_alignment(prefix, text, spec, '>'));
    }
    if val.is_infinite() {
        let text = if upper { "INF" } else { "inf" };
        let prefix = if val.is_sign_negative() { "-" } else { "" };
        return Ok(apply_alignment(prefix, text, spec, '>'));
    }
    let mut prefix = String::new();
    if val.is_sign_negative() {
        prefix.push('-');
    } else if let Some(sign) = spec.sign {
        if sign == '+' || sign == ' ' {
            prefix.push(sign);
        }
    }
    let abs_val = val.abs();
    let prec = spec.precision.unwrap_or(6);
    let mut body = if use_default {
        format_float(abs_val)
    } else {
        match ty {
            'f' | 'F' => format!("{:.*}", prec, abs_val),
            'e' | 'E' => format!("{:.*e}", prec, abs_val),
            'g' | 'G' => {
                let digits = if prec == 0 { 1 } else { prec };
                if abs_val == 0.0 {
                    "0".to_string()
                } else {
                    let exp = abs_val.log10().floor() as i32;
                    if exp < -4 || exp >= digits as i32 {
                        let text = format!("{:.*e}", digits - 1, abs_val);
                        trim_float_trailing(&text, spec.alternate)
                    } else {
                        let frac = (digits as i32 - 1 - exp).max(0) as usize;
                        let text = format!("{:.*}", frac, abs_val);
                        trim_float_trailing(&text, spec.alternate)
                    }
                }
            }
            '%' => {
                let scaled = abs_val * 100.0;
                format!("{:.*}", prec, scaled)
            }
            _ => return Err(("ValueError", Cow::Borrowed("unsupported float format type"))),
        }
    };
    body = normalize_exponent(&body, upper);
    if upper {
        body = body.replace('e', "E");
    }
    if spec.alternate && !body.contains('.') && !body.contains('E') && !body.contains('e') {
        body.push('.');
    }
    if let Some(sep) = spec.grouping {
        if !body.contains('e') && !body.contains('E') {
            let mut parts = body.splitn(2, '.');
            let int_part = parts.next().unwrap_or("");
            let frac_part = parts.next();
            let grouped = apply_grouping(int_part, 3, sep);
            body = if let Some(frac) = frac_part {
                format!("{grouped}.{frac}")
            } else {
                grouped
            };
        }
    }
    if ty == '%' {
        body.push('%');
    }
    Ok(apply_alignment(&prefix, &body, spec, '>'))
}

fn apply_grouping_to_float_text(text: &str, sep: char) -> String {
    if text.contains('e') || text.contains('E') {
        return text.to_string();
    }
    let mut parts = text.splitn(2, '.');
    let int_part = parts.next().unwrap_or("");
    let frac_part = parts.next();
    let grouped = apply_grouping(int_part, 3, sep);
    if let Some(frac) = frac_part {
        format!("{grouped}.{frac}")
    } else {
        grouped
    }
}

fn format_complex_with_spec(
    _py: &PyToken<'_>,
    value: ComplexParts,
    spec: &FormatSpec,
) -> Result<String, FormatError> {
    let mut ty = spec.ty;
    let mut grouping = spec.grouping;
    if ty == Some('n') {
        if let Some(sep) = grouping {
            let msg = if sep == ',' {
                "Cannot specify ',' with 'n'."
            } else {
                "Cannot specify '_' with 'n'."
            };
            return Err(("ValueError", Cow::Borrowed(msg)));
        }
        ty = Some('g');
        grouping = None;
    }
    if let Some(code) = ty {
        if !matches!(code, 'e' | 'E' | 'f' | 'F' | 'g' | 'G') {
            let msg = format!("Unknown format code '{code}' for object of type 'complex'");
            return Err(("ValueError", Cow::Owned(msg)));
        }
    }
    if spec.fill == '0' {
        return Err((
            "ValueError",
            Cow::Borrowed("Zero padding is not allowed in complex format specifier"),
        ));
    }
    if spec.align == Some('=') {
        return Err((
            "ValueError",
            Cow::Borrowed("'=' alignment flag is not allowed in complex format specifier"),
        ));
    }
    let re = value.re;
    let im = value.im;
    let re_is_zero = re == 0.0 && !re.is_sign_negative();
    let im_is_negative = im.is_sign_negative();
    let im_sign = if im_is_negative { '-' } else { '+' };
    let use_default = spec.ty.is_none() && spec.precision.is_none();
    let (real_text, imag_text) = if use_default {
        let mut real_text = format_complex_float(re.abs());
        let mut imag_text = format_complex_float(im.abs());
        if let Some(sep) = grouping {
            real_text = apply_grouping_to_float_text(&real_text, sep);
            imag_text = apply_grouping_to_float_text(&imag_text, sep);
        }
        (real_text, imag_text)
    } else {
        let real_spec = FormatSpec {
            fill: spec.fill,
            align: None,
            sign: spec.sign,
            alternate: spec.alternate,
            width: None,
            grouping,
            precision: spec.precision,
            ty,
        };
        let imag_spec = FormatSpec {
            fill: spec.fill,
            align: None,
            sign: None,
            alternate: spec.alternate,
            width: None,
            grouping,
            precision: spec.precision,
            ty,
        };
        let real_text = format_float_with_spec(MoltObject::from_float(re), &real_spec)?;
        let imag_text = format_float_with_spec(MoltObject::from_float(im.abs()), &imag_spec)?;
        (real_text, imag_text)
    };
    let include_real = ty.is_some() || !re_is_zero;
    let body = if include_real {
        let real_text = if use_default {
            let mut prefix = String::new();
            if re.is_sign_negative() {
                prefix.push('-');
            } else if let Some(sign) = spec.sign {
                if sign == '+' || sign == ' ' {
                    prefix.push(sign);
                }
            }
            format!("{prefix}{real_text}")
        } else {
            real_text
        };
        let combined = format!("{real_text}{im_sign}{imag_text}j");
        if ty.is_none() {
            format!("({combined})")
        } else {
            combined
        }
    } else {
        let prefix = if im_is_negative {
            "-"
        } else if let Some(sign) = spec.sign {
            if sign == '+' || sign == ' ' {
                if sign == '+' { "+" } else { " " }
            } else {
                ""
            }
        } else {
            ""
        };
        format!("{prefix}{imag_text}j")
    };
    Ok(apply_alignment("", &body, spec, '>'))
}

fn format_with_spec(
    _py: &PyToken<'_>,
    obj: MoltObject,
    spec: &FormatSpec,
) -> Result<String, FormatError> {
    if let Some(ptr) = obj.as_ptr() {
        unsafe {
            if object_type_id(ptr) == TYPE_ID_COMPLEX {
                let value = *complex_ref(ptr);
                return format_complex_with_spec(_py, value, spec);
            }
        }
    }
    if spec.ty == Some('n') {
        if let Some(sep) = spec.grouping {
            let msg = if sep == ',' {
                "Cannot specify ',' with 'n'."
            } else {
                "Cannot specify '_' with 'n'."
            };
            return Err(("ValueError", Cow::Borrowed(msg)));
        }
        let mut normalized = FormatSpec {
            fill: spec.fill,
            align: spec.align,
            sign: spec.sign,
            alternate: spec.alternate,
            width: spec.width,
            grouping: None,
            precision: spec.precision,
            ty: None,
        };
        if obj.as_float().is_some() {
            normalized.ty = Some('g');
            return format_float_with_spec(obj, &normalized);
        }
        normalized.ty = Some('d');
        return format_int_with_spec(obj, &normalized);
    }
    match spec.ty {
        Some('s') => Ok(format_string_with_spec(format_obj_str(_py, obj), spec)),
        Some('d') | Some('b') | Some('o') | Some('x') | Some('X') | Some('c') => {
            format_int_with_spec(obj, spec)
        }
        Some('f') | Some('F') | Some('e') | Some('E') | Some('g') | Some('G') | Some('%') => {
            format_float_with_spec(obj, spec)
        }
        Some(_) => Err(("ValueError", Cow::Borrowed("unsupported format type"))),
        None => {
            if obj.as_float().is_some() {
                format_float_with_spec(obj, spec)
            } else if obj.as_bool().is_some() {
                Ok(format_string_with_spec(format_obj_str(_py, obj), spec))
            } else if obj.as_int().is_some() || bigint_ptr_from_bits(obj.bits()).is_some() {
                format_int_with_spec(obj, spec)
            } else {
                Ok(format_string_with_spec(format_obj_str(_py, obj), spec))
            }
        }
    }
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_inc_ref_obj(bits: u64) {
    crate::with_gil_entry!(_py, {
        if let Some(ptr) = obj_from_bits(bits).as_ptr() {
            unsafe { molt_inc_ref(ptr) };
        }
    })
}

#[unsafe(no_mangle)]
pub extern "C" fn molt_dec_ref_obj(bits: u64) {
    crate::with_gil_entry!(_py, {
        if let Some(ptr) = obj_from_bits(bits).as_ptr() {
            unsafe { molt_dec_ref(ptr) };
        }
    })
}

unsafe fn dict_subclass_storage_bits(_py: &PyToken<'_>, ptr: *mut u8) -> Option<u64> {
    unsafe {
        let debug = std::env::var("MOLT_DEBUG_DICT_SUBCLASS").as_deref() == Ok("1");
        let class_bits = object_class_bits(ptr);
        if class_bits == 0 {
            if debug {
                eprintln!(
                    "dict_subclass_storage_bits: no class bits for ptr=0x{:x}",
                    ptr as usize
                );
            }
            return None;
        }
        let builtins = builtin_classes(_py);
        if !issubclass_bits(class_bits, builtins.dict) {
            if debug {
                let class_name = class_name_for_error(class_bits);
                if class_name == "defaultdict" || class_name == "dict" {
                    eprintln!(
                        "dict_subclass_storage_bits: class not dict-subclass ptr=0x{:x} class={}",
                        ptr as usize, class_name
                    );
                }
            }
            return None;
        }
        let payload = object_payload_size(ptr);
        if debug {
            eprintln!(
                "dict_subclass_storage_bits: ptr=0x{:x} payload={}",
                ptr as usize, payload
            );
        }
        if payload < 2 * std::mem::size_of::<u64>() {
            if debug {
                eprintln!(
                    "dict_subclass_storage_bits: using sidecar storage for ptr=0x{:x}",
                    ptr as usize
                );
            }
            let slot = PtrSlot(ptr);
            let mut storage = runtime_state(_py).dict_subclass_storage.lock().unwrap();
            if let Some(bits) = storage.get(&slot).copied() {
                return Some(bits);
            }
            let dict_ptr = alloc_dict_with_pairs(_py, &[]);
            if dict_ptr.is_null() {
                return None;
            }
            let storage_bits = MoltObject::from_ptr(dict_ptr).bits();
            storage.insert(slot, storage_bits);
            return Some(storage_bits);
        }
        let storage_ptr = ptr.add(payload - 2 * std::mem::size_of::<u64>()) as *mut u64;
        let mut storage_bits = *storage_ptr;
        let mut needs_init = storage_bits == 0;
        let mut dict_ptr_opt = if storage_bits == 0 {
            None
        } else {
            obj_from_bits(storage_bits).as_ptr()
        };
        if let Some(dict_ptr) = dict_ptr_opt {
            if object_type_id(dict_ptr) != TYPE_ID_DICT {
                if debug {
                    eprintln!(
                        "dict_subclass_storage_bits: storage not dict ptr=0x{:x} bits=0x{:x} type_id={}",
                        ptr as usize,
                        storage_bits,
                        object_type_id(dict_ptr)
                    );
                }
                needs_init = true;
            }
        } else if storage_bits != 0 {
            needs_init = true;
        }
        if needs_init {
            let dict_ptr = alloc_dict_with_pairs(_py, &[]);
            if dict_ptr.is_null() {
                return None;
            }
            storage_bits = MoltObject::from_ptr(dict_ptr).bits();
            *storage_ptr = storage_bits;
            dict_ptr_opt = Some(dict_ptr);
            if debug {
                eprintln!(
                    "dict_subclass_storage_bits: initialized storage ptr=0x{:x} bits=0x{:x}",
                    ptr as usize, storage_bits
                );
            }
        }
        if let Some(dict_ptr) = dict_ptr_opt {
            if object_type_id(dict_ptr) != TYPE_ID_DICT {
                return None;
            }
        } else {
            return None;
        }
        Some(storage_bits)
    }
}

unsafe fn dict_like_bits_from_ptr(_py: &PyToken<'_>, ptr: *mut u8) -> Option<u64> {
    unsafe {
        if object_type_id(ptr) == TYPE_ID_DICT {
            return Some(MoltObject::from_ptr(ptr).bits());
        }
        if object_type_id(ptr) == TYPE_ID_OBJECT {
            return dict_subclass_storage_bits(_py, ptr);
        }
        None
    }
}

pub(crate) fn class_break_cycles(_py: &PyToken<'_>, bits: u64) {
    crate::gil_assert();
    let Some(ptr) = obj_from_bits(bits).as_ptr() else {
        return;
    };
    unsafe {
        if object_type_id(ptr) != TYPE_ID_TYPE {
            return;
        }
        let none_bits = MoltObject::none().bits();
        let bases_bits = class_bases_bits(ptr);
        let mro_bits = class_mro_bits(ptr);
        if !obj_from_bits(bases_bits).is_none() {
            dec_ref_bits(_py, bases_bits);
        }
        if !obj_from_bits(mro_bits).is_none() {
            dec_ref_bits(_py, mro_bits);
        }
        class_set_bases_bits(ptr, none_bits);
        class_set_mro_bits(ptr, none_bits);
        class_set_annotations_bits(_py, ptr, 0u64);
        class_set_annotate_bits(_py, ptr, 0u64);
        let dict_bits = class_dict_bits(ptr);
        if let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() {
            if object_type_id(dict_ptr) == TYPE_ID_DICT {
                dict_clear_in_place(_py, dict_ptr);
            }
        }
    }
}

pub(crate) fn tuple_from_isize_slice(_py: &PyToken<'_>, values: &[isize]) -> u64 {
    let mut elems = Vec::with_capacity(values.len());
    for &val in values {
        elems.push(MoltObject::from_int(val as i64).bits());
    }
    let ptr = alloc_tuple(_py, &elems);
    if ptr.is_null() {
        MoltObject::none().bits()
    } else {
        MoltObject::from_ptr(ptr).bits()
    }
}

pub(crate) fn is_truthy(_py: &PyToken<'_>, obj: MoltObject) -> bool {
    if obj.is_none() {
        return false;
    }
    if let Some(b) = obj.as_bool() {
        return b;
    }
    if let Some(i) = to_i64(obj) {
        return i != 0;
    }
    if let Some(f) = obj.as_float() {
        return f != 0.0;
    }
    if let Some(big) = to_bigint(obj) {
        return !big.is_zero();
    }
    if let Some(ptr) = obj.as_ptr() {
        unsafe {
            let type_id = object_type_id(ptr);
            if type_id == TYPE_ID_STRING {
                return string_len(ptr) > 0;
            }
            if type_id == TYPE_ID_BYTES {
                return bytes_len(ptr) > 0;
            }
            if type_id == TYPE_ID_COMPLEX {
                let value = *complex_ref(ptr);
                return value.re != 0.0 || value.im != 0.0;
            }
            if type_id == TYPE_ID_BYTEARRAY {
                return bytes_len(ptr) > 0;
            }
            if type_id == TYPE_ID_LIST {
                return list_len(ptr) > 0;
            }
            if type_id == TYPE_ID_TUPLE {
                return tuple_len(ptr) > 0;
            }
            if type_id == TYPE_ID_INTARRAY {
                return intarray_len(ptr) > 0;
            }
            if type_id == TYPE_ID_DICT {
                return dict_len(ptr) > 0;
            }
            if type_id == TYPE_ID_SET {
                return set_len(ptr) > 0;
            }
            if type_id == TYPE_ID_FROZENSET {
                return set_len(ptr) > 0;
            }
            if type_id == TYPE_ID_BUFFER2D {
                let buf_ptr = buffer2d_ptr(ptr);
                if buf_ptr.is_null() {
                    return false;
                }
                let buf = &*buf_ptr;
                return buf.rows.saturating_mul(buf.cols) > 0;
            }
            if type_id == TYPE_ID_DICT_KEYS_VIEW
                || type_id == TYPE_ID_DICT_VALUES_VIEW
                || type_id == TYPE_ID_DICT_ITEMS_VIEW
            {
                return dict_view_len(ptr) > 0;
            }
            if type_id == TYPE_ID_RANGE {
                let Some((start, stop, step)) = range_components_bigint(ptr) else {
                    return false;
                };
                let len = range_len_bigint(&start, &stop, &step);
                return !len.is_zero();
            }
            if type_id == TYPE_ID_ITER {
                return true;
            }
            if type_id == TYPE_ID_GENERATOR {
                return true;
            }
            if type_id == TYPE_ID_ASYNC_GENERATOR {
                return true;
            }
            if type_id == TYPE_ID_ENUMERATE {
                return true;
            }
            if type_id == TYPE_ID_CALL_ITER
                || type_id == TYPE_ID_REVERSED
                || type_id == TYPE_ID_ZIP
                || type_id == TYPE_ID_MAP
                || type_id == TYPE_ID_FILTER
            {
                return true;
            }
            if type_id == TYPE_ID_SLICE {
                return true;
            }
            if type_id == TYPE_ID_CONTEXT_MANAGER {
                return true;
            }
            if type_id == TYPE_ID_FILE_HANDLE {
                return true;
            }
            if type_id == TYPE_ID_OBJECT || type_id == TYPE_ID_DATACLASS {
                if let Some(name_bits) = attr_name_bits_from_bytes(_py, b"__bool__") {
                    let call_bits = attr_lookup_ptr_allow_missing(_py, ptr, name_bits);
                    dec_ref_bits(_py, name_bits);
                    if let Some(call_bits) = call_bits {
                        let res_bits = call_callable0(_py, call_bits);
                        dec_ref_bits(_py, call_bits);
                        if exception_pending(_py) {
                            dec_ref_bits(_py, res_bits);
                            return false;
                        }
                        let res_obj = obj_from_bits(res_bits);
                        if let Some(b) = res_obj.as_bool() {
                            dec_ref_bits(_py, res_bits);
                            return b;
                        }
                        let res_type = class_name_for_error(type_of_bits(_py, res_bits));
                        dec_ref_bits(_py, res_bits);
                        let msg = format!("__bool__ should return bool, returned {res_type}");
                        let _ = raise_exception::<u64>(_py, "TypeError", &msg);
                        return false;
                    }
                }
                if let Some(name_bits) = attr_name_bits_from_bytes(_py, b"__len__") {
                    let call_bits = attr_lookup_ptr_allow_missing(_py, ptr, name_bits);
                    dec_ref_bits(_py, name_bits);
                    if let Some(call_bits) = call_bits {
                        let res_bits = call_callable0(_py, call_bits);
                        dec_ref_bits(_py, call_bits);
                        if exception_pending(_py) {
                            dec_ref_bits(_py, res_bits);
                            return false;
                        }
                        let res_obj = obj_from_bits(res_bits);
                        if let Some(i) = to_i64(res_obj) {
                            dec_ref_bits(_py, res_bits);
                            if i < 0 {
                                let _ = raise_exception::<u64>(
                                    _py,
                                    "ValueError",
                                    "__len__() should return >= 0",
                                );
                                return false;
                            }
                            return i != 0;
                        }
                        if let Some(big_ptr) = bigint_ptr_from_bits(res_bits) {
                            let big = bigint_ref(big_ptr);
                            if big.is_negative() {
                                let _ = raise_exception::<u64>(
                                    _py,
                                    "ValueError",
                                    "__len__() should return >= 0",
                                );
                                dec_ref_bits(_py, res_bits);
                                return false;
                            }
                            let Some(len) = big.to_usize() else {
                                let _ = raise_exception::<u64>(
                                    _py,
                                    "OverflowError",
                                    "cannot fit 'int' into an index-sized integer",
                                );
                                dec_ref_bits(_py, res_bits);
                                return false;
                            };
                            if len > i64::MAX as usize {
                                let _ = raise_exception::<u64>(
                                    _py,
                                    "OverflowError",
                                    "cannot fit 'int' into an index-sized integer",
                                );
                                dec_ref_bits(_py, res_bits);
                                return false;
                            }
                            dec_ref_bits(_py, res_bits);
                            return len != 0;
                        }
                        let res_type = class_name_for_error(type_of_bits(_py, res_bits));
                        dec_ref_bits(_py, res_bits);
                        let msg =
                            format!("'{}' object cannot be interpreted as an integer", res_type);
                        let _ = raise_exception::<u64>(_py, "TypeError", &msg);
                        return false;
                    }
                }
                return true;
            }
            return true;
        }
    }
    false
}

fn union_type_display_name() -> &'static str {
    static NAME: OnceLock<&'static str> = OnceLock::new();
    NAME.get_or_init(|| {
        let minor = std::env::var("MOLT_SYS_VERSION_INFO")
            .ok()
            .and_then(|raw| {
                let mut parts = raw.split(',');
                let _major = parts.next()?.trim().parse::<i64>().ok()?;
                let minor = parts.next()?.trim().parse::<i64>().ok()?;
                Some(minor)
            })
            .unwrap_or(14);
        if minor >= 14 {
            "types.Union"
        } else {
            "types.UnionType"
        }
    })
}

pub(crate) fn type_name(_py: &PyToken<'_>, obj: MoltObject) -> Cow<'static, str> {
    if obj.is_int() {
        return Cow::Borrowed("int");
    }
    if obj.is_float() {
        return Cow::Borrowed("float");
    }
    if obj.is_bool() {
        return Cow::Borrowed("bool");
    }
    if obj.is_none() {
        return Cow::Borrowed("NoneType");
    }
    if let Some(ptr) = obj.as_ptr() {
        unsafe {
            return match object_type_id(ptr) {
                TYPE_ID_STRING => Cow::Borrowed("str"),
                TYPE_ID_BYTES => Cow::Borrowed("bytes"),
                TYPE_ID_BYTEARRAY => Cow::Borrowed("bytearray"),
                TYPE_ID_LIST => Cow::Borrowed("list"),
                TYPE_ID_TUPLE => Cow::Borrowed("tuple"),
                TYPE_ID_DICT => Cow::Borrowed("dict"),
                TYPE_ID_DICT_KEYS_VIEW => Cow::Borrowed("dict_keys"),
                TYPE_ID_DICT_VALUES_VIEW => Cow::Borrowed("dict_values"),
                TYPE_ID_DICT_ITEMS_VIEW => Cow::Borrowed("dict_items"),
                TYPE_ID_SET => Cow::Borrowed("set"),
                TYPE_ID_FROZENSET => Cow::Borrowed("frozenset"),
                TYPE_ID_BIGINT => Cow::Borrowed("int"),
                TYPE_ID_COMPLEX => Cow::Borrowed("complex"),
                TYPE_ID_RANGE => Cow::Borrowed("range"),
                TYPE_ID_SLICE => Cow::Borrowed("slice"),
                TYPE_ID_MEMORYVIEW => Cow::Borrowed("memoryview"),
                TYPE_ID_INTARRAY => Cow::Borrowed("intarray"),
                TYPE_ID_NOT_IMPLEMENTED => Cow::Borrowed("NotImplementedType"),
                TYPE_ID_ELLIPSIS => Cow::Borrowed("ellipsis"),
                TYPE_ID_EXCEPTION => Cow::Borrowed("Exception"),
                TYPE_ID_DATACLASS => {
                    Cow::Owned(class_name_for_error(type_of_bits(_py, obj.bits())))
                }
                TYPE_ID_BUFFER2D => Cow::Borrowed("buffer2d"),
                TYPE_ID_CONTEXT_MANAGER => Cow::Borrowed("context_manager"),
                TYPE_ID_FILE_HANDLE => {
                    Cow::Owned(class_name_for_error(type_of_bits(_py, obj.bits())))
                }
                TYPE_ID_FUNCTION => Cow::Owned(class_name_for_error(type_of_bits(_py, obj.bits()))),
                TYPE_ID_BOUND_METHOD => Cow::Borrowed("method"),
                TYPE_ID_CODE => Cow::Borrowed("code"),
                TYPE_ID_MODULE => Cow::Borrowed("module"),
                TYPE_ID_TYPE => Cow::Borrowed("type"),
                TYPE_ID_GENERIC_ALIAS => Cow::Borrowed("types.GenericAlias"),
                TYPE_ID_UNION => Cow::Borrowed(union_type_display_name()),
                TYPE_ID_GENERATOR => Cow::Borrowed("generator"),
                TYPE_ID_ASYNC_GENERATOR => Cow::Borrowed("async_generator"),
                TYPE_ID_ENUMERATE => Cow::Borrowed("enumerate"),
                TYPE_ID_ITER => Cow::Owned(class_name_for_error(type_of_bits(_py, obj.bits()))),
                TYPE_ID_CALL_ITER => Cow::Borrowed("callable_iterator"),
                TYPE_ID_REVERSED => Cow::Owned(class_name_for_error(type_of_bits(_py, obj.bits()))),
                TYPE_ID_ZIP => Cow::Borrowed("zip"),
                TYPE_ID_MAP => Cow::Borrowed("map"),
                TYPE_ID_FILTER => Cow::Borrowed("filter"),
                TYPE_ID_CLASSMETHOD => Cow::Borrowed("classmethod"),
                TYPE_ID_STATICMETHOD => Cow::Borrowed("staticmethod"),
                TYPE_ID_PROPERTY => Cow::Borrowed("property"),
                TYPE_ID_SUPER => Cow::Borrowed("super"),
                TYPE_ID_OBJECT => Cow::Owned(class_name_for_error(type_of_bits(_py, obj.bits()))),
                _ => Cow::Borrowed("object"),
            };
        }
    }
    Cow::Borrowed("object")
}

enum BinaryDunderOutcome {
    Value(u64),
    NotImplemented,
    Missing,
    Error,
}

unsafe fn call_dunder_raw(
    _py: &PyToken<'_>,
    raw_bits: u64,
    owner_ptr: *mut u8,
    instance_ptr: Option<*mut u8>,
    arg_bits: u64,
) -> BinaryDunderOutcome {
    unsafe {
        let Some(inst_ptr) = instance_ptr else {
            return BinaryDunderOutcome::Missing;
        };
        let Some(bound_bits) = descriptor_bind(_py, raw_bits, owner_ptr, Some(inst_ptr)) else {
            if exception_pending(_py) {
                return BinaryDunderOutcome::Error;
            }
            return BinaryDunderOutcome::Missing;
        };
        let res_bits = call_callable1(_py, bound_bits, arg_bits);
        dec_ref_bits(_py, bound_bits);
        if exception_pending(_py) {
            dec_ref_bits(_py, res_bits);
            return BinaryDunderOutcome::Error;
        }
        if is_not_implemented_bits(_py, res_bits) {
            dec_ref_bits(_py, res_bits);
            return BinaryDunderOutcome::NotImplemented;
        }
        BinaryDunderOutcome::Value(res_bits)
    }
}

unsafe fn call_binary_dunder(
    _py: &PyToken<'_>,
    lhs_bits: u64,
    rhs_bits: u64,
    op_name_bits: u64,
    rop_name_bits: u64,
) -> Option<u64> {
    unsafe {
        let lhs_obj = obj_from_bits(lhs_bits);
        let rhs_obj = obj_from_bits(rhs_bits);
        let lhs_ptr = lhs_obj.as_ptr();
        let rhs_ptr = rhs_obj.as_ptr();

        let lhs_type_bits = type_of_bits(_py, lhs_bits);
        let rhs_type_bits = type_of_bits(_py, rhs_bits);
        let lhs_type_ptr = obj_from_bits(lhs_type_bits).as_ptr();
        let rhs_type_ptr = obj_from_bits(rhs_type_bits).as_ptr();

        let lhs_op_raw =
            lhs_type_ptr.and_then(|ptr| class_attr_lookup_raw_mro(_py, ptr, op_name_bits));
        let rhs_rop_raw =
            rhs_type_ptr.and_then(|ptr| class_attr_lookup_raw_mro(_py, ptr, rop_name_bits));

        let rhs_is_subclass =
            rhs_type_bits != lhs_type_bits && issubclass_bits(rhs_type_bits, lhs_type_bits);
        let prefer_rhs = rhs_is_subclass
            && rhs_rop_raw.is_some()
            && lhs_op_raw.is_none_or(|lhs_raw| lhs_raw != rhs_rop_raw.unwrap());

        let mut tried_rhs = false;
        if prefer_rhs {
            if let (Some(rhs_ptr), Some(rhs_type_ptr), Some(rhs_raw)) =
                (rhs_ptr, rhs_type_ptr, rhs_rop_raw)
            {
                tried_rhs = true;
                match call_dunder_raw(_py, rhs_raw, rhs_type_ptr, Some(rhs_ptr), lhs_bits) {
                    BinaryDunderOutcome::Value(bits) => return Some(bits),
                    BinaryDunderOutcome::Error => return Some(MoltObject::none().bits()),
                    BinaryDunderOutcome::NotImplemented | BinaryDunderOutcome::Missing => {}
                }
            }
        }

        if let (Some(lhs_ptr), Some(lhs_type_ptr), Some(lhs_raw)) =
            (lhs_ptr, lhs_type_ptr, lhs_op_raw)
        {
            match call_dunder_raw(_py, lhs_raw, lhs_type_ptr, Some(lhs_ptr), rhs_bits) {
                BinaryDunderOutcome::Value(bits) => return Some(bits),
                BinaryDunderOutcome::Error => return Some(MoltObject::none().bits()),
                BinaryDunderOutcome::NotImplemented | BinaryDunderOutcome::Missing => {}
            }
        }

        if !tried_rhs {
            if let (Some(rhs_ptr), Some(rhs_type_ptr), Some(rhs_raw)) =
                (rhs_ptr, rhs_type_ptr, rhs_rop_raw)
            {
                match call_dunder_raw(_py, rhs_raw, rhs_type_ptr, Some(rhs_ptr), lhs_bits) {
                    BinaryDunderOutcome::Value(bits) => return Some(bits),
                    BinaryDunderOutcome::Error => return Some(MoltObject::none().bits()),
                    BinaryDunderOutcome::NotImplemented | BinaryDunderOutcome::Missing => {}
                }
            }
        }
        None
    }
}

unsafe fn call_inplace_dunder(
    _py: &PyToken<'_>,
    lhs_bits: u64,
    rhs_bits: u64,
    op_name_bits: u64,
) -> Option<u64> {
    unsafe {
        if let Some(lhs_ptr) = obj_from_bits(lhs_bits).as_ptr() {
            if let Some(call_bits) = attr_lookup_ptr(_py, lhs_ptr, op_name_bits) {
                let res_bits = call_callable1(_py, call_bits, rhs_bits);
                dec_ref_bits(_py, call_bits);
                if exception_pending(_py) {
                    dec_ref_bits(_py, res_bits);
                    return Some(MoltObject::none().bits());
                }
                if !is_not_implemented_bits(_py, res_bits) {
                    return Some(res_bits);
                }
                dec_ref_bits(_py, res_bits);
            }
            if exception_pending(_py) {
                return Some(MoltObject::none().bits());
            }
        }
        None
    }
}

pub(crate) fn obj_eq(_py: &PyToken<'_>, lhs: MoltObject, rhs: MoltObject) -> bool {
    if let (Some(li), Some(ri)) = (to_i64(lhs), to_i64(rhs)) {
        return li == ri;
    }
    if lhs.is_none() && rhs.is_none() {
        return true;
    }
    if lhs.is_float() || rhs.is_float() {
        if let (Some(lf), Some(rf)) = (to_f64(lhs), to_f64(rhs)) {
            return lf == rf;
        }
    }
    if let (Some(l_big), Some(r_big)) = (to_bigint(lhs), to_bigint(rhs)) {
        return l_big == r_big;
    }
    if complex_ptr_from_bits(lhs.bits()).is_some() || complex_ptr_from_bits(rhs.bits()).is_some() {
        let l_complex = complex_from_obj_lossy(lhs);
        let r_complex = complex_from_obj_lossy(rhs);
        if let (Some(lc), Some(rc)) = (l_complex, r_complex) {
            return lc.re == rc.re && lc.im == rc.im;
        }
        return false;
    }
    if let (Some(lp), Some(rp)) = (
        maybe_ptr_from_bits(lhs.bits()),
        maybe_ptr_from_bits(rhs.bits()),
    ) {
        unsafe {
            let ltype = object_type_id(lp);
            let rtype = object_type_id(rp);
            if ltype != rtype {
                if (ltype == TYPE_ID_BYTES && rtype == TYPE_ID_BYTEARRAY)
                    || (ltype == TYPE_ID_BYTEARRAY && rtype == TYPE_ID_BYTES)
                {
                    let l_len = bytes_len(lp);
                    let r_len = bytes_len(rp);
                    if l_len != r_len {
                        return false;
                    }
                    let l_bytes = std::slice::from_raw_parts(bytes_data(lp), l_len);
                    let r_bytes = std::slice::from_raw_parts(bytes_data(rp), r_len);
                    return l_bytes == r_bytes;
                }
                if is_set_like_type(ltype) && is_set_like_type(rtype) {
                    let l_elems = set_order(lp);
                    let r_elems = set_order(rp);
                    if l_elems.len() != r_elems.len() {
                        return false;
                    }
                    let r_table = set_table(rp);
                    for key_bits in l_elems.iter().copied() {
                        if set_find_entry_fast(_py, r_elems, r_table, key_bits).is_none() {
                            return false;
                        }
                    }
                    return true;
                }
                if (is_set_like_type(ltype) || is_set_view_type(ltype))
                    && (is_set_like_type(rtype) || is_set_view_type(rtype))
                {
                    let (lhs_ptr, lhs_bits) = if is_set_like_type(ltype) {
                        (lp, None)
                    } else {
                        let Some(bits) = dict_view_as_set_bits(_py, lp, ltype) else {
                            return false;
                        };
                        let Some(ptr) = obj_from_bits(bits).as_ptr() else {
                            dec_ref_bits(_py, bits);
                            return false;
                        };
                        (ptr, Some(bits))
                    };
                    let (rhs_ptr, rhs_bits) = if is_set_like_type(rtype) {
                        (rp, None)
                    } else {
                        let Some(bits) = dict_view_as_set_bits(_py, rp, rtype) else {
                            if let Some(bits) = lhs_bits {
                                dec_ref_bits(_py, bits);
                            }
                            return false;
                        };
                        let Some(ptr) = obj_from_bits(bits).as_ptr() else {
                            if let Some(bits) = lhs_bits {
                                dec_ref_bits(_py, bits);
                            }
                            dec_ref_bits(_py, bits);
                            return false;
                        };
                        (ptr, Some(bits))
                    };
                    let l_elems = set_order(lhs_ptr);
                    let r_elems = set_order(rhs_ptr);
                    let mut equal = true;
                    if l_elems.len() != r_elems.len() {
                        equal = false;
                    } else {
                        let r_table = set_table(rhs_ptr);
                        for key_bits in l_elems.iter().copied() {
                            if set_find_entry_fast(_py, r_elems, r_table, key_bits).is_none() {
                                equal = false;
                                break;
                            }
                        }
                    }
                    if let Some(bits) = lhs_bits {
                        dec_ref_bits(_py, bits);
                    }
                    if let Some(bits) = rhs_bits {
                        dec_ref_bits(_py, bits);
                    }
                    return equal;
                }
                return false;
            }
            if ltype == TYPE_ID_STRING {
                let l_len = string_len(lp);
                let r_len = string_len(rp);
                if l_len != r_len {
                    return false;
                }
                let l_bytes = std::slice::from_raw_parts(string_bytes(lp), l_len);
                let r_bytes = std::slice::from_raw_parts(string_bytes(rp), r_len);
                return l_bytes == r_bytes;
            }
            if ltype == TYPE_ID_BYTES || ltype == TYPE_ID_BYTEARRAY {
                let l_len = bytes_len(lp);
                let r_len = bytes_len(rp);
                if l_len != r_len {
                    return false;
                }
                let l_bytes = std::slice::from_raw_parts(bytes_data(lp), l_len);
                let r_bytes = std::slice::from_raw_parts(bytes_data(rp), r_len);
                return l_bytes == r_bytes;
            }
            if ltype == TYPE_ID_TUPLE {
                let l_elems = seq_vec_ref(lp);
                let r_elems = seq_vec_ref(rp);
                if l_elems.len() != r_elems.len() {
                    return false;
                }
                for (l_val, r_val) in l_elems.iter().zip(r_elems.iter()) {
                    if !obj_eq(_py, obj_from_bits(*l_val), obj_from_bits(*r_val)) {
                        return false;
                    }
                }
                return true;
            }
            if ltype == TYPE_ID_SLICE {
                let l_start = slice_start_bits(lp);
                let l_stop = slice_stop_bits(lp);
                let l_step = slice_step_bits(lp);
                let r_start = slice_start_bits(rp);
                let r_stop = slice_stop_bits(rp);
                let r_step = slice_step_bits(rp);
                if !obj_eq(_py, obj_from_bits(l_start), obj_from_bits(r_start)) {
                    return false;
                }
                if !obj_eq(_py, obj_from_bits(l_stop), obj_from_bits(r_stop)) {
                    return false;
                }
                if !obj_eq(_py, obj_from_bits(l_step), obj_from_bits(r_step)) {
                    return false;
                }
                return true;
            }
            if ltype == TYPE_ID_GENERIC_ALIAS {
                let l_origin = generic_alias_origin_bits(lp);
                let l_args = generic_alias_args_bits(lp);
                let r_origin = generic_alias_origin_bits(rp);
                let r_args = generic_alias_args_bits(rp);
                return obj_eq(_py, obj_from_bits(l_origin), obj_from_bits(r_origin))
                    && obj_eq(_py, obj_from_bits(l_args), obj_from_bits(r_args));
            }
            if ltype == TYPE_ID_UNION {
                let l_args = union_type_args_bits(lp);
                let r_args = union_type_args_bits(rp);
                return obj_eq(_py, obj_from_bits(l_args), obj_from_bits(r_args));
            }
            if ltype == TYPE_ID_LIST {
                let l_elems = seq_vec_ref(lp);
                let r_elems = seq_vec_ref(rp);
                if l_elems.len() != r_elems.len() {
                    return false;
                }
                for (l_val, r_val) in l_elems.iter().zip(r_elems.iter()) {
                    if !obj_eq(_py, obj_from_bits(*l_val), obj_from_bits(*r_val)) {
                        return false;
                    }
                }
                return true;
            }
            if ltype == TYPE_ID_DICT {
                let l_pairs = dict_order(lp);
                let r_pairs = dict_order(rp);
                if l_pairs.len() != r_pairs.len() {
                    return false;
                }
                let r_table = dict_table(rp);
                let entries = l_pairs.len() / 2;
                for entry_idx in 0..entries {
                    let key_bits = l_pairs[entry_idx * 2];
                    let val_bits = l_pairs[entry_idx * 2 + 1];
                    let Some(r_entry_idx) = dict_find_entry_fast(_py, r_pairs, r_table, key_bits)
                    else {
                        return false;
                    };
                    let r_val_bits = r_pairs[r_entry_idx * 2 + 1];
                    if !obj_eq(_py, obj_from_bits(val_bits), obj_from_bits(r_val_bits)) {
                        return false;
                    }
                }
                return true;
            }
            if ltype == TYPE_ID_SET || ltype == TYPE_ID_FROZENSET {
                let l_elems = set_order(lp);
                let r_elems = set_order(rp);
                if l_elems.len() != r_elems.len() {
                    return false;
                }
                let r_table = set_table(rp);
                for key_bits in l_elems.iter().copied() {
                    if set_find_entry_fast(_py, r_elems, r_table, key_bits).is_none() {
                        return false;
                    }
                }
                return true;
            }
            if ltype == TYPE_ID_DATACLASS {
                let l_desc = dataclass_desc_ptr(lp);
                let r_desc = dataclass_desc_ptr(rp);
                if l_desc.is_null() || r_desc.is_null() {
                    return false;
                }
                let l_desc = &*l_desc;
                let r_desc = &*r_desc;
                if !l_desc.eq || !r_desc.eq {
                    return lp == rp;
                }
                if l_desc.name != r_desc.name || l_desc.field_names != r_desc.field_names {
                    return false;
                }
                let l_vals = dataclass_fields_ref(lp);
                let r_vals = dataclass_fields_ref(rp);
                if l_vals.len() != r_vals.len() {
                    return false;
                }
                for (idx, (l_val, r_val)) in l_vals.iter().zip(r_vals.iter()).enumerate() {
                    let flag = l_desc.field_flags.get(idx).copied().unwrap_or(0x7);
                    if (flag & 0x2) == 0 {
                        continue;
                    }
                    if is_missing_bits(_py, *l_val) || is_missing_bits(_py, *r_val) {
                        return false;
                    }
                    if !obj_eq(_py, obj_from_bits(*l_val), obj_from_bits(*r_val)) {
                        return false;
                    }
                }
                return true;
            }
        }
        return lp == rp;
    }
    false
}

pub(crate) struct HashSecret {
    k0: u64,
    k1: u64,
}

const PY_HASH_BITS: u32 = 61;
const PY_HASH_MODULUS: u64 = (1u64 << PY_HASH_BITS) - 1;
const PY_HASH_INF: i64 = 314_159;
const PY_HASH_NONE: i64 = 0xfca86420;
const PY_HASHSEED_MAX: u64 = 4_294_967_295;

static HASH_MODULUS_BIG: OnceLock<BigInt> = OnceLock::new();

fn hash_modulus_big() -> &'static BigInt {
    HASH_MODULUS_BIG.get_or_init(|| BigInt::from(PY_HASH_MODULUS))
}

fn hash_secret(_py: &PyToken<'_>) -> &'static HashSecret {
    runtime_state(_py).hash_secret.get_or_init(init_hash_secret)
}

fn init_hash_secret() -> HashSecret {
    match std::env::var("PYTHONHASHSEED") {
        Ok(value) => {
            if value == "random" {
                return random_hash_secret();
            }
            let seed: u32 = value.parse().unwrap_or_else(|_| fatal_hash_seed(&value));
            if seed == 0 {
                return HashSecret { k0: 0, k1: 0 };
            }
            let bytes = lcg_hash_seed(seed);
            HashSecret {
                k0: u64::from_ne_bytes(bytes[..8].try_into().unwrap()),
                k1: u64::from_ne_bytes(bytes[8..].try_into().unwrap()),
            }
        }
        Err(_) => random_hash_secret(),
    }
}

fn fatal_hash_seed(value: &str) -> ! {
    eprintln!(
        "Fatal Python error: PYTHONHASHSEED must be \"random\" or an integer in range [0; {PY_HASHSEED_MAX}]"
    );
    eprintln!("PYTHONHASHSEED={value}");
    std::process::exit(1);
}

fn random_hash_secret() -> HashSecret {
    let mut bytes = [0u8; 16];
    if let Err(err) = getrandom_fill(&mut bytes) {
        eprintln!("Failed to initialize hash seed: {err}");
        std::process::exit(1);
    }
    HashSecret {
        k0: u64::from_ne_bytes(bytes[..8].try_into().unwrap()),
        k1: u64::from_ne_bytes(bytes[8..].try_into().unwrap()),
    }
}

fn lcg_hash_seed(seed: u32) -> [u8; 16] {
    let mut out = [0u8; 16];
    let mut x = seed;
    for byte in out.iter_mut() {
        x = x.wrapping_mul(214013).wrapping_add(2531011);
        *byte = ((x >> 16) & 0xff) as u8;
    }
    out
}

struct SipHasher13 {
    v0: u64,
    v1: u64,
    v2: u64,
    v3: u64,
    tail: u64,
    ntail: usize,
    total_len: u64,
}

impl SipHasher13 {
    fn new(k0: u64, k1: u64) -> Self {
        Self {
            v0: 0x736f6d6570736575 ^ k0,
            v1: 0x646f72616e646f6d ^ k1,
            v2: 0x6c7967656e657261 ^ k0,
            v3: 0x7465646279746573 ^ k1,
            tail: 0,
            ntail: 0,
            total_len: 0,
        }
    }

    fn sip_round(&mut self) {
        self.v0 = self.v0.wrapping_add(self.v1);
        self.v1 = self.v1.rotate_left(13);
        self.v1 ^= self.v0;
        self.v0 = self.v0.rotate_left(32);
        self.v2 = self.v2.wrapping_add(self.v3);
        self.v3 = self.v3.rotate_left(16);
        self.v3 ^= self.v2;
        self.v0 = self.v0.wrapping_add(self.v3);
        self.v3 = self.v3.rotate_left(21);
        self.v3 ^= self.v0;
        self.v2 = self.v2.wrapping_add(self.v1);
        self.v1 = self.v1.rotate_left(17);
        self.v1 ^= self.v2;
        self.v2 = self.v2.rotate_left(32);
    }

    fn process_block(&mut self, block: u64) {
        self.v3 ^= block;
        self.sip_round();
        self.v0 ^= block;
    }

    fn update(&mut self, bytes: &[u8]) {
        self.total_len = self.total_len.wrapping_add(bytes.len() as u64);
        for &byte in bytes {
            self.tail |= (byte as u64) << (8 * self.ntail);
            self.ntail += 1;
            if self.ntail == 8 {
                self.process_block(self.tail);
                self.tail = 0;
                self.ntail = 0;
            }
        }
    }

    fn finish(mut self) -> u64 {
        let b = self.tail | ((self.total_len & 0xff) << 56);
        self.process_block(b);
        self.v2 ^= 0xff;
        for _ in 0..3 {
            self.sip_round();
        }
        self.v0 ^ self.v1 ^ self.v2 ^ self.v3
    }
}

fn fix_hash(hash: i64) -> i64 {
    if hash == -1 { -2 } else { hash }
}

fn exp_mod(exp: i32) -> u32 {
    if exp >= 0 {
        (exp as u32) % PY_HASH_BITS
    } else {
        PY_HASH_BITS - 1 - ((-1 - exp) as u32 % PY_HASH_BITS)
    }
}

fn pow2_mod(exp: u32) -> u64 {
    let mut value = 1u64;
    for _ in 0..exp {
        value <<= 1;
        if value >= PY_HASH_MODULUS {
            value -= PY_HASH_MODULUS;
        }
    }
    value
}

fn reduce_mersenne(mut value: u128) -> u64 {
    let mask = PY_HASH_MODULUS as u128;
    value = (value & mask) + (value >> PY_HASH_BITS);
    value = (value & mask) + (value >> PY_HASH_BITS);
    if value >= mask {
        value -= mask;
    }
    if value == mask { 0 } else { value as u64 }
}

fn mul_mod_mersenne(lhs: u64, rhs: u64) -> u64 {
    reduce_mersenne((lhs as u128) * (rhs as u128))
}

fn frexp(value: f64) -> (f64, i32) {
    if value == 0.0 {
        return (0.0, 0);
    }
    let bits = value.to_bits();
    let mut exp = ((bits >> 52) & 0x7ff) as i32;
    let mut mant = bits & ((1u64 << 52) - 1);
    if exp == 0 {
        let mut e = -1022;
        while mant & (1u64 << 52) == 0 {
            mant <<= 1;
            e -= 1;
        }
        exp = e;
        mant &= (1u64 << 52) - 1;
    } else {
        exp -= 1022;
    }
    let frac_bits = (1022u64 << 52) | mant;
    let frac = f64::from_bits(frac_bits);
    (frac, exp)
}

fn hash_bytes_with_secret(bytes: &[u8], secret: &HashSecret) -> i64 {
    if bytes.is_empty() {
        return 0;
    }
    let mut hasher = SipHasher13::new(secret.k0, secret.k1);
    hasher.update(bytes);
    fix_hash(hasher.finish() as i64)
}

fn hash_bytes(_py: &PyToken<'_>, bytes: &[u8]) -> i64 {
    hash_bytes_with_secret(bytes, hash_secret(_py))
}

fn hash_string_bytes(_py: &PyToken<'_>, bytes: &[u8]) -> i64 {
    if bytes.is_empty() {
        return 0;
    }
    let secret = hash_secret(_py);
    let Ok(text) = std::str::from_utf8(bytes) else {
        return hash_bytes_with_secret(bytes, secret);
    };
    let mut max_codepoint = 0u32;
    for ch in text.chars() {
        max_codepoint = max_codepoint.max(ch as u32);
    }
    let mut hasher = SipHasher13::new(secret.k0, secret.k1);
    if max_codepoint <= 0xff {
        for ch in text.chars() {
            hasher.update(&[ch as u8]);
        }
    } else if max_codepoint <= 0xffff {
        for ch in text.chars() {
            let bytes = (ch as u16).to_ne_bytes();
            hasher.update(&bytes);
        }
    } else {
        for ch in text.chars() {
            let bytes = (ch as u32).to_ne_bytes();
            hasher.update(&bytes);
        }
    }
    fix_hash(hasher.finish() as i64)
}

fn hash_string(_py: &PyToken<'_>, ptr: *mut u8) -> i64 {
    let header = unsafe { header_from_obj_ptr(ptr) };
    let cached = unsafe { (*header).state };
    if cached != 0 {
        return cached.wrapping_sub(1);
    }
    let len = unsafe { string_len(ptr) };
    let bytes = unsafe { std::slice::from_raw_parts(string_bytes(ptr), len) };
    let hash = hash_string_bytes(_py, bytes);
    unsafe {
        (*header).state = hash.wrapping_add(1);
    }
    hash
}

fn hash_bytes_cached(_py: &PyToken<'_>, ptr: *mut u8, bytes: &[u8]) -> i64 {
    let header = unsafe { header_from_obj_ptr(ptr) };
    let cached = unsafe { (*header).state };
    if cached != 0 {
        return cached.wrapping_sub(1);
    }
    let hash = hash_bytes(_py, bytes);
    unsafe {
        (*header).state = hash.wrapping_add(1);
    }
    hash
}

fn hash_int(val: i64) -> i64 {
    let mut mag = val as i128;
    let sign = if mag < 0 { -1 } else { 1 };
    if mag < 0 {
        mag = -mag;
    }
    let modulus = PY_HASH_MODULUS as i128;
    let mut hash = (mag % modulus) as i64;
    if sign < 0 {
        hash = -hash;
    }
    fix_hash(hash)
}

fn hash_bigint(ptr: *mut u8) -> i64 {
    let big = unsafe { bigint_ref(ptr) };
    let sign = big.sign();
    let modulus = hash_modulus_big();
    let hash = big.abs().mod_floor(modulus);
    let mut hash = hash.to_i64().unwrap_or(0);
    if sign == Sign::Minus {
        hash = -hash;
    }
    fix_hash(hash)
}

fn hash_float(val: f64) -> i64 {
    if val.is_nan() {
        return 0;
    }
    if val.is_infinite() {
        return if val.is_sign_positive() {
            PY_HASH_INF
        } else {
            -PY_HASH_INF
        };
    }
    if val == 0.0 {
        return 0;
    }
    let value = val.abs();
    let mut sign = 1i64;
    if val.is_sign_negative() {
        sign = -1;
    }
    let (mut frac, mut exp) = frexp(value);
    let mut hash = 0u64;
    while frac != 0.0 {
        frac *= (1u64 << 28) as f64;
        let intpart = frac as u64;
        frac -= intpart as f64;
        hash = ((hash << 28) & PY_HASH_MODULUS) | intpart;
        exp -= 28;
    }
    let exp = exp_mod(exp);
    hash = mul_mod_mersenne(hash, pow2_mod(exp));
    let hash = (hash as i64) * sign;
    fix_hash(hash)
}

fn hash_complex(re: f64, im: f64) -> i64 {
    let re_hash = hash_float(re);
    let im_hash = hash_float(im);
    let mut hash = re_hash.wrapping_add(im_hash.wrapping_mul(1000003));
    if hash == -1 {
        hash = -2;
    }
    hash
}

fn hash_tuple(_py: &PyToken<'_>, ptr: *mut u8) -> i64 {
    let elems = unsafe { seq_vec_ref(ptr) };
    #[cfg(target_pointer_width = "64")]
    {
        const XXPRIME_1: u64 = 11400714785074694791;
        const XXPRIME_2: u64 = 14029467366897019727;
        const XXPRIME_5: u64 = 2870177450012600261;
        let mut acc = XXPRIME_5;
        for &elem in elems.iter() {
            let lane = hash_bits_signed(_py, elem);
            if exception_pending(_py) {
                return 0;
            }
            acc = acc.wrapping_add((lane as u64).wrapping_mul(XXPRIME_2));
            acc = acc.rotate_left(31);
            acc = acc.wrapping_mul(XXPRIME_1);
        }
        acc = acc.wrapping_add((elems.len() as u64) ^ (XXPRIME_5 ^ 3527539));
        if acc == u64::MAX {
            return 1546275796;
        }
        acc as i64
    }
    #[cfg(target_pointer_width = "32")]
    {
        const XXPRIME_1: u32 = 2654435761;
        const XXPRIME_2: u32 = 2246822519;
        const XXPRIME_5: u32 = 374761393;
        let mut acc = XXPRIME_5;
        for &elem in elems.iter() {
            let lane = hash_bits_signed(_py, elem);
            if exception_pending(_py) {
                return 0;
            }
            acc = acc.wrapping_add((lane as u32).wrapping_mul(XXPRIME_2));
            acc = acc.rotate_left(13);
            acc = acc.wrapping_mul(XXPRIME_1);
        }
        acc = acc.wrapping_add((elems.len() as u32) ^ (XXPRIME_5 ^ 3527539));
        if acc == u32::MAX {
            return 1546275796;
        }
        return (acc as i32) as i64;
    }
}

fn hash_dataclass_fields(
    _py: &PyToken<'_>,
    fields: &[u64],
    flags: &[u8],
    field_names: &[String],
    type_label: &str,
) -> i64 {
    #[cfg(target_pointer_width = "64")]
    {
        const XXPRIME_1: u64 = 11400714785074694791;
        const XXPRIME_2: u64 = 14029467366897019727;
        const XXPRIME_5: u64 = 2870177450012600261;
        let mut acc = XXPRIME_5;
        let mut count = 0usize;
        for (idx, &elem) in fields.iter().enumerate() {
            let flag = flags.get(idx).copied().unwrap_or(0x7);
            if (flag & 0x4) == 0 {
                continue;
            }
            if is_missing_bits(_py, elem) {
                let name = field_names.get(idx).map(|s| s.as_str()).unwrap_or("field");
                let _ = attr_error(_py, type_label, name);
                return 0;
            }
            count += 1;
            let lane = hash_bits_signed(_py, elem);
            if exception_pending(_py) {
                return 0;
            }
            acc = acc.wrapping_add((lane as u64).wrapping_mul(XXPRIME_2));
            acc = acc.rotate_left(31);
            acc = acc.wrapping_mul(XXPRIME_1);
        }
        acc = acc.wrapping_add((count as u64) ^ (XXPRIME_5 ^ 3527539));
        if acc == u64::MAX {
            return 1546275796;
        }
        acc as i64
    }
    #[cfg(target_pointer_width = "32")]
    {
        const XXPRIME_1: u32 = 2654435761;
        const XXPRIME_2: u32 = 2246822519;
        const XXPRIME_5: u32 = 374761393;
        let mut acc = XXPRIME_5;
        let mut count = 0usize;
        for (idx, &elem) in fields.iter().enumerate() {
            let flag = flags.get(idx).copied().unwrap_or(0x7);
            if (flag & 0x4) == 0 {
                continue;
            }
            if is_missing_bits(_py, elem) {
                let name = field_names.get(idx).map(|s| s.as_str()).unwrap_or("field");
                let _ = attr_error(_py, type_label, name);
                return 0;
            }
            count += 1;
            let lane = hash_bits_signed(_py, elem);
            if exception_pending(_py) {
                return 0;
            }
            acc = acc.wrapping_add((lane as u32).wrapping_mul(XXPRIME_2));
            acc = acc.rotate_left(13);
            acc = acc.wrapping_mul(XXPRIME_1);
        }
        acc = acc.wrapping_add((count as u32) ^ (XXPRIME_5 ^ 3527539));
        if acc == u32::MAX {
            return 1546275796;
        }
        (acc as i32) as i64
    }
}

fn hash_generic_alias(_py: &PyToken<'_>, ptr: *mut u8) -> i64 {
    let origin_bits = unsafe { generic_alias_origin_bits(ptr) };
    let args_bits = unsafe { generic_alias_args_bits(ptr) };
    #[cfg(target_pointer_width = "64")]
    {
        const XXPRIME_1: u64 = 11400714785074694791;
        const XXPRIME_2: u64 = 14029467366897019727;
        const XXPRIME_5: u64 = 2870177450012600261;
        let mut acc = XXPRIME_5;
        for lane_bits in [origin_bits, args_bits] {
            let lane = hash_bits_signed(_py, lane_bits);
            if exception_pending(_py) {
                return 0;
            }
            acc = acc.wrapping_add((lane as u64).wrapping_mul(XXPRIME_2));
            acc = acc.rotate_left(31);
            acc = acc.wrapping_mul(XXPRIME_1);
        }
        acc = acc.wrapping_add(2u64 ^ (XXPRIME_5 ^ 3527539));
        if acc == u64::MAX {
            return 1546275796;
        }
        acc as i64
    }
    #[cfg(target_pointer_width = "32")]
    {
        const XXPRIME_1: u32 = 2654435761;
        const XXPRIME_2: u32 = 2246822519;
        const XXPRIME_5: u32 = 374761393;
        let mut acc = XXPRIME_5;
        for lane_bits in [origin_bits, args_bits] {
            let lane = hash_bits_signed(_py, lane_bits);
            if exception_pending(_py) {
                return 0;
            }
            acc = acc.wrapping_add((lane as u32).wrapping_mul(XXPRIME_2));
            acc = acc.rotate_left(13);
            acc = acc.wrapping_mul(XXPRIME_1);
        }
        acc = acc.wrapping_add(2u32 ^ (XXPRIME_5 ^ 3527539));
        if acc == u32::MAX {
            return 1546275796;
        }
        return (acc as i32) as i64;
    }
}

fn hash_union_type(_py: &PyToken<'_>, ptr: *mut u8) -> i64 {
    let args_bits = unsafe { union_type_args_bits(ptr) };
    #[cfg(target_pointer_width = "64")]
    {
        const XXPRIME_1: u64 = 11400714785074694791;
        const XXPRIME_2: u64 = 14029467366897019727;
        const XXPRIME_5: u64 = 2870177450012600261;
        let lane = hash_bits_signed(_py, args_bits);
        if exception_pending(_py) {
            return 0;
        }
        let mut acc = XXPRIME_5;
        acc = acc.wrapping_add((lane as u64).wrapping_mul(XXPRIME_2));
        acc = acc.rotate_left(31);
        acc = acc.wrapping_mul(XXPRIME_1);
        acc = acc.wrapping_add(1u64 ^ (XXPRIME_5 ^ 3527539));
        if acc == u64::MAX {
            return 1546275796;
        }
        acc as i64
    }
    #[cfg(target_pointer_width = "32")]
    {
        const XXPRIME_1: u32 = 2654435761;
        const XXPRIME_2: u32 = 2246822519;
        const XXPRIME_5: u32 = 374761393;
        let lane = hash_bits_signed(_py, args_bits);
        if exception_pending(_py) {
            return 0;
        }
        let mut acc = XXPRIME_5;
        acc = acc.wrapping_add((lane as u32).wrapping_mul(XXPRIME_2));
        acc = acc.rotate_left(13);
        acc = acc.wrapping_mul(XXPRIME_1);
        acc = acc.wrapping_add(1u32 ^ (XXPRIME_5 ^ 3527539));
        if acc == u32::MAX {
            return 1546275796;
        }
        return (acc as i32) as i64;
    }
}

#[cfg(target_pointer_width = "64")]
fn slice_hash_acc(lanes: [u64; 3]) -> u64 {
    const XXPRIME_1: u64 = 11400714785074694791;
    const XXPRIME_2: u64 = 14029467366897019727;
    const XXPRIME_5: u64 = 2870177450012600261;
    let mut acc = XXPRIME_5;
    for lane in lanes {
        acc = acc.wrapping_add(lane.wrapping_mul(XXPRIME_2));
        acc = acc.rotate_left(31);
        acc = acc.wrapping_mul(XXPRIME_1);
    }
    acc
}

#[cfg(target_pointer_width = "32")]
fn slice_hash_acc(lanes: [u32; 3]) -> u32 {
    const XXPRIME_1: u32 = 2654435761;
    const XXPRIME_2: u32 = 2246822519;
    const XXPRIME_5: u32 = 374761393;
    let mut acc = XXPRIME_5;
    for lane in lanes {
        acc = acc.wrapping_add(lane.wrapping_mul(XXPRIME_2));
        acc = acc.rotate_left(13);
        acc = acc.wrapping_mul(XXPRIME_1);
    }
    acc
}

pub(crate) fn hash_slice_bits(
    _py: &PyToken<'_>,
    start_bits: u64,
    stop_bits: u64,
    step_bits: u64,
) -> Option<i64> {
    let mut lanes = [0i64; 3];
    let elems = [start_bits, stop_bits, step_bits];
    for (idx, bits) in elems.iter().enumerate() {
        lanes[idx] = hash_bits_signed(_py, *bits);
        if exception_pending(_py) {
            return None;
        }
    }
    #[cfg(target_pointer_width = "64")]
    {
        let acc = slice_hash_acc([lanes[0] as u64, lanes[1] as u64, lanes[2] as u64]);
        if acc == u64::MAX {
            return Some(1546275796);
        }
        Some(acc as i64)
    }
    #[cfg(target_pointer_width = "32")]
    {
        let acc = slice_hash_acc([lanes[0] as u32, lanes[1] as u32, lanes[2] as u32]);
        if acc == u32::MAX {
            return Some(1546275796);
        }
        return Some((acc as i32) as i64);
    }
}

fn shuffle_frozenset_hash(hash: u64) -> u64 {
    let mixed = (hash ^ 89869747u64) ^ (hash << 16);
    mixed.wrapping_mul(3644798167u64)
}

fn hash_frozenset(_py: &PyToken<'_>, ptr: *mut u8) -> i64 {
    let elems = unsafe { set_order(ptr) };
    let mut hash = 0u64;
    for &elem in elems.iter() {
        hash ^= shuffle_frozenset_hash(hash_bits(_py, elem));
    }
    if elems.len() & 1 == 1 {
        hash ^= shuffle_frozenset_hash(0);
    }
    hash ^= ((elems.len() as u64) + 1).wrapping_mul(1927868237u64);
    hash ^= (hash >> 11) ^ (hash >> 25);
    hash = hash.wrapping_mul(69069u64).wrapping_add(907133923u64);
    if hash == u64::MAX {
        hash = 590923713u64;
    }
    hash as i64
}

fn hash_pointer(ptr: u64) -> i64 {
    let hash = (ptr >> 4) as i64;
    fix_hash(hash)
}

fn hash_unhashable(_py: &PyToken<'_>, obj: MoltObject) -> i64 {
    let name = type_name(_py, obj);
    let msg = format!("unhashable type: '{name}'");
    raise_exception::<_>(_py, "TypeError", &msg)
}

fn is_unhashable_type(type_id: u32) -> bool {
    matches!(
        type_id,
        TYPE_ID_LIST
            | TYPE_ID_DICT
            | TYPE_ID_SET
            | TYPE_ID_BYTEARRAY
            | TYPE_ID_MEMORYVIEW
            | TYPE_ID_LIST_BUILDER
            | TYPE_ID_DICT_BUILDER
            | TYPE_ID_SET_BUILDER
            | TYPE_ID_DICT_KEYS_VIEW
            | TYPE_ID_DICT_VALUES_VIEW
            | TYPE_ID_DICT_ITEMS_VIEW
            | TYPE_ID_CALLARGS
    )
}

fn hash_bits_signed(_py: &PyToken<'_>, bits: u64) -> i64 {
    let obj = obj_from_bits(bits);
    if let Some(i) = obj.as_int() {
        return hash_int(i);
    }
    if let Some(b) = obj.as_bool() {
        return hash_int(if b { 1 } else { 0 });
    }
    if obj.is_none() {
        return PY_HASH_NONE;
    }
    if let Some(f) = obj.as_float() {
        return hash_float(f);
    }
    if let Some(ptr) = obj.as_ptr() {
        unsafe {
            let type_id = object_type_id(ptr);
            if is_unhashable_type(type_id) {
                return hash_unhashable(_py, obj);
            }
            if type_id == TYPE_ID_STRING {
                return hash_string(_py, ptr);
            }
            if type_id == TYPE_ID_BYTES || type_id == TYPE_ID_BYTEARRAY {
                let len = bytes_len(ptr);
                let bytes = std::slice::from_raw_parts(bytes_data(ptr), len);
                return hash_bytes_cached(_py, ptr, bytes);
            }
            if type_id == TYPE_ID_BIGINT {
                return hash_bigint(ptr);
            }
            if type_id == TYPE_ID_COMPLEX {
                let value = *complex_ref(ptr);
                return hash_complex(value.re, value.im);
            }
            if type_id == TYPE_ID_TUPLE {
                return hash_tuple(_py, ptr);
            }
            if type_id == TYPE_ID_DATACLASS {
                let desc_ptr = dataclass_desc_ptr(ptr);
                if desc_ptr.is_null() {
                    return hash_pointer(ptr as u64);
                }
                let desc = &*desc_ptr;
                match desc.hash_mode {
                    2 => return hash_unhashable(_py, obj),
                    3 => {
                        let hash_name_bits = intern_static_name(
                            _py,
                            &runtime_state(_py).interned.hash_name,
                            b"__hash__",
                        );
                        if let Some(call_bits) =
                            attr_lookup_ptr_allow_missing(_py, ptr, hash_name_bits)
                        {
                            let res_bits = call_callable0(_py, call_bits);
                            dec_ref_bits(_py, call_bits);
                            if exception_pending(_py) {
                                dec_ref_bits(_py, res_bits);
                                return 0;
                            }
                            let res_obj = obj_from_bits(res_bits);
                            if let Some(val) = to_i64(res_obj) {
                                dec_ref_bits(_py, res_bits);
                                return fix_hash(val);
                            }
                            if let Some(big_ptr) = bigint_ptr_from_bits(res_bits) {
                                let big = bigint_ref(big_ptr);
                                let Some(val) = big.to_i64() else {
                                    dec_ref_bits(_py, res_bits);
                                    return raise_exception::<i64>(
                                        _py,
                                        "OverflowError",
                                        "cannot fit 'int' into an index-sized integer",
                                    );
                                };
                                dec_ref_bits(_py, res_bits);
                                return fix_hash(val);
                            }
                            dec_ref_bits(_py, res_bits);
                            return raise_exception::<i64>(
                                _py,
                                "TypeError",
                                "__hash__ returned non-int",
                            );
                        }
                        return hash_pointer(ptr as u64);
                    }
                    1 => {
                        let fields = dataclass_fields_ref(ptr);
                        let type_label = if desc.name.is_empty() {
                            "dataclass"
                        } else {
                            desc.name.as_str()
                        };
                        return hash_dataclass_fields(
                            _py,
                            fields,
                            &desc.field_flags,
                            &desc.field_names,
                            type_label,
                        );
                    }
                    _ => return hash_pointer(ptr as u64),
                }
            }
            if type_id == TYPE_ID_TYPE {
                let class_bits = type_of_bits(_py, obj.bits());
                if class_bits == builtin_classes(_py).type_obj {
                    return hash_pointer(ptr as u64);
                }
                if let Some(hash) = hash_from_dunder(_py, obj, ptr) {
                    return hash;
                }
                return hash_pointer(ptr as u64);
            }
            if type_id == TYPE_ID_GENERIC_ALIAS {
                return hash_generic_alias(_py, ptr);
            }
            if type_id == TYPE_ID_UNION {
                return hash_union_type(_py, ptr);
            }
            if type_id == TYPE_ID_SLICE {
                let start_bits = slice_start_bits(ptr);
                let stop_bits = slice_stop_bits(ptr);
                let step_bits = slice_step_bits(ptr);
                if let Some(hash) = hash_slice_bits(_py, start_bits, stop_bits, step_bits) {
                    return hash;
                }
                return 0;
            }
            if type_id == TYPE_ID_FROZENSET {
                return hash_frozenset(_py, ptr);
            }
            if let Some(hash) = hash_from_dunder(_py, obj, ptr) {
                return hash;
            }
        }
        return hash_pointer(ptr as u64);
    }
    hash_pointer(bits)
}

unsafe fn hash_from_dunder(_py: &PyToken<'_>, obj: MoltObject, obj_ptr: *mut u8) -> Option<i64> {
    unsafe {
        let hash_name_bits =
            intern_static_name(_py, &runtime_state(_py).interned.hash_name, b"__hash__");
        let eq_name_bits = intern_static_name(_py, &runtime_state(_py).interned.eq_name, b"__eq__");
        let class_bits = type_of_bits(_py, obj.bits());
        let default_type_hashable = class_bits == builtin_classes(_py).type_obj;
        if let Some(class_ptr) = obj_from_bits(class_bits).as_ptr() {
            if object_type_id(class_ptr) == TYPE_ID_TYPE && !default_type_hashable {
                let dict_bits = class_dict_bits(class_ptr);
                if let Some(dict_ptr) = obj_from_bits(dict_bits).as_ptr() {
                    if object_type_id(dict_ptr) == TYPE_ID_DICT {
                        let hash_entry = dict_get_in_place(_py, dict_ptr, hash_name_bits);
                        if exception_pending(_py) {
                            return Some(0);
                        }
                        if let Some(hash_bits) = hash_entry {
                            if obj_from_bits(hash_bits).is_none() {
                                let name = type_name(_py, obj);
                                let msg = format!("unhashable type: '{name}'");
                                return Some(raise_exception::<i64>(_py, "TypeError", &msg));
                            }
                        } else if dict_get_in_place(_py, dict_ptr, eq_name_bits).is_some() {
                            let name = type_name(_py, obj);
                            let msg = format!("unhashable type: '{name}'");
                            return Some(raise_exception::<i64>(_py, "TypeError", &msg));
                        }
                        if exception_pending(_py) {
                            return Some(0);
                        }
                    }
                }
            }
        }
        let Some(call_bits) = attr_lookup_ptr_allow_missing(_py, obj_ptr, hash_name_bits) else {
            return None;
        };
        if obj_from_bits(call_bits).is_none() {
            dec_ref_bits(_py, call_bits);
            if default_type_hashable {
                return None;
            }
            let name = type_name(_py, obj);
            let msg = format!("unhashable type: '{name}'");
            return Some(raise_exception::<i64>(_py, "TypeError", &msg));
        }
        let res_bits = call_callable0(_py, call_bits);
        dec_ref_bits(_py, call_bits);
        if exception_pending(_py) {
            if !obj_from_bits(res_bits).is_none() {
                dec_ref_bits(_py, res_bits);
            }
            return Some(0);
        }
        let res_obj = obj_from_bits(res_bits);
        let hash = if let Some(i) = to_i64(res_obj) {
            hash_int(i)
        } else if let Some(ptr) = res_obj.as_ptr() {
            if object_type_id(ptr) == TYPE_ID_BIGINT {
                hash_bigint(ptr)
            } else {
                let msg = "__hash__ method should return an integer";
                dec_ref_bits(_py, res_bits);
                return Some(raise_exception::<i64>(_py, "TypeError", msg));
            }
        } else {
            let msg = "__hash__ method should return an integer";
            dec_ref_bits(_py, res_bits);
            return Some(raise_exception::<i64>(_py, "TypeError", msg));
        };
        dec_ref_bits(_py, res_bits);
        Some(hash)
    }
}

fn hash_bits(_py: &PyToken<'_>, bits: u64) -> u64 {
    hash_bits_signed(_py, bits) as u64
}

fn ensure_hashable(_py: &PyToken<'_>, key_bits: u64) -> bool {
    let obj = obj_from_bits(key_bits);
    if let Some(ptr) = obj.as_ptr() {
        unsafe {
            let type_id = object_type_id(ptr);
            if is_unhashable_type(type_id) {
                let name = type_name(_py, obj);
                let msg = format!("unhashable type: '{name}'");
                return raise_exception::<_>(_py, "TypeError", &msg);
            }
        }
    }
    true
}

pub(crate) fn dict_table_capacity(entries: usize) -> usize {
    let mut cap = entries.saturating_mul(2).next_power_of_two();
    if cap < 8 {
        cap = 8;
    }
    cap
}

fn dict_insert_entry(_py: &PyToken<'_>, order: &[u64], table: &mut [usize], entry_idx: usize) {
    let mask = table.len() - 1;
    let key_bits = order[entry_idx * 2];
    let mut slot = (hash_bits(_py, key_bits) as usize) & mask;
    loop {
        if table[slot] == 0 {
            table[slot] = entry_idx + 1;
            return;
        }
        slot = (slot + 1) & mask;
    }
}

fn dict_insert_entry_with_hash(
    _py: &PyToken<'_>,
    _order: &[u64],
    table: &mut [usize],
    entry_idx: usize,
    hash: u64,
) {
    let mask = table.len() - 1;
    let mut slot = (hash as usize) & mask;
    loop {
        if table[slot] == 0 {
            table[slot] = entry_idx + 1;
            return;
        }
        slot = (slot + 1) & mask;
    }
}
fn dict_rebuild(_py: &PyToken<'_>, order: &[u64], table: &mut Vec<usize>, capacity: usize) {
    table.clear();
    table.resize(capacity, 0);
    let entry_count = order.len() / 2;
    for entry_idx in 0..entry_count {
        dict_insert_entry(_py, order, table, entry_idx);
    }
}

pub(crate) fn dict_find_entry_fast(
    _py: &PyToken<'_>,
    order: &[u64],
    table: &[usize],
    key_bits: u64,
) -> Option<usize> {
    if table.is_empty() {
        return None;
    }
    let mask = table.len() - 1;
    let mut slot = (hash_bits(_py, key_bits) as usize) & mask;
    loop {
        let entry = table[slot];
        if entry == 0 {
            return None;
        }
        let entry_idx = entry - 1;
        let entry_key = order[entry_idx * 2];
        if obj_eq(_py, obj_from_bits(entry_key), obj_from_bits(key_bits)) {
            return Some(entry_idx);
        }
        slot = (slot + 1) & mask;
    }
}

pub(crate) fn dict_find_entry(
    _py: &PyToken<'_>,
    order: &[u64],
    table: &[usize],
    key_bits: u64,
) -> Option<usize> {
    if table.is_empty() {
        return None;
    }
    let pending_before = exception_pending(_py);
    let mask = table.len() - 1;
    let mut slot = (hash_bits(_py, key_bits) as usize) & mask;
    loop {
        let entry = table[slot];
        if entry == 0 {
            return None;
        }
        let entry_idx = entry - 1;
        let entry_key = order[entry_idx * 2];
        if let Some(eq) = unsafe { string_bits_eq(entry_key, key_bits) } {
            if eq {
                return Some(entry_idx);
            }
            slot = (slot + 1) & mask;
            continue;
        }
        let eq = unsafe { eq_bool_from_bits(_py, entry_key, key_bits) };
        match eq {
            Some(true) => return Some(entry_idx),
            Some(false) => {
                if pending_before && unsafe { string_bits_eq(entry_key, key_bits) } == Some(true) {
                    return Some(entry_idx);
                }
            }
            None => {
                if pending_before && unsafe { string_bits_eq(entry_key, key_bits) } == Some(true) {
                    return Some(entry_idx);
                }
                return None;
            }
        }
        slot = (slot + 1) & mask;
    }
}

unsafe fn string_bits_eq(a_bits: u64, b_bits: u64) -> Option<bool> {
    unsafe {
        let a_obj = obj_from_bits(a_bits);
        let b_obj = obj_from_bits(b_bits);
        let Some(a_ptr) = a_obj.as_ptr() else {
            return None;
        };
        let Some(b_ptr) = b_obj.as_ptr() else {
            return None;
        };
        if object_type_id(a_ptr) != TYPE_ID_STRING || object_type_id(b_ptr) != TYPE_ID_STRING {
            return None;
        }
        if a_ptr == b_ptr {
            return Some(true);
        }
        let a_len = string_len(a_ptr);
        let b_len = string_len(b_ptr);
        if a_len != b_len {
            return Some(false);
        }
        let a_bytes = std::slice::from_raw_parts(string_bytes(a_ptr), a_len);
        let b_bytes = std::slice::from_raw_parts(string_bytes(b_ptr), b_len);
        Some(a_bytes == b_bytes)
    }
}

pub(crate) fn dict_find_entry_with_hash(
    _py: &PyToken<'_>,
    order: &[u64],
    table: &[usize],
    key_bits: u64,
    hash: u64,
) -> Option<usize> {
    if table.is_empty() {
        return None;
    }
    let mask = table.len() - 1;
    let mut slot = (hash as usize) & mask;
    loop {
        let entry = table[slot];
        if entry == 0 {
            return None;
        }
        let entry_idx = entry - 1;
        let entry_key = order[entry_idx * 2];
        if let Some(eq) = unsafe { string_bits_eq(entry_key, key_bits) } {
            if eq {
                return Some(entry_idx);
            }
            slot = (slot + 1) & mask;
            continue;
        }
        let eq = unsafe { eq_bool_from_bits(_py, entry_key, key_bits) };
        match eq {
            Some(true) => return Some(entry_idx),
            Some(false) => {}
            None => return None,
        }
        slot = (slot + 1) & mask;
    }
}

pub(crate) fn set_table_capacity(entries: usize) -> usize {
    dict_table_capacity(entries)
}

fn set_insert_entry(_py: &PyToken<'_>, order: &[u64], table: &mut [usize], entry_idx: usize) {
    let mask = table.len() - 1;
    let key_bits = order[entry_idx];
    let mut slot = (hash_bits(_py, key_bits) as usize) & mask;
    loop {
        if table[slot] == 0 {
            table[slot] = entry_idx + 1;
            return;
        }
        slot = (slot + 1) & mask;
    }
}

fn set_insert_entry_with_hash(
    _py: &PyToken<'_>,
    _order: &[u64],
    table: &mut [usize],
    entry_idx: usize,
    hash: u64,
) {
    let mask = table.len() - 1;
    let mut slot = (hash as usize) & mask;
    loop {
        if table[slot] == 0 {
            table[slot] = entry_idx + 1;
            return;
        }
        slot = (slot + 1) & mask;
    }
}
fn set_rebuild(_py: &PyToken<'_>, order: &[u64], table: &mut Vec<usize>, capacity: usize) {
    crate::gil_assert();
    table.clear();
    table.resize(capacity, 0);
    for entry_idx in 0..order.len() {
        set_insert_entry(_py, order, table, entry_idx);
    }
}

pub(crate) fn set_find_entry_fast(
    _py: &PyToken<'_>,
    order: &[u64],
    table: &[usize],
    key_bits: u64,
) -> Option<usize> {
    if table.is_empty() {
        return None;
    }
    let mask = table.len() - 1;
    let mut slot = (hash_bits(_py, key_bits) as usize) & mask;
    loop {
        let entry = table[slot];
        if entry == 0 {
            return None;
        }
        let entry_idx = entry - 1;
        let entry_key = order[entry_idx];
        if obj_eq(_py, obj_from_bits(entry_key), obj_from_bits(key_bits)) {
            return Some(entry_idx);
        }
        slot = (slot + 1) & mask;
    }
}

pub(crate) fn set_find_entry(
    _py: &PyToken<'_>,
    order: &[u64],
    table: &[usize],
    key_bits: u64,
) -> Option<usize> {
    if table.is_empty() {
        return None;
    }
    let mask = table.len() - 1;
    let mut slot = (hash_bits(_py, key_bits) as usize) & mask;
    loop {
        let entry = table[slot];
        if entry == 0 {
            return None;
        }
        let entry_idx = entry - 1;
        let entry_key = order[entry_idx];
        let eq = unsafe { eq_bool_from_bits(_py, entry_key, key_bits) };
        match eq {
            Some(true) => return Some(entry_idx),
            Some(false) => {}
            None => return None,
        }
        slot = (slot + 1) & mask;
    }
}

pub(crate) fn set_find_entry_with_hash(
    _py: &PyToken<'_>,
    order: &[u64],
    table: &[usize],
    key_bits: u64,
    hash: u64,
) -> Option<usize> {
    if table.is_empty() {
        return None;
    }
    let mask = table.len() - 1;
    let mut slot = (hash as usize) & mask;
    loop {
        let entry = table[slot];
        if entry == 0 {
            return None;
        }
        let entry_idx = entry - 1;
        let entry_key = order[entry_idx];
        let eq = unsafe { eq_bool_from_bits(_py, entry_key, key_bits) };
        match eq {
            Some(true) => return Some(entry_idx),
            Some(false) => {}
            None => return None,
        }
        slot = (slot + 1) & mask;
    }
}

fn concat_bytes_like(_py: &PyToken<'_>, left: &[u8], right: &[u8], type_id: u32) -> Option<u64> {
    let total = left.len().checked_add(right.len())?;
    if type_id == TYPE_ID_BYTEARRAY {
        let mut out = Vec::with_capacity(total);
        out.extend_from_slice(left);
        out.extend_from_slice(right);
        let ptr = alloc_bytearray(_py, &out);
        if ptr.is_null() {
            return None;
        }
        return Some(MoltObject::from_ptr(ptr).bits());
    }
    let ptr = alloc_bytes_like_with_len(_py, total, type_id);
    if ptr.is_null() {
        return None;
    }
    unsafe {
        let data_ptr = ptr.add(std::mem::size_of::<usize>());
        std::ptr::copy_nonoverlapping(left.as_ptr(), data_ptr, left.len());
        std::ptr::copy_nonoverlapping(right.as_ptr(), data_ptr.add(left.len()), right.len());
    }
    Some(MoltObject::from_ptr(ptr).bits())
}

fn fill_repeated_bytes(dst: &mut [u8], pattern: &[u8]) {
    if pattern.is_empty() {
        return;
    }
    if pattern.len() == 1 {
        dst.fill(pattern[0]);
        return;
    }
    let mut filled = pattern.len().min(dst.len());
    dst[..filled].copy_from_slice(&pattern[..filled]);
    while filled < dst.len() {
        let copy_len = std::cmp::min(filled, dst.len() - filled);
        let (head, tail) = dst.split_at_mut(filled);
        tail[..copy_len].copy_from_slice(&head[..copy_len]);
        filled += copy_len;
    }
}

pub(crate) unsafe fn dict_set_in_place(
    _py: &PyToken<'_>,
    ptr: *mut u8,
    key_bits: u64,
    val_bits: u64,
) {
    unsafe {
        crate::gil_assert();
        if !ensure_hashable(_py, key_bits) {
            return;
        }
        let hash = hash_bits(_py, key_bits);
        if exception_pending(_py) {
            return;
        }
        let order = dict_order(ptr);
        let table = dict_table(ptr);
        let found = dict_find_entry_with_hash(_py, order, table, key_bits, hash);
        if exception_pending(_py) {
            return;
        }
        if let Some(entry_idx) = found {
            let val_idx = entry_idx * 2 + 1;
            let old_bits = order[val_idx];
            if old_bits != val_bits {
                dec_ref_bits(_py, old_bits);
                inc_ref_bits(_py, val_bits);
                order[val_idx] = val_bits;
            }
            return;
        }

        let new_entries = (order.len() / 2) + 1;
        let needs_resize = table.is_empty() || new_entries * 10 >= table.len() * 7;
        if needs_resize {
            let capacity = dict_table_capacity(new_entries);
            dict_rebuild(_py, order, table, capacity);
            if exception_pending(_py) {
                return;
            }
        }

        order.push(key_bits);
        order.push(val_bits);
        inc_ref_bits(_py, key_bits);
        inc_ref_bits(_py, val_bits);
        let entry_idx = order.len() / 2 - 1;
        dict_insert_entry_with_hash(_py, order, table, entry_idx, hash);
    }
}

pub(crate) unsafe fn dict_set_in_place_preserving_pending(
    _py: &PyToken<'_>,
    ptr: *mut u8,
    key_bits: u64,
    val_bits: u64,
) {
    unsafe {
        crate::gil_assert();
        if !ensure_hashable(_py, key_bits) {
            return;
        }
        let pending_before = exception_pending(_py);
        let prev_exc_bits = if pending_before {
            exception_last_bits_noinc(_py).unwrap_or(0)
        } else {
            0
        };
        let hash = hash_bits(_py, key_bits);
        if exception_pending(_py) {
            if !pending_before {
                return;
            }
            let after_exc_bits = exception_last_bits_noinc(_py).unwrap_or(0);
            if after_exc_bits != prev_exc_bits {
                return;
            }
        }
        let order = dict_order(ptr);
        let table = dict_table(ptr);
        let found = dict_find_entry_with_hash(_py, order, table, key_bits, hash);
        if exception_pending(_py) {
            if !pending_before {
                return;
            }
            let after_exc_bits = exception_last_bits_noinc(_py).unwrap_or(0);
            if after_exc_bits != prev_exc_bits {
                return;
            }
        }
        if let Some(entry_idx) = found {
            let val_idx = entry_idx * 2 + 1;
            let old_bits = order[val_idx];
            if old_bits != val_bits {
                dec_ref_bits(_py, old_bits);
                inc_ref_bits(_py, val_bits);
                order[val_idx] = val_bits;
            }
            return;
        }

        let new_entries = (order.len() / 2) + 1;
        let needs_resize = table.is_empty() || new_entries * 10 >= table.len() * 7;
        if needs_resize {
            let capacity = dict_table_capacity(new_entries);
            dict_rebuild(_py, order, table, capacity);
            if exception_pending(_py) {
                if !pending_before {
                    return;
                }
                let after_exc_bits = exception_last_bits_noinc(_py).unwrap_or(0);
                if after_exc_bits != prev_exc_bits {
                    return;
                }
            }
        }

        order.push(key_bits);
        order.push(val_bits);
        inc_ref_bits(_py, key_bits);
        inc_ref_bits(_py, val_bits);
        let entry_idx = order.len() / 2 - 1;
        dict_insert_entry_with_hash(_py, order, table, entry_idx, hash);
    }
}

pub(crate) unsafe fn set_add_in_place(_py: &PyToken<'_>, ptr: *mut u8, key_bits: u64) {
    unsafe {
        crate::gil_assert();
        if !ensure_hashable(_py, key_bits) {
            return;
        }
        let hash = hash_bits(_py, key_bits);
        if exception_pending(_py) {
            return;
        }
        let order = set_order(ptr);
        let table = set_table(ptr);
        let found = set_find_entry_with_hash(_py, order, table, key_bits, hash);
        if exception_pending(_py) {
            return;
        }
        if found.is_some() {
            return;
        }

        let new_entries = order.len() + 1;
        let needs_resize = table.is_empty() || new_entries * 10 >= table.len() * 7;
        if needs_resize {
            let capacity = set_table_capacity(new_entries);
            set_rebuild(_py, order, table, capacity);
            if exception_pending(_py) {
                return;
            }
        }

        order.push(key_bits);
        inc_ref_bits(_py, key_bits);
        let entry_idx = order.len() - 1;
        set_insert_entry_with_hash(_py, order, table, entry_idx, hash);
    }
}

pub(crate) unsafe fn dict_get_in_place(
    _py: &PyToken<'_>,
    ptr: *mut u8,
    key_bits: u64,
) -> Option<u64> {
    unsafe {
        if !ensure_hashable(_py, key_bits) {
            return None;
        }
        let pending_before = exception_pending(_py);
        let prev_exc_bits = if pending_before {
            exception_last_bits_noinc(_py).unwrap_or(0)
        } else {
            0
        };
        let order = dict_order(ptr);
        let table = dict_table(ptr);
        let found = dict_find_entry(_py, order, table, key_bits);
        if exception_pending(_py) {
            if !pending_before {
                return None;
            }
            let after_exc_bits = exception_last_bits_noinc(_py).unwrap_or(0);
            if after_exc_bits != prev_exc_bits {
                return None;
            }
        }
        found.map(|idx| order[idx * 2 + 1])
    }
}

pub(crate) unsafe fn set_del_in_place(_py: &PyToken<'_>, ptr: *mut u8, key_bits: u64) -> bool {
    unsafe {
        if !ensure_hashable(_py, key_bits) {
            return false;
        }
        let order = set_order(ptr);
        let table = set_table(ptr);
        let found = set_find_entry(_py, order, table, key_bits);
        if exception_pending(_py) {
            return false;
        }
        let Some(entry_idx) = found else {
            return false;
        };
        let key_val = order[entry_idx];
        dec_ref_bits(_py, key_val);
        order.remove(entry_idx);
        let entries = order.len();
        let capacity = set_table_capacity(entries.max(1));
        set_rebuild(_py, order, table, capacity);
        true
    }
}

pub(crate) unsafe fn set_replace_entries(_py: &PyToken<'_>, ptr: *mut u8, entries: &[u64]) {
    unsafe {
        crate::gil_assert();
        let order = set_order(ptr);
        for entry in entries {
            inc_ref_bits(_py, *entry);
        }
        for entry in order.iter().copied() {
            dec_ref_bits(_py, entry);
        }
        order.clear();
        order.extend_from_slice(entries);
        let table = set_table(ptr);
        let capacity = set_table_capacity(order.len().max(1));
        set_rebuild(_py, order, table, capacity);
    }
}

pub(crate) unsafe fn dict_del_in_place(_py: &PyToken<'_>, ptr: *mut u8, key_bits: u64) -> bool {
    unsafe {
        if !ensure_hashable(_py, key_bits) {
            return false;
        }
        let order = dict_order(ptr);
        let table = dict_table(ptr);
        let found = dict_find_entry(_py, order, table, key_bits);
        if exception_pending(_py) {
            return false;
        }
        let Some(entry_idx) = found else {
            return false;
        };
        let key_idx = entry_idx * 2;
        let val_idx = key_idx + 1;
        let key_val = order[key_idx];
        let val_val = order[val_idx];
        dec_ref_bits(_py, key_val);
        dec_ref_bits(_py, val_val);
        order.drain(key_idx..=val_idx);
        let entries = order.len() / 2;
        let capacity = dict_table_capacity(entries.max(1));
        dict_rebuild(_py, order, table, capacity);
        true
    }
}

pub(crate) unsafe fn dict_clear_in_place(_py: &PyToken<'_>, ptr: *mut u8) {
    unsafe {
        crate::gil_assert();
        let order = dict_order(ptr);
        for pair in order.chunks_exact(2) {
            dec_ref_bits(_py, pair[0]);
            dec_ref_bits(_py, pair[1]);
        }
        order.clear();
        let table = dict_table(ptr);
        table.clear();
    }
}
