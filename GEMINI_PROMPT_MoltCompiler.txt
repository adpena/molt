You are Gemini Pro acting as a “beyond-senior” research engineer and systems architect. Your task: design and help implement **Molt** — a compiler that turns a **verified per-application subset of Python** into **small, fast native binaries** (and optionally WASM), with a Go-like developer experience.

You have access to:
- A local repo (you may assume you can write files)
- Terminal access
- GitHub CLI (gh), git
- Standard Python toolchain (ruff/mypy/pytest/hypothesis/pre-commit)
- CI via GitHub Actions
- You may propose additional tooling (LLVM/MLIR, Cranelift, Zig, WASI SDK, etc.)

Hard product goals
1) Produce a single-file (or minimal-files) executable for: Linux x86_64/arm64, macOS arm64.
2) Fast startup, small binary size comparable to Go programs of similar scope (state assumptions if needed).
3) Significant speedups over CPython on real workloads by eliminating interpreter overhead in hot paths.
4) “Normal-ish Python” support via a **compatibility tier system**; not full CPython initially.
5) **No CPython C-extension loading.** Instead:
   - Provide a curated, portable “Molt Packages” set (pure Python + compiled-by-Molt, or Rust/WASM components with stable ABI).
   - Promote interoperability via **WASM**: allow calling portable WASM modules from Molt and exporting Molt components as WASM.

Correctness and rigor goals
- Treat correctness as a first-class feature: define semantics precisely for the supported subset.
- Use a **soundness model**: static proofs where possible, otherwise runtime guards + deopt/fallback.
- Build a differential test harness against CPython for supported behaviors.
- Include fuzzing (Hypothesis) + metamorphic testing + corpus minimization.
- Provide clear invariants for IR passes; include property tests for transformations.
- Reproducible builds, deterministic outputs where practical.

Your deliverable in this response
Produce a comprehensive, implementation-oriented specification and an execution plan. Write it as if it will be reviewed by world-class compiler/runtime engineers.

Format required
A) A top-level spec summary (1–2 pages)
B) A detailed spec organized into Markdown files under docs/spec/ (include filenames and full contents)
C) A staged roadmap with milestones and acceptance criteria
D) A testing/verification strategy document (differential tests, fuzzing, guards, deopt)
E) A packaging + distribution plan (macOS + Linux cross-compilation, reproducibility, signing, SBOM)
F) A security model (sandboxing, WASM boundaries, supply chain)
G) A repo changes plan: list exact files to create/modify and their contents for an MVP scaffold
H) A CI plan (GitHub Actions workflows, caching, artifact publishing)
I) A benchmark plan (methodology, suites, reporting, regression gates)

System architecture constraints & desiderata
1) Compatibility tiers (must define)
   - Tier 0: “Frozen Python” subset for AOT compilation, no dynamic imports at runtime, no eval/exec, limited reflection.
   - Tier 1: “Guarded Python” allows some dynamism with guards + deopt.
   - Tier 2+: optional future tiers (hybrid interpreter islands) — describe but keep MVP focused.

2) Core compilation approach (must choose and justify)
   - Whole-program or module-closure compilation
   - Semantic reduction via invariant mining
   - Type/shape/effect inference
   - Specialization with guards and deoptimization
   - Lowering to a compact runtime + native code
   Provide an IR stack proposal (e.g., Python AST → typed SSA → lower-level SSA → backend IR).

3) Runtime model (must define)
   - Memory management strategy (RC, tracing GC, hybrid) and why.
   - Object representations for subset: ints/floats/bools, strings, lists, tuples, dicts, classes/instances, exceptions.
   - Exceptions and control flow; how “no-exception fast paths” are represented.
   - Concurrency model (threads? async?) for MVP vs later; address the GIL question explicitly.

4) Interop model (must define)
   - WASM calling convention: host functions, module import/export, memory mapping, strings/arrays ABI.
   - Foreign function interface for “Molt Packages” implemented in Rust/WASM.
   - Clear policy: how to handle nondeterminism, syscalls, filesystem, network.

5) “Molt Packages” strategy (must define)
   - Which packages to replace first (e.g., json, regex, datetime, sqlite, http client, numpy-like subset later).
   - Criteria: portability, performance, minimal surface area, stable APIs.
   - How packages are versioned and compiled into the binary.

6) Tooling and developer experience (must define)
   - CLI: `molt build`, `molt run`, `molt test`, `molt doctor`.
   - Project config file (pyproject extension? molt.toml?) and lockfile story.
   - Debuggability: stack traces, source maps, profiler, perf counters.
   - Deterministic builds, caching, incremental builds.

7) AI-assisted components (must specify)
   - Invariant mining: propose candidate invariants from traces + static analysis.
   - Guard synthesis: produce runtime checks and fallback plans.
   - Test generation: targeted fuzzing and metamorphic tests.
   - Optimization search: superoptimization / pass ordering under constraints.
   - Provide a plan that is useful even if “AI” is not available at runtime (AI is a dev-time accelerator).

Backend choices (pick one primary for MVP, mention alternatives)
- LLVM/MLIR
- Cranelift
- Zig as a backend toolchain
- WASM-first then native via WASM2native

Be explicit:
- What is built first (MVP), what is postponed.
- What subset features are in/out for MVP.
- Binary size/perf targets and how you’ll measure them.
- What exact repos/dirs/files should exist after MVP week 1.

Repo actions you should take (assume gh is available)
- Propose creation of GitHub repo, default branch, license (suggest one), code owners, issue templates, PR templates.
- Propose CI workflows, formatting/lint gates, coverage gates, and release workflow.
- Include a plan for versioning and changelog.

Important: do not be generic.
- Provide concrete data structures, pass pipelines, IR invariants, ABIs, file layouts, and pseudocode.
- Give test case examples and how to automatically generate them.
- Provide “stop conditions” for each milestone (what proves it works).
- Provide explicit tradeoffs and rationale.

Start now. Output the full content of each file you propose, not just outlines.
