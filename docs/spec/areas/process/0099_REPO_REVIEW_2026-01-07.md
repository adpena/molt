# Molt — Repo Review & Spec Feedback (Draft)
**Snapshot date:** 2026-01-07
**Repo:** `adpena/molt` (GitHub)
**Snapshot signals used:** README (capabilities/limits/bench section), CI workflow (`.github/workflows/ci.yml` as rendered in an Actions run), and a couple of recent commits (notably `9d1537c` and `67611ad`).

> This doc is intended to be committed into `docs/spec/` (or similar) as a living “how we’re doing + what’s next” spec.

---

## 1. Project framing (what Molt is becoming)

From the README, Molt is positioning itself as:

- **AOT Python subset compiler** (not a JIT): builds native binaries and optionally WASM.
- **Performance-first**: typed classes become fixed-layout structs (“structification”), plus explicit fast paths / kernels (strings, reductions, buffer2d matmul).
- **Compatibility-by-contract**: only a subset of Python is supported, validated via **differential testing vs CPython 3.12** and parity-style tests.
- **Reproducible builds**: the workflow pushes toward pinned dependencies (e.g., `uv.lock`, Rust lockfile) and CI enforcement.

That combination is a strong and modern “Python ergonomics, compiled-language delivery” story.

---

## 2. Current state (as observed)

### 2.1 Repo structure signals good separation of concerns
The top-level layout indicates intentional modularity:

- `src/` — Python frontend / CLI glue
- `runtime/` — Rust runtime + backends
- `wit/` — interface definitions for WASM/component-style interop
- `tests/` — unit + differential + wasm harness
- `bench/` — benchmarks, baselines, results
- `tools/` — dev harness scripts

This is the right scaffolding for a serious compiler/runtime project: the runtime can evolve independently of the Python driver code, and wasm interop has its own “surface area.”

### 2.2 Capabilities and limitations are unusually concrete (good)
Your README explicitly lists current capabilities (structification, async, package story, Cranelift AOT, differential testing) *and* current limitations (imports, stdlib coverage, object model constraints, descriptor gaps, dataclass coverage, exceptions).

That clarity is a competitive advantage. Keep it.

### 2.3 CI is already “real language project” quality
From the rendered workflow file (CI run #88), you already have:

**Python job (`test-python`)**
- Python matrix: 3.12 / 3.13 / 3.14
- Dependency install via **uv**
- Lint: `ruff check .`
- Type check: `ty check src`
- Tests: `pytest`
- On 3.12 only: build runtime (`cargo build -p molt-runtime --release`)
- On 3.12 only: run differential suites
- On 3.12 only: “type coverage TODO sync” check (`tools/check_type_coverage_todos.py`)
- On 3.12 only: perf smoke gate with a baseline and max regression threshold:
  - `tools/bench.py --smoke ... --max-regression 0.25 ...`
  - uploads benchmark artifact

**Rust job (`test-rust`)**
- `cargo fmt -- --check`
- `cargo clippy -- -D warnings`
- `cargo test`

**WASM job (`test-wasm`)**
- uv + Python 3.12 + Rust
- Runs wasm parity test via `pytest tests/test_wasm_control_flow.py`

This is excellent: correctness, style, compatibility, and performance are all in your definition of “green.”

### 2.4 Performance is being treated as a first-class artifact
Your README includes a “Latest run” benchmark note:

- Latest run recorded: **2026-01-06** (macOS x86_64, CPython 3.14.0)
- Example speedups called out: `bench_sum.py` ~231×, msgpack parsing ~26×, matmul ~10×
- A regression is explicitly recorded (`bench_str_count_unicode_warm.py` ~0.25×) with a prompt to investigate

You also list **performance gates** by category (vector reductions, string kernels, matrix/buffer kernels).
This is exactly how a performance compiler project avoids death-by-regressions.

### 2.5 One thing is drifting: “status truth” across docs (fix this early)
A Jan 6 commit (`9d1537c`) updates `ROADMAP.md` to claim:

- **C3 MRO**
- **multiple inheritance for attribute lookup**
- **`super()` resolution**
- **data descriptor precedence**

…but the README “Limitations” section still says multiple inheritance/MRO/super() are not supported.

This is normal early in a fast-moving project, but you should correct it *now* because newcomers will anchor on README first.

**Recommendation:** pick one “source of truth” for feature status and make the others derived or mechanically checked.

Concrete options (pick one):
1) README is canonical; ROADMAP is “future only”
2) ROADMAP is canonical; README includes an *auto-generated* “capability snapshot”
3) `docs/spec/STATUS.md` is canonical; README and ROADMAP link to it

---

## 3. Spec feedback: what to lock down next

This section uses spec language (MUST/SHOULD/MAY) so you can treat it as requirements.

### 3.1 Define “verified subset” precisely (MUST)
Right now, “verified subset” is strongly implied via differential testing, but it should be defined as a *contract*.

**MUST specify:**
- What “verification” means (e.g., behavioral equivalence to CPython 3.12 for supported constructs).
- The “unsupported behavior” policy:
  - compile-time error vs runtime trap vs “slow fallback”
- The “Python version” policy:
  - what happens when CPython semantics differ across 3.12/3.13/3.14?

**Suggested deliverable:** `docs/spec/areas/compat/0016_VERIFIED_SUBSET_CONTRACT.md`

Outline:
- Supported semantics table (link to your type coverage matrix)
- “Undefined / rejected” features list
- Compatibility modes (`--python=3.12`, `--python=3.14`, etc.)
- Determinism model (see §3.6)

### 3.2 Make the typing strategy explicit (SHOULD)
You already have “typed Python classes -> structs.” To scale, you need a crisp story for partially-typed real codebases.

**SHOULD decide** which mode(s) Molt supports:

- **Typed-required mode:** only code that typechecks under Molt rules compiles. Fast + predictable.
- **Gradual mode:** untyped compiles but uses boxed objects/slow paths; opt-in specialization.
- **Profile-guided specialization:** gather shapes from test runs, then specialize (later).

**SHOULD specify:**
- What type system is enforced (PEP 484-ish? narrower?)
- Whether `Any` is allowed and what it costs
- What is a compile-time error vs a dynamic fallback

**Suggested deliverable:** `docs/spec/areas/compiler/0017_TYPE_SYSTEM_AND_SPECIALIZATION.md`

### 3.3 Freeze a stable “Molt Package” ABI boundary (MUST for ecosystem)
You mention “Molt Packages” (Rust-backed) using MsgPack/CBOR and Arrow IPC. That’s a great direction, but ecosystems live or die on stable ABI boundaries.

**MUST specify:**
- Call boundary: sync vs async; cancellation semantics
- Memory ownership: who allocates/frees buffers? can you do true zero-copy?
- Versioning: how to evolve APIs without breaking apps
- Capability gating: what packages are allowed to do I/O / network / process

**Suggested deliverable:** `docs/spec/areas/compat/0018_MOLT_PACKAGE_ABI.md`

### 3.4 WASM interop: pick a north star (SHOULD)
You already have `wit/` and a wasm parity test job.

Long-term wasm strategies:
1) **WASI-first** (server/edge/sandbox)
2) **Browser-first** (JS interop surface is primary)

Both are valid, but drive different runtime constraints (I/O APIs, threading, async scheduling, binary size).

**SHOULD decide** what “deployable to browser via wasm” means in measurable terms:
- minimal module size target (hello world)
- supported JS interop patterns
- restrictions (no blocking I/O; threads only if wasm-threads enabled)

**Suggested deliverable:** 0401 WASM Targets And Constraints (`docs/spec/areas/wasm/0401_WASM_TARGETS_AND_CONSTRAINTS.md`)

### 3.5 Memory model & safety invariants (MUST)
The runtime appears to use a NaN-box / tagged representation; a recent commit (`67611ad`) specifically changed `maybe_ptr_from_bits` to avoid an unsafe header-based pointer check in favor of a predicate (`is_raw_object(bits)`), which is a good move.

To keep the runtime maintainable, write down the invariants that must *always* hold.

**MUST document:**
- object representation invariants (bit patterns, tags, alignment)
- “raw pointer” invariants (when they can exist, how they’re validated)
- GC/RC invariants (when pointers can move, if ever)
- thread-safety assumptions (single-threaded today? future?)

**Suggested deliverable:** `docs/spec/areas/security/0020_RUNTIME_SAFETY_INVARIANTS.md`

**SHOULD add CI hardening (even if nightly):**
- sanitizer builds (ASan/UBSan) on Linux
- fuzz targets for parser/IR/runtime APIs
- `miri` on a small subset if feasible

### 3.6 Determinism and reproducibility as a feature (SHOULD)
You already *act* like reproducibility matters. Make it a product feature:

- deterministic builds
- deterministic runtime (when requested)
- deterministic package execution for serverless/wasm use-cases

**SHOULD specify:**
- randomness seeding policy
- time APIs behavior in deterministic mode
- hash randomization policy

**Suggested deliverable:** 0025 Reproducible And Deterministic Mode (`docs/spec/areas/core/0025_REPRODUCIBLE_AND_DETERMINISTIC_MODE.md`)

---

## 4. Ergonomics: Python-like feel without Python’s footguns

### 4.1 “Ergonomic strictness” (SHOULD)
Python is forgiving; compilers aren’t. The trick is to be strict in a friendly way:

- Great error messages (point to exact AST node)
- Actionable suggestions (“add a type annotation”, “this import is dynamic”)
- A `molt doctor` command: tells you why a file can’t compile and how to fix it

You already have a CLI spec doc listed in README; adding `doctor`/`explain` flows would be a strong adoption move.

### 4.2 Escape hatches (MAY, but keep them explicit)
Real-world adoption will need escape hatches:
- `@molt.ignore` (compile but treat as opaque boundary)
- `--allow-unsafe-dynamic` (slow path allowed; still compiles)

But escape hatches must be explicit so you don’t accidentally lose performance.

---

## 5. Performance engineering: what to measure next

You’re already measuring speedups. Next, measure the constraints that matter for “deploy everywhere.”

### 5.1 Binary size & cold start (SHOULD)
Add to benchmarks / reporting:
- output binary size (stripped/unstripped),
- wasm module size,
- cold start latency (time to first instruction / time to first request).

**Suggested deliverable:** 0604 Binary Size And Cold Start (`docs/spec/areas/perf/0604_BINARY_SIZE_AND_COLD_START.md`)

### 5.2 Memory footprint (MUST if “memory efficient binary” is a goal)
Track:
- peak RSS for representative workloads,
- allocations / object counts,
- GC pause time distribution (if/when GC is enabled).

Integrate at least “peak RSS” into perf smoke reporting if possible.

---

## 6. Recommended “next 10 commits” (prioritized)

### P0 (correctness + trust)
- [ ] Update README vs ROADMAP so “current limitations” is accurate.
- [ ] Add `docs/spec/STATUS.md` (or equivalent) as canonical capability snapshot.
- [ ] Add a short spec defining “verified subset” and its guarantees.

### P1 (ecosystem + deployment)
- [ ] Write the Molt Package ABI + versioning spec.
- [ ] Clarify wasm target: WASI-first or browser-first (you can support both later, but pick priority).
- [ ] Add “binary size + cold start” reporting to the bench harness.

### P2 (performance + maintainability)
- [ ] Add runtime safety invariants doc + sanitizer/fuzz/Miri plan.
- [ ] Expand differential tests around tricky Python semantics (descriptors, attribute resolution, exception chaining).

---

## 7. What you’re doing exceptionally well (keep leaning in)

- Treating **CI, differential testing, and perf regressions** as core requirements—not “later.”
- Writing **specs early** and linking them from README (big signal of seriousness).
- Building a credible “deploy everywhere” story (native + wasm + WIT).
- Picking the right subset approach: *typed, struct-like Python* is the highest ROI path to “Python ergonomics with compiled performance.”

---

## Appendix: Suggested file placement

Commit this document as one of:

- `docs/spec/areas/process/0099_REPO_REVIEW_2026-01-07.md` (time-stamped review; add more later)
- `docs/spec/STATUS.md` (living document; keep updated)

If you choose the living approach, keep **time-stamped benchmark summaries** in the README (or `bench/README.md`) and keep **architectural truth** in `docs/spec/`.
