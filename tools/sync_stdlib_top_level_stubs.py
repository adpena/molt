#!/usr/bin/env python3
"""
Synchronize top-level stdlib coverage stubs with the CPython union baseline.

This script compares `tools/stdlib_module_union.py` to the actual top-level
entries under `src/molt/stdlib` and reports missing names.

`--write` creates intrinsic-first placeholder stubs for missing entries.
Without `--write`, this script is a dry run suitable for CI/local checks.
"""

from __future__ import annotations

import argparse
import runpy
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
STDLIB_ROOT = ROOT / "src" / "molt" / "stdlib"
BASELINE = ROOT / "tools" / "stdlib_module_union.py"


def _load_baseline() -> tuple[frozenset[str], frozenset[str]]:
    if not BASELINE.exists():
        raise RuntimeError(f"baseline missing: {BASELINE}")
    namespace = runpy.run_path(str(BASELINE))
    modules = namespace.get("STDLIB_MODULE_UNION")
    packages = namespace.get("STDLIB_PACKAGE_UNION")
    if not isinstance(modules, tuple) or not isinstance(packages, tuple):
        raise RuntimeError("baseline missing required tuple constants")
    return frozenset(modules), frozenset(packages)


def _top_level_entries() -> tuple[set[str], set[str]]:
    files: set[str] = set()
    packages: set[str] = set()
    for path in STDLIB_ROOT.rglob("*.py"):
        if path.name.startswith("."):
            continue
        rel = path.relative_to(STDLIB_ROOT)
        if path.name == "__init__.py":
            if len(rel.parts) == 1:
                continue
            if len(rel.parts) == 2:
                packages.add(rel.parts[0])
            continue
        if len(rel.parts) == 1:
            files.add(path.stem)
    return files, packages


def _stub_text(name: str) -> str:
    return (
        '"""Intrinsic-first top-level stdlib stub.\n'
        "\n"
        f"Module: `{name}`\n"
        "Generated by tools/sync_stdlib_top_level_stubs.py to keep Molt top-level\n"
        "stdlib coverage synchronized with CPython 3.12/3.13/3.14.\n"
        '"""\n'
        "\n"
        "from _intrinsics import require_intrinsic as _require_intrinsic\n"
        "\n"
        '_require_intrinsic("molt_capabilities_has", globals())\n'
        "\n"
        f"# TODO(stdlib-parity, owner:stdlib, milestone:SL3, priority:P1, status:planned): "
        f"replace `{name}` top-level stub with full intrinsic-backed lowering.\n"
        "def __getattr__(attr: str):\n"
        "    raise RuntimeError(\n"
        f'        "stdlib module \\"{name}\\" is not fully lowered yet; only an intrinsic-first stub is available."\n'
        "    )\n"
    )


def main() -> int:
    parser = argparse.ArgumentParser(
        description=(
            "Create intrinsic-first top-level stdlib stubs for entries required by "
            "tools/stdlib_module_union.py that are currently missing."
        )
    )
    parser.add_argument(
        "--write",
        action="store_true",
        help="Write missing stubs. Without this flag the command is a dry run.",
    )
    args = parser.parse_args()

    required_modules, required_packages = _load_baseline()
    files, packages = _top_level_entries()
    present = files | packages
    missing = sorted(required_modules - present)
    if not missing:
        print("no missing top-level stdlib entries")
        return 0

    print(f"missing top-level stdlib entries: {len(missing)}")
    for name in missing:
        is_package = name in required_packages
        if is_package:
            target = STDLIB_ROOT / name / "__init__.py"
        else:
            target = STDLIB_ROOT / f"{name}.py"
        print(f"- {'package' if is_package else 'module'} {target.relative_to(ROOT)}")
        if not args.write:
            continue
        target.parent.mkdir(parents=True, exist_ok=True)
        if target.exists():
            continue
        target.write_text(_stub_text(name), encoding="utf-8")
    if not args.write:
        print("dry run only; rerun with --write to create stubs")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
