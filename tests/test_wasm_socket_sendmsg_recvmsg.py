import shutil
import subprocess
from pathlib import Path

import pytest


def test_wasm_socket_sendmsg_recvmsg_parity() -> None:
    """Validate wasm socket-host msg metadata/control payload wire format.

    This worker RPC path backs both recvmsg and recvmsg_into host intrinsics.
    """
    if shutil.which("node") is None:
        pytest.skip("node is required for wasm socket worker parity test")

    root = Path(__file__).resolve().parents[1]
    runner = root / "run_wasm.js"
    script = (
        "const { Worker } = require('worker_threads');\n"
        f"const RUNNER = {str(runner)!r};\n"
        "const AF_INET = 2;\n"
        "const SOCK_STREAM = 1;\n"
        "const MSG_PEEK = 2;\n"
        "const SOCKET_SAB_HEADER_SIZE = 32;\n"
        "const SOCKET_SAB_DATA_OFFSET = SOCKET_SAB_HEADER_SIZE;\n"
        "const readHandleParts = (view, index) => {\n"
        "  const lo = BigInt(view[index] >>> 0);\n"
        "  const hi = BigInt(view[index + 1] >>> 0);\n"
        "  let value = (hi << 32n) | lo;\n"
        "  if (value & 0x8000000000000000n) value -= 1n << 64n;\n"
        "  return value;\n"
        "};\n"
        "const encodeAncillaryPayload = (items) => {\n"
        "  let total = 4;\n"
        "  for (const item of items) total += 12 + item.data.length;\n"
        "  const out = Buffer.alloc(total);\n"
        "  out.writeUInt32LE(items.length, 0);\n"
        "  let offset = 4;\n"
        "  for (const item of items) {\n"
        "    out.writeInt32LE(item.level | 0, offset);\n"
        "    offset += 4;\n"
        "    out.writeInt32LE(item.kind | 0, offset);\n"
        "    offset += 4;\n"
        "    out.writeUInt32LE(item.data.length, offset);\n"
        "    offset += 4;\n"
        "    item.data.copy(out, offset);\n"
        "    offset += item.data.length;\n"
        "  }\n"
        "  return out;\n"
        "};\n"
        "const decodeAncillaryPayload = (payload) => {\n"
        "  if (!payload || payload.length < 4) throw new Error('short ancillary payload');\n"
        "  const count = payload.readUInt32LE(0);\n"
        "  let offset = 4;\n"
        "  const out = [];\n"
        "  for (let i = 0; i < count; i += 1) {\n"
        "    if (offset + 12 > payload.length) throw new Error('truncated ancillary payload');\n"
        "    const level = payload.readInt32LE(offset);\n"
        "    offset += 4;\n"
        "    const kind = payload.readInt32LE(offset);\n"
        "    offset += 4;\n"
        "    const len = payload.readUInt32LE(offset);\n"
        "    offset += 4;\n"
        "    const end = offset + len;\n"
        "    if (end > payload.length) throw new Error('truncated ancillary data');\n"
        "    out.push({ level, kind, data: payload.subarray(offset, end) });\n"
        "    offset = end;\n"
        "  }\n"
        "  if (offset !== payload.length) throw new Error('ancillary trailing bytes');\n"
        "  return out;\n"
        "};\n"
        "const decodeRecvmsgExtra = (extra) => {\n"
        "  if (!extra || extra.length < 8) throw new Error('short recvmsg extra');\n"
        "  const addrLen = extra.readUInt32LE(0);\n"
        "  const addrStart = 4;\n"
        "  const addrEnd = addrStart + addrLen;\n"
        "  if (addrEnd + 4 > extra.length) throw new Error('truncated recvmsg extra');\n"
        "  const ancLen = extra.readUInt32LE(addrEnd);\n"
        "  const ancStart = addrEnd + 4;\n"
        "  const ancEnd = ancStart + ancLen;\n"
        "  if (ancEnd > extra.length || ancEnd !== extra.length) throw new Error('invalid recvmsg extra');\n"
        "  return { addr: extra.subarray(addrStart, addrEnd), ancillary: extra.subarray(ancStart, ancEnd) };\n"
        "};\n"
        "const call = (worker, op, request, cap = 0, timeoutMs = 5000) => {\n"
        "  const sab = new SharedArrayBuffer(SOCKET_SAB_HEADER_SIZE + cap);\n"
        "  const header = new Int32Array(sab, 0, SOCKET_SAB_HEADER_SIZE / 4);\n"
        "  const dataView = new Uint8Array(sab, SOCKET_SAB_DATA_OFFSET);\n"
        "  worker.postMessage({ type: 'request', op, request, sab });\n"
        "  const waitRes = Atomics.wait(header, 0, 0, timeoutMs);\n"
        "  if (waitRes === 'timed-out') throw new Error(`socket host ${op} timed out`);\n"
        "  const status = header[1] | 0;\n"
        "  const dataLen = header[2] >>> 0;\n"
        "  const extraLen = header[7] >>> 0;\n"
        "  const dataCopyLen = Math.min(dataLen, dataView.length);\n"
        "  const data = dataCopyLen ? Buffer.from(dataView.subarray(0, dataCopyLen)) : Buffer.alloc(0);\n"
        "  const extraCopyLen = Math.min(extraLen, dataView.length - dataCopyLen);\n"
        "  const extra = extraCopyLen\n"
        "    ? Buffer.from(dataView.subarray(dataCopyLen, dataCopyLen + extraCopyLen))\n"
        "    : Buffer.alloc(0);\n"
        "  const handle1 = readHandleParts(header, 3);\n"
        "  const handle2 = readHandleParts(header, 5);\n"
        "  return { status, data, extra, dataLen, extraLen, handle1, handle2 };\n"
        "};\n"
        "const must = (cond, msg) => { if (!cond) throw new Error(msg); };\n"
        "(async () => {\n"
        "  const worker = new Worker(RUNNER, { workerData: { kind: 'molt_socket_host' } });\n"
        "  try {\n"
        "    const pair = call(worker, 'socketpair', { family: AF_INET, sockType: SOCK_STREAM, proto: 0 }, 0);\n"
        "    must(pair.status === 0, `socketpair failed: ${pair.status}`);\n"
        "    const left = Number(pair.handle1);\n"
        "    const right = Number(pair.handle2);\n"
        "    const anc1 = encodeAncillaryPayload([{ level: 1, kind: 2, data: Buffer.from('ancillary') }]);\n"
        "    const send1 = call(worker, 'sendmsg', {\n"
        "      handle: left,\n"
        "      payload: Buffer.from('abcdef'),\n"
        "      flags: 0,\n"
        "      addr: Buffer.alloc(0),\n"
        "      ancillary: anc1,\n"
        "    }, 0);\n"
        "    must(send1.status === 6, `sendmsg 1 failed: ${send1.status}`);\n"
        "    const recv1 = call(worker, 'recvmsg', { handle: right, size: 3, flags: 0 }, 1024);\n"
        "    must(recv1.status === 3, `recvmsg 1 status: ${recv1.status}`);\n"
        "    must(recv1.data.toString('utf8') === 'abc', `recvmsg 1 data mismatch: ${recv1.data.toString('hex')}`);\n"
        "    must(Number(recv1.handle1) === 0, `recvmsg 1 flags mismatch: ${recv1.handle1}`);\n"
        "    const extra1 = decodeRecvmsgExtra(recv1.extra);\n"
        "    must(extra1.addr.length > 0, 'recvmsg 1 addr expected non-empty');\n"
        "    const decodedAnc1 = decodeAncillaryPayload(extra1.ancillary);\n"
        "    must(decodedAnc1.length === 1, 'recvmsg 1 ancillary length mismatch');\n"
        "    must(decodedAnc1[0].level === 1 && decodedAnc1[0].kind === 2, 'recvmsg 1 ancillary header mismatch');\n"
        "    must(decodedAnc1[0].data.equals(Buffer.from('ancillary')), 'recvmsg 1 ancillary data mismatch');\n"
        "    const recv2 = call(worker, 'recvmsg', { handle: right, size: 16, flags: 0 }, 1024);\n"
        "    must(recv2.status === 3, `recvmsg 2 status: ${recv2.status}`);\n"
        "    must(recv2.data.toString('utf8') === 'def', 'recvmsg 2 data mismatch');\n"
        "    const extra2 = decodeRecvmsgExtra(recv2.extra);\n"
        "    must(extra2.addr.length > 0, 'recvmsg 2 addr expected non-empty');\n"
        "    const decodedAnc2 = decodeAncillaryPayload(extra2.ancillary);\n"
        "    must(decodedAnc2.length === 0, 'recvmsg 2 ancillary should be empty');\n"
        "    const anc3 = encodeAncillaryPayload([{ level: 9, kind: 10, data: Buffer.from('peekmeta') }]);\n"
        "    const send3 = call(worker, 'sendmsg', {\n"
        "      handle: left,\n"
        "      payload: Buffer.from('ghijkl'),\n"
        "      flags: 0,\n"
        "      addr: Buffer.alloc(0),\n"
        "      ancillary: anc3,\n"
        "    }, 0);\n"
        "    must(send3.status === 6, `sendmsg 3 failed: ${send3.status}`);\n"
        "    const peek1 = call(worker, 'recvmsg', { handle: right, size: 3, flags: MSG_PEEK }, 1024);\n"
        "    must(peek1.status === 3, `recvmsg peek status: ${peek1.status}`);\n"
        "    must(peek1.data.toString('utf8') === 'ghi', `recvmsg peek data mismatch: ${peek1.data.toString('hex')}`);\n"
        "    must(Number(peek1.handle1) === 0, `recvmsg peek flags mismatch: ${peek1.handle1}`);\n"
        "    const peekExtra = decodeRecvmsgExtra(peek1.extra);\n"
        "    const peekAnc = decodeAncillaryPayload(peekExtra.ancillary);\n"
        "    must(peekAnc.length === 1, 'recvmsg peek ancillary length mismatch');\n"
        "    must(peekAnc[0].level === 9 && peekAnc[0].kind === 10, 'recvmsg peek ancillary header mismatch');\n"
        "    must(peekAnc[0].data.equals(Buffer.from('peekmeta')), 'recvmsg peek ancillary data mismatch');\n"
        "    const recv3 = call(worker, 'recvmsg', { handle: right, size: 3, flags: 0 }, 1024);\n"
        "    must(recv3.status === 3, `recvmsg 3 status: ${recv3.status}`);\n"
        "    must(recv3.data.toString('utf8') === 'ghi', `recvmsg 3 data mismatch: ${recv3.data.toString('hex')}`);\n"
        "    const extra3 = decodeRecvmsgExtra(recv3.extra);\n"
        "    const decodedAnc3 = decodeAncillaryPayload(extra3.ancillary);\n"
        "    must(decodedAnc3.length === 1, 'recvmsg 3 ancillary length mismatch');\n"
        "    must(decodedAnc3[0].level === 9 && decodedAnc3[0].kind === 10, 'recvmsg 3 ancillary header mismatch');\n"
        "    must(decodedAnc3[0].data.equals(Buffer.from('peekmeta')), 'recvmsg 3 ancillary data mismatch');\n"
        "    const recv4 = call(worker, 'recvmsg', { handle: right, size: 16, flags: 0 }, 1024);\n"
        "    must(recv4.status === 3, `recvmsg 4 status: ${recv4.status}`);\n"
        "    must(recv4.data.toString('utf8') === 'jkl', `recvmsg 4 data mismatch: ${recv4.data.toString('hex')}`);\n"
        "    const extra4 = decodeRecvmsgExtra(recv4.extra);\n"
        "    const decodedAnc4 = decodeAncillaryPayload(extra4.ancillary);\n"
        "    must(decodedAnc4.length === 0, 'recvmsg 4 ancillary should be empty');\n"
        "    call(worker, 'close', { handle: left }, 0);\n"
        "    call(worker, 'close', { handle: right }, 0);\n"
        "    console.log('ok');\n"
        "  } finally {\n"
        "    await worker.terminate();\n"
        "  }\n"
        "})().catch((err) => {\n"
        "  console.error(err && err.stack ? err.stack : String(err));\n"
        "  process.exit(1);\n"
        "});\n"
    )

    run = subprocess.run(
        ["node", "-e", script],
        cwd=root,
        capture_output=True,
        text=True,
    )
    assert run.returncode == 0, run.stderr
    assert run.stdout.strip() == "ok"
